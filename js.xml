<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/home/travis/haxe/std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<impl><class path="_Any.Any_Impl_" params="" file="/home/travis/haxe/std/Any.hx" private="1" module="Any"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Array" params="T" file="/home/travis/haxe/std/js/_std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<iterator public="1" get="inline" set="null" line="85">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/home/travis/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/home/travis/haxe/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="46" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="50" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="54" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" get="inline" set="null" line="42">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="js.lib.RegExp" params="" file="/home/travis/haxe/std/js/lib/RegExp.hx" extern="1">
		<global public="1" set="null"><x path="Bool"/></global>
		<ignoreCase public="1" set="null"><x path="Bool"/></ignoreCase>
		<multiline public="1" set="null"><x path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<exec public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Null"><c path="js.lib.RegExpMatch"/></x>
</f></exec>
		<test public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></test>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="pattern:?flags">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Native JavaScript regular expressions.

	For cross-platform regular expressions, use Haxe `EReg` class or
	[regexp literals](https://haxe.org/manual/std-regex.html).</haxe_doc>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<class path="_EReg.HaxeRegExp" params="" file="/home/travis/haxe/std/js/_std/EReg.hx" private="1" module="EReg" extern="1">
		<extends path="js.lib.RegExp"/>
		<m public="1"><c path="js.lib.RegExpMatch"/></m>
		<s public="1"><c path="String"/></s>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<abstract path="Enum" params="T" file="/home/travis/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/home/travis/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/home/travis/haxe/std/EnumValue.hx" private="1" module="EnumValue"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="js.Syntax" params="" file="/home/travis/haxe/std/js/Syntax.hx" extern="1">
		<code public="1" set="method" static="1">
			<f a="code:args">
				<c path="String"/>
				<x path="haxe.extern.Rest"><d/></x>
				<d/>
			</f>
			<haxe_doc>Inject `code` directly into generated source.

		`code` must be a string constant.

		Additional `args` are supported to provide code interpolation, for example:
		```haxe
		Syntax.code("console.log({0}, {1})", "hi", 42);
		```
		will generate
		```haxe
		console.log("hi", 42);
		```

		Emits a compilation error if the count of `args` does not match the count of placeholders in `code`.</haxe_doc>
		</code>
		<plainCode public="1" set="method" static="1">
			<f a="code">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Inject `code` directly into generated source.
		The same as `js.Syntax.code` except this one does not provide code interpolation.</haxe_doc>
		</plainCode>
		<construct public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="construct.T"/></x>
				<x path="haxe.extern.Rest"><d/></x>
				<c path="construct.T"/>
			</f>
			<haxe_doc>Generate `new cl(...args)` expression.</haxe_doc>
			<overloads><construct public="1" set="method">
	<f a="cl:args">
		<c path="String"/>
		<x path="haxe.extern.Rest"><d/></x>
		<d/>
	</f>
	<haxe_doc>Generate `new cl(...args)` expression.</haxe_doc>
</construct></overloads>
		</construct>
		<instanceof public="1" set="method" static="1">
			<f a="v:cl">
				<d/>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Generate `v instanceof cl` expression.</haxe_doc>
		</instanceof>
		<typeof public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Generate `typeof o` expression.</haxe_doc>
		</typeof>
		<strictEq public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Genearte `a === b` expression.</haxe_doc>
		</strictEq>
		<strictNeq public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Genearte `a !== b` expression.</haxe_doc>
		</strictNeq>
		<delete public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Generate `delete o[f]` expression.</haxe_doc>
			<overloads><delete public="1" set="method">
	<f a="o:f">
		<d/>
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Generate `delete o[f]` expression.</haxe_doc>
</delete></overloads>
		</delete>
		<field public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Generate `o.f` expression, if `f` is a constant string,
		or `o[f]` if it's any other expression.</haxe_doc>
		</field>
		<haxe_doc>Generate JavaScript syntax not directly supported by Haxe.
	Use only at low-level when specific target-specific code-generation is required.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noClosure"/>
		</meta>
	</class>
	<class path="js.lib.Date" params="" file="/home/travis/haxe/std/js/lib/Date.hx" extern="1">
		<fromHaxeDate public="1" get="inline" set="null" line="40" static="1">
			<f a="date">
				<t path="_Date.HaxeDate"/>
				<c path="js.lib.Date"/>
			</f>
			<haxe_doc>Cast Haxe's Date to js.lib.Date.</haxe_doc>
		</fromHaxeDate>
		<toHaxeDate public="1" get="inline" set="null" line="47" static="1">
			<f a="date">
				<c path="js.lib.Date"/>
				<t path="_Date.HaxeDate"/>
			</f>
			<haxe_doc>Cast js.lib.Date to Haxe's Date.</haxe_doc>
		</toHaxeDate>
		<now public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the numeric value corresponding to the current time - the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored</haxe_doc>
		</now>
		<parse public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Parses a string representation of a date and returns the number of milliseconds since 1 January, 1970, 00:00:00, UTC, with leap seconds ignored.</haxe_doc>
		</parse>
		<UTC public="1" set="method" static="1">
			<f a="year:month:?day:?hours:?minutes:?seconds:?milliseconds">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the number of milliseconds since January 1, 1970, 00:00:00 UTC, with leap seconds ignored.</haxe_doc>
		</UTC>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the month (1-31) for the specified date according to local time.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week (0-6) for the specified date according to local time.</haxe_doc>
		</getDay>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year (4 digits for 4-digit years) of the specified date according to local time.</haxe_doc>
		</getFullYear>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hour (0-23) in the specified date according to local time.</haxe_doc>
		</getHours>
		<getMilliseconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the milliseconds (0-999) in the specified date according to local time.</haxe_doc>
		</getMilliseconds>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes (0-59) in the specified date according to local time.</haxe_doc>
		</getMinutes>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month (0-11) in the specified date according to local time.</haxe_doc>
		</getMonth>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds (0-59) in the specified date according to local time.</haxe_doc>
		</getSeconds>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970, 00:00:00 UTC (negative for prior times).</haxe_doc>
		</getTime>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time-zone offset in minutes for the current locale.</haxe_doc>
		</getTimezoneOffset>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day (date) of the month (1-31) in the specified date according to universal time.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week (0-6) in the specified date according to universal time.</haxe_doc>
		</getUTCDay>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year (4 digits for 4-digit years) in the specified date according to universal time.</haxe_doc>
		</getUTCFullYear>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours (0-23) in the specified date according to universal time.</haxe_doc>
		</getUTCHours>
		<getUTCMilliseconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the milliseconds (0-999) in the specified date according to universal time.</haxe_doc>
		</getUTCMilliseconds>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes (0-59) in the specified date according to universal time.</haxe_doc>
		</getUTCMinutes>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month (0-11) in the specified date according to universal time.</haxe_doc>
		</getUTCMonth>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds (0-59) in the specified date according to universal time.</haxe_doc>
		</getUTCSeconds>
		<setDate public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the day of the month for a specified date according to local time.</haxe_doc>
		</setDate>
		<setFullYear public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time.</haxe_doc>
		</setFullYear>
		<setHours public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hours for a specified date according to local time.</haxe_doc>
		</setHours>
		<setMilliseconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the milliseconds for a specified date according to local time.</haxe_doc>
		</setMilliseconds>
		<setMinutes public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the minutes for a specified date according to local time.</haxe_doc>
		</setMinutes>
		<setMonth public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the month for a specified date according to local time.</haxe_doc>
		</setMonth>
		<setSeconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the seconds for a specified date according to local time.</haxe_doc>
		</setSeconds>
		<setTime public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC, allowing for negative numbers for times prior.</haxe_doc>
		</setTime>
		<setUTCDate public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the day of the month for a specified date according to universal time.</haxe_doc>
		</setUTCDate>
		<setUTCFullYear public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time.</haxe_doc>
		</setUTCFullYear>
		<setUTCHours public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hour for a specified date according to universal time.</haxe_doc>
		</setUTCHours>
		<setUTCMilliseconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the milliseconds for a specified date according to universal time.</haxe_doc>
		</setUTCMilliseconds>
		<setUTCMinutes public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the minutes for a specified date according to universal time.</haxe_doc>
		</setUTCMinutes>
		<setUTCMonth public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the month for a specified date according to universal time.</haxe_doc>
		</setUTCMonth>
		<setUTCSeconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the seconds for a specified date according to universal time.</haxe_doc>
		</setUTCSeconds>
		<toDateString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the "date" portion of the Date as a human-readable string.</haxe_doc>
		</toDateString>
		<toISOString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Converts a date to a string following the ISO 8601 Extended Format.</haxe_doc>
		</toISOString>
		<toJSON public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the Date using toISOString(). Intended for use by JSON.stringify().</haxe_doc>
		</toJSON>
		<toLocaleDateString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of the date portion of this date based on system settings.</haxe_doc>
			<overloads><toLocaleDateString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of the date portion of this date based on system settings.</haxe_doc>
</toLocaleDateString></overloads>
		</toLocaleDateString>
		<toLocaleFormat public="1" set="method">
			<f a="format">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts a date to a string, using a format string.</haxe_doc>
		</toLocaleFormat>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.</haxe_doc>
			<overloads><toLocaleString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.</haxe_doc>
</toLocaleString></overloads>
		</toLocaleString>
		<toLocaleTimeString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of the time portion of this date based on system settings.</haxe_doc>
			<overloads><toLocaleTimeString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of the time portion of this date based on system settings.</haxe_doc>
</toLocaleTimeString></overloads>
		</toLocaleTimeString>
		<toSource public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the source for an equivalent Date object; you can use this value to create a new object. Overrides the Object.prototype.toSource() method.</haxe_doc>
		</toSource>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.</haxe_doc>
		</toString>
		<toTimeString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the "time" portion of the Date as a human-readable string.</haxe_doc>
		</toTimeString>
		<toUTCString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Converts a date to a string using the UTC timezone.</haxe_doc>
		</toUTCString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="dateString">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="year:month:?day:?hours:?minutes:?seconds:?milliseconds">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<haxe_doc>Creates a JavaScript Date instance that represents a single moment in time. Date objects are based on a time value that is the number of milliseconds since 1 January 1970 UTC.</haxe_doc>
		<meta><m n=":native"><e>"Date"</e></m></meta>
	</class>
	<class path="Math" params="" file="/home/travis/haxe/std/js/_std/Math.hx" extern="1"><meta>
	<m n=":keep"/>
	<m n=":keepInit"/>
</meta></class>
	<class path="String" params="" file="/home/travis/haxe/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" get="inline" set="null" line="43" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex` (if `startIndex` is posivite
		or 0) or `max(this.length + startIndex, 0)` (if `startIndex` is negative).

		If `startIndex` exceeds `this.length`, -1 is returned.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/home/travis/haxe/std/js/_std/Std.hx">
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<abstract path="haxe.Function" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.DynamicAccess" params="T" file="/home/travis/haxe/std/haxe/DynamicAccess.hx">
		<from><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></from>
		<this><d><c path="haxe.DynamicAccess.T"/></d></this>
		<to><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></to>
		<haxe_doc>DynamicAccess is an abstract type for working with anonymous structures
	that are intended to hold collections of objects by the string key.

	For example, these types of structures are often created from JSON.

	Basically, it wraps `Reflect` calls in a `Map`-like interface.</haxe_doc>
		<impl><class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="/home/travis/haxe/std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/home/travis/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/home/travis/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="/home/travis/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/home/travis/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/home/travis/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/home/travis/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/home/travis/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/home/travis/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>concat</e>
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/travis/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The length of `this` Array.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/home/travis/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/home/travis/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.Rest" params="T" file="/home/travis/haxe/std/haxe/extern/Rest.hx">
		<this><c path="Array"><c path="haxe.extern.Rest.T"/></c></this>
		<haxe_doc><![CDATA[A special abstract type that represents "rest" function argument.

	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._Rest.Rest_Impl_" params="" file="/home/travis/haxe/std/haxe/extern/Rest.hx" private="1" module="haxe.extern.Rest"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.io.BytesData" params="" file="/home/travis/haxe/std/haxe/io/BytesData.hx"><c path="js.lib.ArrayBuffer"/></typedef>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/home/travis/haxe/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="43">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="51">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.lib.Error" params="" file="/home/travis/haxe/std/js/lib/Error.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<stack public="1" set="null"><c path="String"/></stack>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"Error"</e></m></meta>
	</class>
	<class path="js.lib.ArrayBuffer" params="" file="/home/travis/haxe/std/js/lib/ArrayBuffer.hx" extern="1">
		<isView public="1" set="method" static="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></isView>
		<byteLength final="1" public="1"><x path="Int"/></byteLength>
		<slice public="1" set="method"><f a="begin:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.lib.ArrayBuffer"/>
</f></slice>
		<new public="1" set="method">
			<f a="length">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"ArrayBuffer"</e></m></meta>
	</class>
	<class path="js.lib.ArrayBufferView" params="" file="/home/travis/haxe/std/js/lib/ArrayBufferView.hx" extern="1" interface="1">
		<buffer final="1" public="1"><c path="js.lib.ArrayBuffer"/></buffer>
		<byteOffset final="1" public="1"><x path="Int"/></byteOffset>
		<byteLength final="1" public="1"><x path="Int"/></byteLength>
		<haxe_doc><![CDATA[`ArrayBufferView` is a helper type representing any of the following JavaScript `TypedArray` types:

	Documentation [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).

	@see <https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView>]]></haxe_doc>
	</class>
	<class path="js.lib.Uint8Array" params="" file="/home/travis/haxe/std/js/lib/Uint8Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 1 in the case of an `Uint8Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Creates a new `Uint8Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Uint8Array"/>
	</f>
	<haxe_doc>Creates a new `Uint8Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Creates a new `Uint8Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Uint8Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Uint8Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Uint8Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Uint8Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint8Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint8Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Uint8Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Uint8Array` typed array represents an array of 8-bit unsigned integers. The contents
	are initialized to 0. Once established, you can reference elements in the array using the object's
	methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Uint8Array"</e></m></meta>
	</class>
	<class path="js.lib.DataView" params="" file="/home/travis/haxe/std/js/lib/DataView.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<buffer final="1" public="1"><c path="js.lib.ArrayBuffer"/></buffer>
		<byteOffset final="1" public="1"><x path="Int"/></byteOffset>
		<byteLength final="1" public="1"><x path="Int"/></byteLength>
		<getInt8 public="1" set="method"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt8>
		<getUint8 public="1" set="method"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getUint8>
		<getInt16 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getInt16>
		<getUint16 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getUint16>
		<getInt32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getInt32>
		<getUint32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getUint32>
		<getFloat32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getFloat32>
		<getFloat64 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getFloat64>
		<setInt8 public="1" set="method"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt8>
		<setUint8 public="1" set="method"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUint8>
		<setInt16 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setInt16>
		<setUint16 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUint16>
		<setInt32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setInt32>
		<setUint32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUint32>
		<setFloat32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFloat32>
		<setFloat64 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFloat64>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?byteLength">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"DataView"</e></m></meta>
	</class>
	<class path="js.lib.EvalError" params="" file="/home/travis/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"EvalError"</e></m></meta>
	</class>
	<class path="js.lib.RangeError" params="" file="/home/travis/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RangeError"</e></m></meta>
	</class>
	<class path="js.lib.ReferenceError" params="" file="/home/travis/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"ReferenceError"</e></m></meta>
	</class>
	<class path="js.lib.SyntaxError" params="" file="/home/travis/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"SyntaxError"</e></m></meta>
	</class>
	<class path="js.lib.TypeError" params="" file="/home/travis/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"TypeError"</e></m></meta>
	</class>
	<class path="js.lib.URIError" params="" file="/home/travis/haxe/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"URIError"</e></m></meta>
	</class>
	<class path="js.lib.Float32Array" params="" file="/home/travis/haxe/std/js/lib/Float32Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 4 in the case of an `Float32Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Float"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Creates a new `Float32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Float"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Float32Array"/>
	</f>
	<haxe_doc>Creates a new `Float32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Creates a new `Float32Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Float32Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Float32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Float32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Float32Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Float"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Float"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Float"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Float"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Float"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="js.lib.Float32Array"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Float"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="js.lib.Float32Array"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Float32Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="Array"><x path="Int"/></c>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float32Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Float"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Float32Array` typed array represents an array of 32-bit floating point numbers
	(corresponding to the C float data type) in the platform byte order. If control over byte order is
	needed, use `DataView` instead. The contents are initialized to `0`. Once established, you can
	reference elements in the array using the object's methods, or using standard array index
	syntax (that is, using bracket notation)

	Documentation [Float32Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Float32Array"</e></m></meta>
	</class>
	<class path="js.lib.Float64Array" params="" file="/home/travis/haxe/std/js/lib/Float64Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 8 in the case of an `Float64Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Float"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Creates a new `Float64Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Float"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Float64Array"/>
	</f>
	<haxe_doc>Creates a new `Float64Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Creates a new `Float64Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Float64Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Float64Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Float64Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Float64Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Float"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float64Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float64Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Float"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Float"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float64Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Float"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Float64Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Float"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="js.lib.Float64Array"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Float"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Float"/>
							<x path="Float"/>
							<x path="Int"/>
							<c path="js.lib.Float64Array"/>
							<x path="Int"/>
						</f>
						<x path="Float"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Float64Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="Array"><x path="Int"/></c>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Float"/>
					<x path="Int"/>
					<c path="js.lib.Float64Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Float"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Float"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Float64Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Float"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Float64Array` typed array represents an array of 64-bit floating point numbers
	(corresponding to the C double data type) in the platform byte order. If control over byte order
	is needed, use `DataView` instead. The contents are initialized to `0`. Once established, you can
	reference elements in the array using the object's methods, or using standard array index
	syntax (that is, using bracket notation).

	Documentation [Float64Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Float64Array"</e></m></meta>
	</class>
	<class path="js.lib.Function" params="" file="/home/travis/haxe/std/js/lib/Function.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Specifies the number of arguments expected by the function.</haxe_doc>
		</length>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the function.</haxe_doc>
		</name>
		<apply public="1" set="method">
			<f a="thisArg:argsArray">
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Calls a function and sets its this to the provided value, arguments can be passed as an Array object.</haxe_doc>
		</apply>
		<call public="1" set="method">
			<f a="thisArg:args">
				<d/>
				<x path="haxe.extern.Rest"><d/></x>
				<d/>
			</f>
			<haxe_doc>Calls (executes) a function and sets its this to the provided value, arguments can be passed as they are.</haxe_doc>
		</call>
		<bind public="1" set="method">
			<f a="thisArg:args">
				<d/>
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Function"/>
			</f>
			<haxe_doc>Creates a new function which, when called, has its this set to the provided value,
		with a given sequence of arguments preceding any provided when the new function was called.</haxe_doc>
		</bind>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the source code of the function.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="arg:rest">
				<c path="String"/>
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Function object.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Function"</e></m></meta>
	</class>
	<class path="js.lib.Int16Array" params="" file="/home/travis/haxe/std/js/lib/Int16Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 2 in the case of an `Int16Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Creates a new `Int16Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Int16Array"/>
	</f>
	<haxe_doc>Creates a new `Int16Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Creates a new `Int16Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Int16Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Int16Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Int16Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Int16Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int16Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int16Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int16Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int16Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int16Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int16Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Int16Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int16Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Int16Array` typed array represents an array of twos-complement 16-bit signed integers in
	the platform byte order. If control over byte order is needed, use `DataView` instead. The
	contents are initialized to 0. Once established, you can reference elements in the array using
	the object's methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Int16Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Int16Array"</e></m></meta>
	</class>
	<class path="js.lib.Int32Array" params="" file="/home/travis/haxe/std/js/lib/Int32Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 4 in the case of an `Int32Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Creates a new `Int32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Int32Array"/>
	</f>
	<haxe_doc>Creates a new `Int32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Creates a new `Int32Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Int32Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Int32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Int32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Int32Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int32Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int32Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Int32Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int32Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Int32Array` typed array represents an array of twos-complement 32-bit signed integers in
	the platform byte order. If control over byte order is needed, use `DataView` instead. The
	contents are initialized to `0`. Once established, you can reference elements in the array using
	the object's methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Int32Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Int32Array"</e></m></meta>
	</class>
	<class path="js.lib.Int8Array" params="" file="/home/travis/haxe/std/js/lib/Int8Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 1 in the case of an `Int8Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Creates a new `Int8Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Int8Array"/>
	</f>
	<haxe_doc>Creates a new `Int8Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Creates a new `Int8Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Int8Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Int8Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Int8Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Int8Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int8Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int8Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int8Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Int8Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int8Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Int8Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Int8Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Int8Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Int8Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Int8Array` typed array represents an array of twos-complement 8-bit signed integers. The
	contents are initialized to 0. Once established, you can reference elements in the array using
	the object's methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Int8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Int8Array"</e></m></meta>
	</class>
	<typedef path="js.lib.Iterator" params="T" file="/home/travis/haxe/std/js/lib/Iterator.hx">
		<a><next set="method"><f a=""><t path="js.lib.IteratorStep"><c path="js.lib.Iterator.T"/></t></f></next></a>
		<haxe_doc>Native JavaScript iterator structure. To enable haxe for-in iteration, use `js.lib.HaxeIterator`, for example `for (v in new js.lib.HaxeIterator(jsIterator))` or add `using js.lib.HaxeIterator;` to your module

	See [Iteration Protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)</haxe_doc>
	</typedef>
	<typedef path="js.lib.AsyncIterator" params="T" file="/home/travis/haxe/std/js/lib/Iterator.hx" module="js.lib.Iterator">
		<a><next set="method"><f a=""><c path="js.lib.Promise"><t path="js.lib.IteratorStep"><c path="js.lib.AsyncIterator.T"/></t></c></f></next></a>
		<haxe_doc>Native JavaScript async iterator structure. 

	See [for await...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)</haxe_doc>
	</typedef>
	<typedef path="js.lib.IteratorStep" params="T" file="/home/travis/haxe/std/js/lib/Iterator.hx" module="js.lib.Iterator"><a>
	<value>
		<x path="Null"><c path="js.lib.IteratorStep.T"/></x>
		<meta><m n=":optional"/></meta>
	</value>
	<done><x path="Bool"/></done>
</a></typedef>
	<abstract path="js.lib.KeyValue" params="K:V" file="/home/travis/haxe/std/js/lib/KeyValue.hx">
		<this><c path="Array"><x path="Any"/></c></this>
		<haxe_doc>Key/value access helper.</haxe_doc>
		<impl><class path="js.lib._KeyValue.KeyValue_Impl_" params="" file="/home/travis/haxe/std/js/lib/KeyValue.hx" private="1" module="js.lib.KeyValue">
	<key public="1" get="accessor" set="null" static="1">
		<c path="js.lib.KeyValue.K"/>
		<meta><m n=":impl"/></meta>
	</key>
	<value public="1" get="accessor" set="null" static="1">
		<c path="js.lib.KeyValue.V"/>
		<meta><m n=":impl"/></meta>
	</value>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="js.lib.Object" params="" file="/home/travis/haxe/std/js/lib/Object.hx" extern="1">
		<assign public="1" params="T" set="method" static="1">
			<f a="target:sources">
				<c path="assign.T"/>
				<x path="haxe.extern.Rest"><a/></x>
				<c path="assign.T"/>
			</f>
			<haxe_doc>Copies the values of all enumerable own properties from one or more
		source objects to a target object.</haxe_doc>
		</assign>
		<create public="1" params="T" set="method" static="1">
			<f a="proto:?propertiesObject">
				<a/>
				<x path="haxe.DynamicAccess"><t path="js.lib.ObjectPropertyDescriptor"/></x>
				<c path="create.T"/>
			</f>
			<haxe_doc>Creates a new object with the specified prototype object and properties.</haxe_doc>
		</create>
		<defineProperties public="1" params="T" set="method" static="1">
			<f a="obj:props">
				<c path="defineProperties.T"/>
				<x path="haxe.DynamicAccess"><t path="js.lib.ObjectPropertyDescriptor"/></x>
				<c path="defineProperties.T"/>
			</f>
			<haxe_doc>Adds the named properties described by the given descriptors to an object.</haxe_doc>
		</defineProperties>
		<defineProperty public="1" params="T" set="method" static="1">
			<f a="obj:prop:descriptor">
				<c path="defineProperty.T"/>
				<c path="String"/>
				<t path="js.lib.ObjectPropertyDescriptor"/>
				<c path="defineProperty.T"/>
			</f>
			<haxe_doc>Adds the named property described by a given descriptor to an object.</haxe_doc>
		</defineProperty>
		<entries public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><x path="js.lib.ObjectEntry"/></c>
			</f>
			<haxe_doc>Returns an array containing all of the [key, value] pairs of a given
		object's own enumerable string properties.</haxe_doc>
		</entries>
		<freeze public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="freeze.T"/>
				<c path="freeze.T"/>
			</f>
			<haxe_doc>Freezes an object: other code can't delete or change any properties.</haxe_doc>
		</freeze>
		<fromEntries public="1" params="T" set="method" static="1">
			<f a="iterable">
				<x path="Any"/>
				<c path="fromEntries.T"/>
			</f>
			<haxe_doc>Returns a new object from an iterable of key-value pairs
		(reverses Object.entries).</haxe_doc>
		</fromEntries>
		<getOwnPropertyDescriptor public="1" set="method" static="1">
			<f a="obj:prop">
				<a/>
				<c path="String"/>
				<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
			</f>
			<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
		</getOwnPropertyDescriptor>
		<getOwnPropertyNames public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing the names of all of the given object's own
		enumerable and non-enumerable properties.</haxe_doc>
		</getOwnPropertyNames>
		<getOwnPropertySymbols public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="js.lib.Symbol"/></c>
			</f>
			<haxe_doc>Returns an array of all symbol properties found directly upon a given object.</haxe_doc>
		</getOwnPropertySymbols>
		<getPrototypeOf public="1" params="TProto" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Null"><c path="getPrototypeOf.TProto"/></x>
			</f>
			<haxe_doc>Returns the prototype of the specified object.</haxe_doc>
		</getPrototypeOf>
		<is public="1" params="T" set="method" static="1">
			<f a="value1:value2">
				<c path="is.T"/>
				<c path="is.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares if two values are the same value. Equates all NaN values
		(which differs from both Abstract Equality Comparison and
		Strict Equality Comparison).</haxe_doc>
		</is>
		<isExtensible public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if extending of an object is allowed.</haxe_doc>
		</isExtensible>
		<isFrozen public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if an object was frozen.</haxe_doc>
		</isFrozen>
		<isSealed public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if an object is sealed.</haxe_doc>
		</isSealed>
		<keys public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing the names of all of the given object's own
		enumerable string properties.</haxe_doc>
		</keys>
		<preventExtensions public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="preventExtensions.T"/>
				<c path="preventExtensions.T"/>
			</f>
			<haxe_doc>Prevents any extensions of an object.</haxe_doc>
		</preventExtensions>
		<seal public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="seal.T"/>
				<c path="seal.T"/>
			</f>
			<haxe_doc>Prevents other code from deleting properties of an object.</haxe_doc>
		</seal>
		<setPrototypeOf public="1" params="T" set="method" static="1">
			<f a="obj:prototype">
				<c path="setPrototypeOf.T"/>
				<x path="Null"><a/></x>
				<c path="setPrototypeOf.T"/>
			</f>
			<haxe_doc>Sets the prototype (i.e., the internal Prototype property).</haxe_doc>
		</setPrototypeOf>
		<values public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><x path="Any"/></c>
			</f>
			<haxe_doc>Returns an array containing the values that correspond to all of
		a given object's own enumerable string properties.</haxe_doc>
		</values>
		<prototype public="1" set="null" static="1">
			<t path="js.lib.ObjectPrototype"/>
			<haxe_doc>Allows the addition of properties to all objects of type Object.</haxe_doc>
		</prototype>
		<new public="1" set="method">
			<f a="?value">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>The Object constructor creates an object wrapper.</haxe_doc>
		</new>
		<haxe_doc>The `js.lib.Object` constructor creates an object wrapper.

	Documentation [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Object"</e></m></meta>
	</class>
	<typedef path="js.lib.ObjectPrototype" params="" file="/home/travis/haxe/std/js/lib/Object.hx" module="js.lib.Object">
		<a>
			<valueOf set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns the primitive value of the specified object.</haxe_doc>
			</valueOf>
			<toString set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a string representation of the object.</haxe_doc>
			</toString>
			<toLocaleString set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Calls `toString()`.</haxe_doc>
			</toLocaleString>
			<propertyIsEnumerable set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating if the internal enumerable attribute is set.</haxe_doc>
			</propertyIsEnumerable>
			<isPrototypeOf set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating whether the object this method is called
		upon is in the prototype chain of the specified object.</haxe_doc>
			</isPrototypeOf>
			<hasOwnProperty set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating whether an object contains the specified
		property as a direct property of that object and not inherited through
		the prototype chain.</haxe_doc>
			</hasOwnProperty>
		</a>
		<haxe_doc><![CDATA[Type for
	@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>]]></haxe_doc>
	</typedef>
	<typedef path="js.lib.ObjectPropertyDescriptor" params="" file="/home/travis/haxe/std/js/lib/Object.hx" module="js.lib.Object">
		<a>
			<writable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if the value associated with the property may be
		changed with an assignment operator.

		Defaults to `false`.</haxe_doc>
			</writable>
			<value>
				<x path="Null"><x path="Any"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The value associated with the property.
		Can be any valid JavaScript value (number, object, function, etc).</haxe_doc>
			</value>
			<set>
				<x path="Null"><f a="">
	<x path="Any"/>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A function which serves as a setter for the property, or undefined if
		there is no setter. When the property is assigned to, this function
		is called with one argument (the value being assigned to the property)
		and with `this` set to the object through which the property is assigned.</haxe_doc>
			</set>
			<get>
				<x path="Null"><f a=""><x path="Any"/></f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A function which serves as a getter for the property, or `undefined` if
		there is no getter. When the property is accessed, this function is
		called without arguments and with `this` set to the object through which
		the property is accessed (this may not be the object on which the
		property is defined due to inheritance).
		The return value will be used as the value of the property.</haxe_doc>
			</get>
			<enumerable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if this property shows up during enumeration of the
		properties on the corresponding object.

		Defaults to `false`.</haxe_doc>
			</enumerable>
			<configurable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if the type of this property descriptor may be
		changed and if the property may be deleted from the corresponding object.

		Defaults to `false`.</haxe_doc>
			</configurable>
		</a>
		<haxe_doc><![CDATA[@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>]]></haxe_doc>
	</typedef>
	<abstract path="js.lib.ObjectEntry" params="" file="/home/travis/haxe/std/js/lib/Object.hx" module="js.lib.Object">
		<this><c path="Array"><x path="Any"/></c></this>
		<haxe_doc>Key/value access helper for `js.lib.Object.entries()`.</haxe_doc>
		<impl><class path="js.lib._Object.ObjectEntry_Impl_" params="" file="/home/travis/haxe/std/js/lib/Object.hx" private="1" module="js.lib.Object">
	<key public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
	</key>
	<value public="1" get="accessor" set="null" static="1">
		<x path="Any"/>
		<meta><m n=":impl"/></meta>
	</value>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="js.lib.Promise" params="T" file="/home/travis/haxe/std/js/lib/Promise.hx" extern="1">
		<resolve public="1" params="T" set="method" static="1">
			<f a="thenable">
				<x path="js.lib.Thenable"><c path="resolve.T"/></x>
				<c path="js.lib.Promise"><c path="resolve.T"/></c>
			</f>
			<haxe_doc>Returns a Promise object that is resolved with the given value. If the
		value is Thenable, the returned promise will "follow" that
		thenable, adopting its eventual state;
		otherwise the returned promise will be fulfilled with the value.
		Generally, when it's unknown when value is a promise or not,
		use `Promise.resolve(value)` instead and work with the return value as
		a promise.</haxe_doc>
			<overloads><resolve public="1" params="T" set="method">
	<f a="?value">
		<c path="resolve.T"/>
		<c path="js.lib.Promise"><c path="resolve.T"/></c>
	</f>
	<haxe_doc>Returns a Promise object that is resolved with the given value. If the
		value is Thenable, the returned promise will "follow" that
		thenable, adopting its eventual state;
		otherwise the returned promise will be fulfilled with the value.
		Generally, when it's unknown when value is a promise or not,
		use `Promise.resolve(value)` instead and work with the return value as
		a promise.</haxe_doc>
</resolve></overloads>
		</resolve>
		<reject public="1" params="T" set="method" static="1">
			<f a="?reason">
				<d/>
				<c path="js.lib.Promise"><c path="reject.T"/></c>
			</f>
			<haxe_doc>Returns a Promise object that is rejected with the given reason.</haxe_doc>
		</reject>
		<all public="1" set="method" static="1">
			<f a="iterable">
				<c path="Array"><d/></c>
				<c path="js.lib.Promise"><c path="Array"><d/></c></c>
			</f>
			<haxe_doc>Returns a promise that either fulfills when all of the promises in the
		iterable argument have fulfilled or rejects as soon as one of the
		promises in the iterable argument rejects. If the returned promise
		fulfills, it is fulfilled with an array of the values from the
		fulfilled promises in the same order as defined in the iterable.
		If the returned promise rejects, it is rejected with the reason from
		the first promise in the iterable that rejected. This method can be
		useful for aggregating results of multiple promises.</haxe_doc>
		</all>
		<race public="1" set="method" static="1">
			<f a="iterable">
				<c path="Array"><d/></c>
				<c path="js.lib.Promise"><d/></c>
			</f>
			<haxe_doc>Returns a promise that fulfills or rejects as soon as one of the
		promises in the iterable fulfills or rejects, with the value or reason
		from that promise.</haxe_doc>
		</race>
		<then public="1" params="TOut" set="method">
			<f a="onFulfilled:?onRejected">
				<x path="Null"><x path="js.lib.PromiseHandler">
	<c path="js.lib.Promise.T"/>
	<c path="then.TOut"/>
</x></x>
				<x path="js.lib.PromiseHandler">
					<d/>
					<c path="then.TOut"/>
				</x>
				<c path="js.lib.Promise"><c path="then.TOut"/></c>
			</f>
			<haxe_doc>Appends fulfillment and rejection handlers to the promise and returns a
		new promise resolving to the return value of the called handler, or to
		its original settled value if the promise was not handled
		(i.e. if the relevant handler onFulfilled or onRejected is not a function).</haxe_doc>
		</then>
		<catchError public="1" params="TOut" set="method">
			<f a="onRejected">
				<x path="js.lib.PromiseHandler">
					<d/>
					<c path="catchError.TOut"/>
				</x>
				<c path="js.lib.Promise"><c path="catchError.TOut"/></c>
			</f>
			<meta><m n=":native"><e>"catch"</e></m></meta>
			<haxe_doc>Appends a rejection handler callback to the promise, and returns a new
		promise resolving to the return value of the callback if it is called,
		or to its original fulfillment value if the promise is instead fulfilled.</haxe_doc>
		</catchError>
		<new public="1" set="method">
			<f a="init">
				<f a="resolve:reject">
					<f a="value">
						<c path="js.lib.Promise.T"/>
						<x path="Void"/>
					</f>
					<f a="reason">
						<d/>
						<x path="Void"/>
					</f>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<haxe_doc>The Promise object represents the eventual completion (or failure) of an
	asynchronous operation and its resulting value.

	Documentation [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Promise"</e></m></meta>
	</class>
	<abstract path="js.lib.PromiseHandler" params="T:TOut" file="/home/travis/haxe/std/js/lib/Promise.hx" module="js.lib.Promise">
		<from>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<c path="js.lib.Promise"><c path="js.lib.PromiseHandler.TOut"/></c>
</f></icast>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<x path="js.lib.Thenable"><c path="js.lib.PromiseHandler.TOut"/></x>
</f></icast>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<c path="js.lib.PromiseHandler.TOut"/>
</f></icast>
		</from>
		<this><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<d/>
</f></this>
		<haxe_doc>Handler type for the Promise object.</haxe_doc>
		<impl><class path="js.lib._Promise.PromiseHandler_Impl_" params="" file="/home/travis/haxe/std/js/lib/Promise.hx" private="1" module="js.lib.Promise"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="js.lib.Thenable" params="T" file="/home/travis/haxe/std/js/lib/Promise.hx" module="js.lib.Promise">
		<from><icast><t path="js.lib.ThenableStruct"><c path="js.lib.Thenable.T"/></t></icast></from>
		<this><t path="js.lib.ThenableStruct"><c path="js.lib.Thenable.T"/></t></this>
		<haxe_doc>A value with a `then` method.</haxe_doc>
		<meta><m n=":forward"/></meta>
		<impl><class path="js.lib._Promise.Thenable_Impl_" params="" file="/home/travis/haxe/std/js/lib/Promise.hx" private="1" module="js.lib.Promise"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="js.lib.ThenableStruct" params="T" file="/home/travis/haxe/std/js/lib/Promise.hx" module="js.lib.Promise"><a><then params="TOut" set="method"><f a="onFulfilled:?onRejected">
	<x path="Null"><x path="js.lib.PromiseHandler">
	<c path="js.lib.ThenableStruct.T"/>
	<c path="then.TOut"/>
</x></x>
	<x path="js.lib.PromiseHandler">
		<d/>
		<c path="then.TOut"/>
	</x>
	<x path="js.lib.Thenable"><c path="then.TOut"/></x>
</f></then></a></typedef>
	<class path="js.lib.RegExpMatch" params="" file="/home/travis/haxe/std/js/lib/RegExp.hx" module="js.lib.RegExp" extern="1">
		<extends path="Array"><c path="String"/></extends>
		<index public="1"><x path="Int"/></index>
		<input public="1"><c path="String"/></input>
	</class>
	<class path="js.lib.Symbol" params="" file="/home/travis/haxe/std/js/lib/Symbol.hx" extern="1">
		<for_ public="1" set="method" static="1">
			<f a="key">
				<c path="String"/>
				<c path="js.lib.Symbol"/>
			</f>
			<meta><m n=":native"><e>"for"</e></m></meta>
			<haxe_doc>Searches for existing symbols with the given key and returns it if found.
		Otherwise a new symbol gets created in the global symbol registry with this key.</haxe_doc>
		</for_>
		<keyFor public="1" set="method" static="1">
			<f a="sym">
				<c path="js.lib.Symbol"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<haxe_doc>Retrieves a shared symbol key from the global symbol registry for the given symbol.</haxe_doc>
		</keyFor>
		<iterator public="1" set="null" static="1">
			<c path="js.lib.Symbol"/>
			<haxe_doc>A method returning the default iterator for an object.</haxe_doc>
		</iterator>
		<asyncIterator public="1" set="null" static="1">
			<c path="js.lib.Symbol"/>
			<haxe_doc>A method that returns the default AsyncIterator for an object.</haxe_doc>
		</asyncIterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string containing the description of the Symbol.</haxe_doc>
		</toString>
		<ofObject public="1" params="T" get="inline" set="null" line="66">
			<f a="object">
				<a/>
				<x path="Null"><c path="ofObject.T"/></x>
			</f>
			<haxe_doc>Retrieve symbol from a given `object`.

		NOTE: This is a Haxe-specific method that generates an `object[symbol]` expression.</haxe_doc>
		</ofObject>
		<new public="1" set="method">
			<f a="?description">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":selfCall"/></meta>
			<haxe_doc>To create a new primitive symbol, use `new Symbol()` with an optional string as its `description`.

		NOTE: Unlike in plain JavaScript, `new Symbol()` syntax is used in Haxe. This generates a `Symbol(...)`
		expression as required by the JavaScript specification.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Symbol"</e></m></meta>
	</class>
	<class path="js.lib.Uint16Array" params="" file="/home/travis/haxe/std/js/lib/Uint16Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 2 in the case of an `Uint16Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Creates a new `Uint16Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Uint16Array"/>
	</f>
	<haxe_doc>Creates a new `Uint16Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Creates a new `Uint16Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Uint16Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Uint16Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Uint16Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Uint16Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint16Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint16Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint16Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint16Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint16Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint16Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Uint16Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint16Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint16Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Uint16Array` typed array represents an array of 16-bit unsigned integers in the platform
	byte order. If control over byte order is needed, use `DataView` instead. The contents are
	initialized to `0`. Once established, you can reference elements in the array using the object's
	methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Uint16Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Uint16Array"</e></m></meta>
	</class>
	<class path="js.lib.Uint32Array" params="" file="/home/travis/haxe/std/js/lib/Uint32Array.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 4 in the case of an `Uint32Array`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Creates a new `Uint32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Uint32Array"/>
	</f>
	<haxe_doc>Creates a new `Uint32Array` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Creates a new `Uint32Array` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Uint32Array` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Uint32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Uint32Array` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Uint32Array`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint32Array"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint32Array"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint32Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint32Array"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Uint32Array"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint32Array"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint32Array"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Uint32Array` typed array represents an array of 32-bit unsigned integers in the platform
	byte order. If control over byte order is needed, use `DataView` instead. The contents are
	initialized to `0`. Once established, you can reference elements in the array using the object's
	methods, or using standard array index syntax (that is, using bracket notation).

	Documentation [Uint32Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Uint32Array"</e></m></meta>
	</class>
	<class path="js.lib.Uint8ClampedArray" params="" file="/home/travis/haxe/std/js/lib/Uint8ClampedArray.hx" extern="1">
		<implements path="js.lib.ArrayBufferView"/>
		<BYTES_PER_ELEMENT final="1" public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Returns a number value of the element size. 1 in the case of an `Uint8ClampedArray`.</haxe_doc>
		</BYTES_PER_ELEMENT>
		<from public="1" set="method" static="1">
			<f a="source:?mapFn:?thisArg">
				<a/>
				<f a="value:index">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Creates a new `Uint8ClampedArray` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
			<overloads><from public="1" set="method">
	<f a="source:?mapFn:?thisArg">
		<a/>
		<f a="value">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<x path="Any"/>
		<c path="js.lib.Uint8ClampedArray"/>
	</f>
	<haxe_doc>Creates a new `Uint8ClampedArray` from an array-like or iterable object. See also [Array.from()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).</haxe_doc>
</from></overloads>
		</from>
		<of public="1" set="method" static="1">
			<f a="elements">
				<x path="haxe.extern.Rest"><d/></x>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Creates a new `Uint8ClampedArray` with a variable number of arguments. See also [Array.of()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of).</haxe_doc>
		</of>
		<BYTES_PER_ELEMENT_ final="1" public="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"BYTES_PER_ELEMENT"</e></m></meta>
			<haxe_doc>Returns a number value of the element size.</haxe_doc>
		</BYTES_PER_ELEMENT_>
		<buffer final="1" public="1">
			<c path="js.lib.ArrayBuffer"/>
			<haxe_doc>Returns the `ArrayBuffer` referenced by the `Uint8ClampedArray` Fixed at construction time and thus read only.</haxe_doc>
		</buffer>
		<byteLength final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the length (in bytes) of the `Uint8ClampedArray` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteLength>
		<byteOffset final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the offset (in bytes) of the `Uint8ClampedArray` from the start of its `ArrayBuffer`. Fixed at construction time and thus read only.</haxe_doc>
		</byteOffset>
		<length final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Returns the number of elements hold in the `Uint8ClampedArray`. Fixed at construction time and thus read only.</haxe_doc>
		</length>
		<copyWithin public="1" set="method">
			<f a="target:start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Copies a sequence of array elements within the array.
		See also [Array.prototype.copyWithin()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin).</haxe_doc>
		</copyWithin>
		<entries public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="js.lib.KeyValue">
	<x path="Int"/>
	<x path="Int"/>
</x></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
		See also [Array.prototype.entries()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries).</haxe_doc>
		</entries>
		<every public="1" set="method">
			<f a="callback:?thisArg">
				<f a="currentValue:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
			<overloads>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
				<every public="1" set="method">
					<f a="callback:?thisArg">
						<f a="currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Tests whether all elements in the array pass the test provided by a function.
		See also [Array.prototype.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).</haxe_doc>
				</every>
			</overloads>
		</every>
		<fill public="1" set="method">
			<f a="value:?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Fills all the elements of an array from a start index to an end index with a static value.
		See also [Array.prototype.fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill).</haxe_doc>
		</fill>
		<filter public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
			<overloads>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8ClampedArray"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
				<filter public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8ClampedArray"/>
					</f>
					<haxe_doc>Creates a new array with all of the elements of this array for which the provided filtering function returns true.
		See also [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).</haxe_doc>
				</filter>
			</overloads>
		</filter>
		<find public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
			<overloads>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
				<find public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Null"><x path="Int"/></x>
					</f>
					<haxe_doc>Returns the found value in the array, if an element in the array satisfies the provided testing function or undefined if not found.
		See also [Array.prototype.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).</haxe_doc>
				</find>
			</overloads>
		</find>
		<findIndex public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
			<overloads>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
				<findIndex public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Returns the found index in the array, if an element in the array satisfies the provided testing function or -1 if not found.
		See also [Array.prototype.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).</haxe_doc>
				</findIndex>
			</overloads>
		</findIndex>
		<forEach public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
			<overloads>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
				<forEach public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Void"/>
						</f>
						<x path="Any"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Calls a function for each element in the array.
		See also [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).</haxe_doc>
				</forEach>
			</overloads>
		</forEach>
		<includes public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines whether a typed array includes a certain element, returning true or false as appropriate.
		See also [Array.prototype.includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).</haxe_doc>
		</includes>
		<indexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).</haxe_doc>
		</indexOf>
		<join public="1" set="method">
			<f a="?separator">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all elements of an array into a string.
		See also [Array.prototype.join()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).</haxe_doc>
		</join>
		<keys public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator that contains the keys for each index in the array.
		See also [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys).</haxe_doc>
		</keys>
		<lastIndexOf public="1" set="method">
			<f a="searchElement:?fromIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
		See also [Array.prototype.lastIndexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf).</haxe_doc>
		</lastIndexOf>
		<map public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Int"/>
				</f>
				<x path="Any"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
			<overloads>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8ClampedArray"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
				<map public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Any"/>
						<c path="js.lib.Uint8ClampedArray"/>
					</f>
					<haxe_doc>Creates a new array with the results of calling a provided function on every element in this array.
		See also [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).</haxe_doc>
				</map>
			</overloads>
		</map>
		<reduce public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduce.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<c path="reduce.T"/>
				</f>
				<c path="reduce.T"/>
				<c path="reduce.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
			<overloads>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduce.T"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduce.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduce.T"/>
						</f>
						<c path="reduce.T"/>
						<c path="reduce.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
				<reduce public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint8ClampedArray"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
		See also [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).</haxe_doc>
				</reduce>
			</overloads>
		</reduce>
		<reduceRight public="1" params="T" set="method">
			<f a="callback:initialValue">
				<f a="previousValue:currentValue:index:array">
					<c path="reduceRight.T"/>
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<c path="reduceRight.T"/>
				</f>
				<c path="reduceRight.T"/>
				<c path="reduceRight.T"/>
			</f>
			<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
			<overloads>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" params="T" set="method">
					<f a="callback:initialValue">
						<f a="previousValue:currentValue:index">
							<c path="reduceRight.T"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="reduceRight.T"/>
						</f>
						<c path="reduceRight.T"/>
						<c path="reduceRight.T"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
				<reduceRight public="1" set="method">
					<f a="callbackfn">
						<f a="previousValue:currentValue:index:array">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Int"/>
							<c path="js.lib.Uint8ClampedArray"/>
							<x path="Int"/>
						</f>
						<x path="Int"/>
					</f>
					<haxe_doc>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
		See also [Array.prototype.reduceRight()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight).</haxe_doc>
				</reduceRight>
			</overloads>
		</reduceRight>
		<reverse public="1" set="method">
			<f a=""><c path="js.lib.Uint8ClampedArray"/></f>
			<haxe_doc>Reverses the order of the elements of an array  the first becomes the last, and the last becomes the first.
		See also [Array.prototype.reverse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).</haxe_doc>
		</reverse>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
			<overloads>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint8ClampedArray"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint16Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Int32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Uint32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float32Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
				<set public="1" set="method">
					<f a="array:?offset">
						<c path="js.lib.Float64Array"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Stores multiple values in the typed array, reading input values from a specified array.</haxe_doc>
				</set>
			</overloads>
		</set>
		<slice public="1" set="method">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Extracts a section of an array and returns a new array.
		See also [Array.prototype.slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).</haxe_doc>
		</slice>
		<some public="1" set="method">
			<f a="callback:?thisArg">
				<f a="element:index:array">
					<x path="Int"/>
					<x path="Int"/>
					<c path="js.lib.Uint8ClampedArray"/>
					<x path="Bool"/>
				</f>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
			<overloads>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element">
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
				<some public="1" set="method">
					<f a="callback:?thisArg">
						<f a="element:index">
							<x path="Int"/>
							<x path="Int"/>
							<x path="Bool"/>
						</f>
						<x path="Any"/>
						<x path="Bool"/>
					</f>
					<haxe_doc>Returns true if at least one element in this array satisfies the provided testing function.
		See also [Array.prototype.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).</haxe_doc>
				</some>
			</overloads>
		</some>
		<sort public="1" set="method">
			<f a="?compareFn">
				<f a="x:y">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Sorts the elements of an array in place and returns the array.
		See also [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).</haxe_doc>
		</sort>
		<subarray public="1" set="method">
			<f a="?begin:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.lib.Uint8ClampedArray"/>
			</f>
			<haxe_doc>Returns a new TypedArray from the given start and end element index.</haxe_doc>
		</subarray>
		<values public="1" set="method">
			<f a=""><t path="js.lib.Iterator"><x path="Int"/></t></f>
			<haxe_doc>Returns a new Array Iterator object that contains the values for each index in the array.
		See also [Array.prototype.values()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values).</haxe_doc>
		</values>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toLocaleString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the array and its elements.
		See also [Array.prototype.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString).</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="object">
						<a/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The `Uint8ClampedArray` typed array represents an array of 8-bit unsigned integers clamped
	to 0-255; if you specified a value that is out of the range of [0,255], 0 or 255 will be set instead;
	if you specify a non-integer, the nearest integer will be set. The contents are initialized to `0`.
	Once established, you can reference elements in the array using the object's methods, or using
	standard array index syntax (that is, using bracket notation).

	Documentation [Uint8ClampedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Uint8ClampedArray"</e></m></meta>
	</class>
	<abstract path="js.lib.intl.LocaleMatcher" params="" file="/home/travis/haxe/std/js/lib/intl/LocaleMatcher.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib.intl._LocaleMatcher.LocaleMatcher_Impl_" params="" file="/home/travis/haxe/std/js/lib/intl/LocaleMatcher.hx" private="1" module="js.lib.intl.LocaleMatcher"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.lib.intl.NumberFormat" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" extern="1">
		<supportedLocalesOf public="1" set="method" static="1">
			<f a="locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatSupportedLocalesOfOptions"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing those of the provided locales that are supported
		without having to fall back to the runtime's default locale.</haxe_doc>
			<overloads><supportedLocalesOf public="1" set="method">
	<f a="locales:?options">
		<c path="Array"><c path="String"/></c>
		<t path="js.lib.intl.NumberFormatSupportedLocalesOfOptions"/>
		<c path="Array"><c path="String"/></c>
	</f>
	<haxe_doc>Returns an array containing those of the provided locales that are supported
		without having to fall back to the runtime's default locale.</haxe_doc>
</supportedLocalesOf></overloads>
		</supportedLocalesOf>
		<format public="1" set="method">
			<f a="number">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Getter function that formats a number according to the locale
		and formatting options of this `NumberFormat` object.</haxe_doc>
		</format>
		<formatToParts public="1" set="method">
			<f a="?number">
				<x path="Float"/>
				<c path="Array"><t path="js.lib.intl.NumberFormatPart"/></c>
			</f>
			<haxe_doc>Returns an `Array` of objects representing the number string in parts
		that can be used for custom locale-aware formatting.</haxe_doc>
		</formatToParts>
		<resolvedOptions public="1" set="method">
			<f a=""><t path="js.lib.intl.NumberFormatResolvedOption"/></f>
			<haxe_doc>Returns a new object with properties reflecting the locale and collation options
		computed during initialization of the object.</haxe_doc>
		</resolvedOptions>
		<new public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<t path="js.lib.intl.NumberFormatOptions"/>
				<x path="Void"/>
			</f>
			<overloads><new public="1" set="method"><f a="?locales:?options">
	<c path="Array"><c path="String"/></c>
	<t path="js.lib.intl.NumberFormatOptions"/>
	<x path="Void"/>
</f></new></overloads>
		</new>
		<haxe_doc>The `NumberFormat` object is a constructor for objects that enable language sensitive number formatting.

	Documentation [NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Intl.NumberFormat"</e></m></meta>
	</class>
	<typedef path="js.lib.intl.NumberFormatOptions" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat"><a>
	<useGrouping>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.
		The default is `true`.</haxe_doc>
	</useGrouping>
	<style>
		<x path="Null"><x path="js.lib.intl.NumberFormatStyle"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The formatting style to use.
		The default is `Decimal`.</haxe_doc>
	</style>
	<minimumSignificantDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The minimum number of significant digits to use.
		Possible values are from 1 to 21; the default is 1.</haxe_doc>
	</minimumSignificantDigits>
	<minimumIntegerDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The minimum number of integer digits to use.
		Possible values are from 1 to 21; the default is 1.</haxe_doc>
	</minimumIntegerDigits>
	<minimumFractionDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The minimum number of fraction digits to use.
		Possible values are from 0 to 20; the default for plain number and percent formatting is 0;
		the default for currency formatting is the number of minor unit digits provided by the
		[ISO 4217 currency code list](http://www.currency-iso.org/en/home/tables/table-a1.html)
		(2 if the list doesn't provide that information).</haxe_doc>
	</minimumFractionDigits>
	<maximumSignificantDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The maximum number of significant digits to use.
		Possible values are from 1 to 21; the default is 21.</haxe_doc>
	</maximumSignificantDigits>
	<maximumFractionDigits>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The maximum number of fraction digits to use.
		Possible values are from 0 to 20; the default for plain number formatting is the larger of
		minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits
		and the number of minor unit digits provided by the [ISO 4217 currency code list](http://www.currency-iso.org/en/home/tables/table-a1.html)
		(2 if the list doesn't provide that information); the default for percent formatting is the larger of
		minimumFractionDigits and 0.</haxe_doc>
	</maximumFractionDigits>
	<localeMatcher>
		<x path="Null"><x path="js.lib.intl.LocaleMatcher"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The locale matching algorithm to use.
		The default is `BestFit`.
		For information about this option, see the [Intl page](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation).</haxe_doc>
	</localeMatcher>
	<currencyDisplay>
		<x path="Null"><x path="js.lib.intl.CurrencyDisplay"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>How to display the currency in currency formatting.
		The default is `Symbol`.</haxe_doc>
	</currencyDisplay>
	<currency>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc><![CDATA[The currency to use in currency formatting. Possible values are the ISO 4217 currency codes,
		such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB  see the
		[Current currency & funds code list](https://www.currency-iso.org/en/home/tables/table-a1.html).
		There is no default value; if the style is "currency", the currency property must be provided.]]></haxe_doc>
	</currency>
</a></typedef>
	<typedef path="js.lib.intl.NumberFormatResolvedOption" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat"><a>
	<useGrouping final="1" set="null">
		<c path="String"/>
		<haxe_doc>The values provided for these properties in the `options` argument or filled in as defaults.</haxe_doc>
	</useGrouping>
	<style final="1" set="null"><x path="js.lib.intl.NumberFormatStyle"/></style>
	<numberingSystem final="1" set="null">
		<c path="String"/>
		<haxe_doc>The value requested using the Unicode extension key `"nu"` or filled in as a default.</haxe_doc>
	</numberingSystem>
	<minimumSignificantDigits final="1" set="null"><x path="Int"/></minimumSignificantDigits>
	<minimumIntegerDigits final="1" set="null"><x path="Int"/></minimumIntegerDigits>
	<minimumFractionDigits final="1" set="null"><x path="Int"/></minimumFractionDigits>
	<maximumSignificantDigits final="1" set="null">
		<x path="Int"/>
		<haxe_doc>The values provided for these properties in the `options` argument or filled in as defaults.
		These properties are present only if at least one of them was provided in the `options` argument.</haxe_doc>
	</maximumSignificantDigits>
	<maximumFractionDigits final="1" set="null">
		<x path="Int"/>
		<haxe_doc>The values provided for these properties in the `options` argument or filled in as defaults.
		These properties are present only if neither m`inimumSignificantDigits` nor `maximumSignificantDigits`
		was provided in the `options` argument.</haxe_doc>
	</maximumFractionDigits>
	<locale final="1" set="null">
		<c path="String"/>
		<haxe_doc>The BCP 47 language tag for the locale actually used. If any Unicode extension values were
		requested in the input BCP 47 language tag that led to this locale, the key-value pairs that
		were requested and are supported for this locale are included in `locale`.</haxe_doc>
	</locale>
	<currencyDisplay final="1" set="null">
		<c path="String"/>
		<haxe_doc>The values provided for these properties in the `options` argument or filled in as defaults.
		These properties are only present if `style` is `"currency"`.</haxe_doc>
	</currencyDisplay>
	<currency final="1" set="null"><c path="String"/></currency>
</a></typedef>
	<abstract path="js.lib.intl.NumberFormatStyle" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib.intl._NumberFormat.NumberFormatStyle_Impl_" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" private="1" module="js.lib.intl.NumberFormat"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.lib.intl.CurrencyDisplay" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib.intl._NumberFormat.CurrencyDisplay_Impl_" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" private="1" module="js.lib.intl.NumberFormat"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<typedef path="js.lib.intl.NumberFormatPart" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat"><a>
	<value final="1" set="null"><c path="String"/></value>
	<type final="1" set="null"><x path="js.lib.intl.NumberFormatPartType"/></type>
</a></typedef>
	<abstract path="js.lib.intl.NumberFormatPartType" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib.intl._NumberFormat.NumberFormatPartType_Impl_" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" private="1" module="js.lib.intl.NumberFormat"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<typedef path="js.lib.intl.NumberFormatSupportedLocalesOfOptions" params="" file="/home/travis/haxe/std/js/lib/intl/NumberFormat.hx" module="js.lib.intl.NumberFormat"><a><localeMatcher>
	<x path="Null"><x path="js.lib.intl.LocaleMatcher"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The locale matching algorithm to use.
		The default is `BestFit`.</haxe_doc>
</localeMatcher></a></typedef>
	<typedef path="js.node.Buffer" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/Buffer.hx"><c path="js.node.buffer.Buffer"/></typedef>
	<typedef path="js.node._ChildProcess.ChildProcessCommonOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Common options for all `ChildProcess` methods.</haxe_doc>
	</typedef>
	<typedef path="js.node._ChildProcess.ChildProcessSpawnOptionsBase" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<stdio>
				<x path="Null"><t path="js.node.ChildProcessSpawnOptionsStdio"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Child's stdio configuration.</haxe_doc>
			</stdio>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Common options for `spawn` and `spawnSync` methods.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessSpawnOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<stdio>
				<x path="Null"><t path="js.node.ChildProcessSpawnOptionsStdio"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Child's stdio configuration.</haxe_doc>
			</stdio>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<detached>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child will be a process group leader.</haxe_doc>
			</detached>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `spawn` method.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessSpawnSyncOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<timeout>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.</haxe_doc>
			</timeout>
			<stdio>
				<x path="Null"><t path="js.node.ChildProcessSpawnOptionsStdio"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Child's stdio configuration.</haxe_doc>
			</stdio>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<maxBuffer>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The largest amount of data allowed on stdout or stderr.
		If this value is exceeded then the child process is killed.
		Default: 200*1024</haxe_doc>
			</maxBuffer>
			<killSignal>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child process is killed with `killSignal` (default: 'SIGTERM').</haxe_doc>
			</killSignal>
			<input>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="js.node.Buffer"/>
</x></x>
				<meta><m n=":optional"/></meta>
			</input>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Default: 'utf8'</haxe_doc>
			</encoding>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `spawnSync` method.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessSpawnOptionsStdio" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<x path="haxe.extern.EitherType">
			<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
			<t path="js.node.ChildProcessSpawnOptionsStdioFull"/>
		</x>
		<haxe_doc>The `stdio` option is an array where each index corresponds to a fd in the child.
	The value is one of the following:

		* 'pipe' - Create a pipe between the child process and the parent process.
			       The parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd].
			       Pipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively.

		* 'ipc' - Create an IPC channel for passing messages/file descriptors between parent and child.
			      A ChildProcess may have at most one IPC stdio file descriptor. Setting this option enables the ChildProcess.send() method.
			      If the child writes JSON messages to this file descriptor, then this will trigger ChildProcess.on('message').
			      If the child is a Node.js program, then the presence of an IPC channel will enable process.send() and process.on('message').

		* 'ignore' - Do not set this file descriptor in the child. Note that Node will always open fd 0 - 2 for the processes it spawns.
		             When any of these is ignored node will open /dev/null and attach it to the child's fd.

		* Stream object - Share a readable or writable stream that refers to a tty, file, socket, or a pipe with the child process.
		                  The stream's underlying file descriptor is duplicated in the child process to the fd that corresponds to the index
		                  in the stdio array. Note that the stream must have an underlying descriptor (file streams do not until the 'open'
		                  event has occurred).

		* Positive integer - The integer value is interpreted as a file descriptor that is is currently open in the parent process.
		                     It is shared with the child process, similar to how Stream objects can be shared.

		* null - Use default value. For stdio fds 0, 1 and 2 (in other words, stdin, stdout, and stderr) a pipe is created.
		         For fd 3 and up, the default is 'ignore'.

     As a shorthand, the stdio argument may also be one of the following strings, rather than an array:
		ignore - ['ignore', 'ignore', 'ignore']
		pipe - ['pipe', 'pipe', 'pipe']
		inherit - [process.stdin, process.stdout, process.stderr] or [0,1,2]</haxe_doc>
	</typedef>
	<abstract path="js.node.ChildProcessSpawnOptionsStdioSimple" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>A shorthand for the `stdio` argument in `ChildProcessSpawnOptions`</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node._ChildProcess.ChildProcessSpawnOptionsStdioSimple_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess" extern="1">
	<Ignore public="1" get="inline" set="null" expr="cast &quot;ignore&quot;" line="146" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
		<meta>
			<m n=":value"><e>cast "ignore"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Equivalent to ['ignore', 'ignore', 'ignore']</haxe_doc>
	</Ignore>
	<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="151" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
		<meta>
			<m n=":value"><e>cast "pipe"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Equivalent to ['pipe', 'pipe', 'pipe']</haxe_doc>
	</Pipe>
	<Inherit public="1" get="inline" set="null" expr="cast &quot;inherit&quot;" line="156" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
		<meta>
			<m n=":value"><e>cast "inherit"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Equivalent to [process.stdin, process.stdout, process.stderr] or [0,1,2]</haxe_doc>
	</Inherit>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node._ChildProcess.ChildProcessSpawnOptionsStdioSimple_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess" extern="1">
		<Ignore public="1" get="inline" set="null" expr="cast &quot;ignore&quot;" line="146" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
			<meta>
				<m n=":value"><e>cast "ignore"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Equivalent to ['ignore', 'ignore', 'ignore']</haxe_doc>
		</Ignore>
		<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="151" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
			<meta>
				<m n=":value"><e>cast "pipe"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Equivalent to ['pipe', 'pipe', 'pipe']</haxe_doc>
		</Pipe>
		<Inherit public="1" get="inline" set="null" expr="cast &quot;inherit&quot;" line="156" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioSimple"/>
			<meta>
				<m n=":value"><e>cast "inherit"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Equivalent to [process.stdin, process.stdout, process.stderr] or [0,1,2]</haxe_doc>
		</Inherit>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="js.node.ChildProcessSpawnOptionsStdioBehaviour" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>Enumeration of possible `stdio` behaviours.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node._ChildProcess.ChildProcessSpawnOptionsStdioBehaviour_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess" extern="1">
	<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="168" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
		<meta>
			<m n=":value"><e>cast "pipe"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Create a pipe between the child process and the parent process.
		The parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd].
		Pipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively.</haxe_doc>
	</Pipe>
	<Ipc public="1" get="inline" set="null" expr="cast &quot;ipc&quot;" line="182" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
		<meta>
			<m n=":value"><e>cast "ipc"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Create an IPC channel for passing messages/file descriptors between parent and child.
		A ChildProcess may have at most one IPC stdio file descriptor.

		Setting this option enables the ChildProcess.send() method.

		If the child writes JSON messages to this file descriptor, then this will trigger
		ChildProcess.on('message').

		If the child is a Node.js program, then the presence of an IPC channel will
		enable process.send() and process.on('message').</haxe_doc>
	</Ipc>
	<Ignore public="1" get="inline" set="null" expr="cast &quot;ignore&quot;" line="189" static="1">
		<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
		<meta>
			<m n=":value"><e>cast "ignore"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Do not set this file descriptor in the child.
		Note that Node will always open fd 0 - 2 for the processes it spawns.
		When any of these is ignored node will open /dev/null and attach it to the child's fd.</haxe_doc>
	</Ignore>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node._ChildProcess.ChildProcessSpawnOptionsStdioBehaviour_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess" extern="1">
		<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="168" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
			<meta>
				<m n=":value"><e>cast "pipe"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Create a pipe between the child process and the parent process.
		The parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd].
		Pipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively.</haxe_doc>
		</Pipe>
		<Ipc public="1" get="inline" set="null" expr="cast &quot;ipc&quot;" line="182" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
			<meta>
				<m n=":value"><e>cast "ipc"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Create an IPC channel for passing messages/file descriptors between parent and child.
		A ChildProcess may have at most one IPC stdio file descriptor.

		Setting this option enables the ChildProcess.send() method.

		If the child writes JSON messages to this file descriptor, then this will trigger
		ChildProcess.on('message').

		If the child is a Node.js program, then the presence of an IPC channel will
		enable process.send() and process.on('message').</haxe_doc>
		</Ipc>
		<Ignore public="1" get="inline" set="null" expr="cast &quot;ignore&quot;" line="189" static="1">
			<x path="js.node.ChildProcessSpawnOptionsStdioBehaviour"/>
			<meta>
				<m n=":value"><e>cast "ignore"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Do not set this file descriptor in the child.
		Note that Node will always open fd 0 - 2 for the processes it spawns.
		When any of these is ignored node will open /dev/null and attach it to the child's fd.</haxe_doc>
		</Ignore>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="js.node.ChildProcessSpawnOptionsStdioFull" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess"><c path="Array"><d/></c></typedef>
	<typedef path="js.node._ChildProcess.ChildProcessExecOptionsBase" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" private="1" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<timeout>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.</haxe_doc>
			</timeout>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<maxBuffer>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The largest amount of data allowed on stdout or stderr.
		If this value is exceeded then the child process is killed.
		Default: 200*1024</haxe_doc>
			</maxBuffer>
			<killSignal>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child process is killed with `killSignal` (default: 'SIGTERM').</haxe_doc>
			</killSignal>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Default: 'utf8'</haxe_doc>
			</encoding>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Common options for `exec` and `execFile` methods.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessExecOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<timeout>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.</haxe_doc>
			</timeout>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<maxBuffer>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The largest amount of data allowed on stdout or stderr.
		If this value is exceeded then the child process is killed.
		Default: 200*1024</haxe_doc>
			</maxBuffer>
			<killSignal>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child process is killed with `killSignal` (default: 'SIGTERM').</haxe_doc>
			</killSignal>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Default: 'utf8'</haxe_doc>
			</encoding>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `exec` method.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessExecFileOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<timeout>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.</haxe_doc>
			</timeout>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<maxBuffer>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The largest amount of data allowed on stdout or stderr.
		If this value is exceeded then the child process is killed.
		Default: 200*1024</haxe_doc>
			</maxBuffer>
			<killSignal>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The child process is killed with `killSignal` (default: 'SIGTERM').</haxe_doc>
			</killSignal>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Default: 'utf8'</haxe_doc>
			</encoding>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `execFile` method.</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessForkOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<uid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the user identity of the process. See setuid(2).</haxe_doc>
			</uid>
			<silent>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If `true`, stdin, stdout, and stderr of the child will be piped to the parent,
		otherwise they will be inherited from the parent, see the "pipe" and "inherit"
		options for `ChildProcessSpawnOptions.stdio` for more details (default is `false`)</haxe_doc>
			</silent>
			<shell>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Shell to execute the command with.
		Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows.

		The shell should understand the -c switch on UNIX or /s /c on Windows.
		On Windows, command line parsing should be compatible with cmd.exe.</haxe_doc>
			</shell>
			<gid>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sets the group identity of the process. See setgid(2).</haxe_doc>
			</gid>
			<execPath>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Executable used to create the child process</haxe_doc>
			</execPath>
			<execArgv>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>List of string arguments passed to the executable (Default: process.execArgv)</haxe_doc>
			</execArgv>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs</haxe_doc>
			</env>
			<cwd>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Current working directory of the child process.</haxe_doc>
			</cwd>
		</a>
		<haxe_doc>Options for the `fork` method.</haxe_doc>
	</typedef>
	<class path="js.node.ChildProcessExecError" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess" extern="1">
		<extends path="js.lib.Error"/>
		<code public="1" set="null">
			<x path="Int"/>
			<haxe_doc>the exit code of the child proces.</haxe_doc>
		</code>
		<signal public="1" set="null">
			<c path="String"/>
			<haxe_doc>the signal that terminated the process.</haxe_doc>
		</signal>
		<haxe_doc>An error passed to the `ChildProcess.exec` callback.</haxe_doc>
		<meta><m n=":native"><e>"Error"</e></m></meta>
	</class>
	<typedef path="js.node.ChildProcessExecCallback" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<f a="error:stdout:stderr">
			<x path="Null"><c path="js.node.ChildProcessExecError"/></x>
			<x path="haxe.extern.EitherType">
				<t path="js.node.Buffer"/>
				<c path="String"/>
			</x>
			<x path="haxe.extern.EitherType">
				<t path="js.node.Buffer"/>
				<c path="String"/>
			</x>
			<x path="Void"/>
		</f>
		<haxe_doc>A callback type for `ChildProcess.exec`.
	It receives three arguments: `error`, `stdout`, `stderr`.

	On success, error will be `null`. On error, `error` will be an instance of `Error`
	and `error.code` will be the exit code of the child process, and `error.signal` will be set
	to the signal that terminated the process (see `ChildProcessExecError`).</haxe_doc>
	</typedef>
	<typedef path="js.node.ChildProcessSpawnSyncResult" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" module="js.node.ChildProcess">
		<a>
			<stdout>
				<x path="haxe.extern.EitherType">
					<t path="js.node.Buffer"/>
					<c path="String"/>
				</x>
				<haxe_doc>The contents of output[1]</haxe_doc>
			</stdout>
			<stderr>
				<x path="haxe.extern.EitherType">
					<t path="js.node.Buffer"/>
					<c path="String"/>
				</x>
				<haxe_doc>The contents of output[2]</haxe_doc>
			</stderr>
			<status>
				<x path="Int"/>
				<haxe_doc>The exit code of the child process</haxe_doc>
			</status>
			<signal>
				<c path="String"/>
				<haxe_doc>The signal used to kill the child process</haxe_doc>
			</signal>
			<pid>
				<x path="Int"/>
				<haxe_doc>Pid of the child process</haxe_doc>
			</pid>
			<output>
				<c path="Array"><x path="haxe.extern.EitherType">
	<t path="js.node.Buffer"/>
	<c path="String"/>
</x></c>
				<haxe_doc>Array of results from stdio output</haxe_doc>
			</output>
			<error>
				<c path="js.lib.Error"/>
				<haxe_doc>The error object if the child process failed or timed out</haxe_doc>
			</error>
		</a>
		<haxe_doc>Object returned from the `spawnSync` method.</haxe_doc>
	</typedef>
	<class path="js.node.ChildProcess" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/ChildProcess.hx" extern="1">
		<spawn public="1" set="method" static="1">
			<f a="command:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
			</f>
			<haxe_doc>Launches a new process with the given `command`, with command line arguments in `args`.
		If omitted, `args` defaults to an empty `Array`.

		The third argument is used to specify additional options, which defaults to:
			{ cwd: null,
			  env: process.env
			}

		Note that if spawn receives an empty options object, it will result in spawning the process with an empty
		environment rather than using `process.env`. This due to backwards compatibility issues with a deprecated API.</haxe_doc>
			<overloads>
				<spawn public="1" set="method">
					<f a="command:?options">
						<c path="String"/>
						<t path="js.node.ChildProcessSpawnOptions"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>Launches a new process with the given `command`, with command line arguments in `args`.
		If omitted, `args` defaults to an empty `Array`.

		The third argument is used to specify additional options, which defaults to:
			{ cwd: null,
			  env: process.env
			}

		Note that if spawn receives an empty options object, it will result in spawning the process with an empty
		environment rather than using `process.env`. This due to backwards compatibility issues with a deprecated API.</haxe_doc>
				</spawn>
				<spawn public="1" set="method">
					<f a="command:args:?options">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<t path="js.node.ChildProcessSpawnOptions"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>Launches a new process with the given `command`, with command line arguments in `args`.
		If omitted, `args` defaults to an empty `Array`.

		The third argument is used to specify additional options, which defaults to:
			{ cwd: null,
			  env: process.env
			}

		Note that if spawn receives an empty options object, it will result in spawning the process with an empty
		environment rather than using `process.env`. This due to backwards compatibility issues with a deprecated API.</haxe_doc>
				</spawn>
			</overloads>
		</spawn>
		<exec public="1" set="method" static="1">
			<f a="command:callback">
				<c path="String"/>
				<t path="js.node.ChildProcessExecCallback"/>
				<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
			</f>
			<haxe_doc>Runs a command in a shell and buffers the output.

		`command` is the command to run, with space-separated arguments.

		The default `options` are:
			{ encoding: 'utf8',
			  timeout: 0,
			  maxBuffer: 200*1024,
			  killSignal: 'SIGTERM',
			  cwd: null,
			  env: null }</haxe_doc>
			<overloads><exec public="1" set="method">
	<f a="command:options:callback">
		<c path="String"/>
		<t path="js.node.ChildProcessExecOptions"/>
		<t path="js.node.ChildProcessExecCallback"/>
		<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
	</f>
	<haxe_doc>Runs a command in a shell and buffers the output.

		`command` is the command to run, with space-separated arguments.

		The default `options` are:
			{ encoding: 'utf8',
			  timeout: 0,
			  maxBuffer: 200*1024,
			  killSignal: 'SIGTERM',
			  cwd: null,
			  env: null }</haxe_doc>
</exec></overloads>
		</exec>
		<execFile public="1" set="method" static="1">
			<f a="file:?callback">
				<c path="String"/>
				<t path="js.node.ChildProcessExecCallback"/>
				<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
			</f>
			<haxe_doc>This is similar to `exec` except it does not execute a subshell but rather the specified file directly.
		This makes it slightly leaner than `exec`</haxe_doc>
			<overloads>
				<execFile public="1" set="method">
					<f a="file:args:options:?callback">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<t path="js.node.ChildProcessExecFileOptions"/>
						<t path="js.node.ChildProcessExecCallback"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is similar to `exec` except it does not execute a subshell but rather the specified file directly.
		This makes it slightly leaner than `exec`</haxe_doc>
				</execFile>
				<execFile public="1" set="method">
					<f a="file:options:?callback">
						<c path="String"/>
						<t path="js.node.ChildProcessExecFileOptions"/>
						<t path="js.node.ChildProcessExecCallback"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is similar to `exec` except it does not execute a subshell but rather the specified file directly.
		This makes it slightly leaner than `exec`</haxe_doc>
				</execFile>
				<execFile public="1" set="method">
					<f a="file:args:?callback">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<t path="js.node.ChildProcessExecCallback"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is similar to `exec` except it does not execute a subshell but rather the specified file directly.
		This makes it slightly leaner than `exec`</haxe_doc>
				</execFile>
			</overloads>
		</execFile>
		<fork public="1" set="method" static="1">
			<f a="modulePath:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
			</f>
			<haxe_doc>This is a special case of the `spawn` functionality for spawning Node processes.
		In addition to having all the methods in a normal `ChildProcess` instance,
		the returned object has a communication channel built-in.
		See `send` for details.</haxe_doc>
			<overloads>
				<fork public="1" set="method">
					<f a="modulePath:args:options">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<t path="js.node.ChildProcessForkOptions"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is a special case of the `spawn` functionality for spawning Node processes.
		In addition to having all the methods in a normal `ChildProcess` instance,
		the returned object has a communication channel built-in.
		See `send` for details.</haxe_doc>
				</fork>
				<fork public="1" set="method">
					<f a="modulePath:options">
						<c path="String"/>
						<t path="js.node.ChildProcessForkOptions"/>
						<t path="js.node.child_process._ChildProcess.ChildProcessObject"/>
					</f>
					<haxe_doc>This is a special case of the `spawn` functionality for spawning Node processes.
		In addition to having all the methods in a normal `ChildProcess` instance,
		the returned object has a communication channel built-in.
		See `send` for details.</haxe_doc>
				</fork>
			</overloads>
		</fork>
		<spawnSync public="1" set="method" static="1">
			<f a="command:?options">
				<c path="String"/>
				<t path="js.node.ChildProcessSpawnSyncOptions"/>
				<t path="js.node.ChildProcessSpawnSyncResult"/>
			</f>
			<haxe_doc>Synchronous version of `spawn`.

		`spawnSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.</haxe_doc>
			<overloads><spawnSync public="1" set="method">
	<f a="command:args:?options">
		<c path="String"/>
		<c path="Array"><c path="String"/></c>
		<t path="js.node.ChildProcessSpawnSyncOptions"/>
		<t path="js.node.ChildProcessSpawnSyncResult"/>
	</f>
	<haxe_doc>Synchronous version of `spawn`.

		`spawnSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.</haxe_doc>
</spawnSync></overloads>
		</spawnSync>
		<execFileSync public="1" set="method" static="1">
			<f a="command:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.Buffer"/>
				</x>
			</f>
			<haxe_doc>Synchronous version of `execFile`.

		`execFileSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.

		If the process times out, or has a non-zero exit code, this method will throw.
		The Error object will contain the entire result from `spawnSync`</haxe_doc>
			<overloads>
				<execFileSync public="1" set="method">
					<f a="command:?options">
						<c path="String"/>
						<t path="js.node.ChildProcessSpawnSyncOptions"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<t path="js.node.Buffer"/>
						</x>
					</f>
					<haxe_doc>Synchronous version of `execFile`.

		`execFileSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.

		If the process times out, or has a non-zero exit code, this method will throw.
		The Error object will contain the entire result from `spawnSync`</haxe_doc>
				</execFileSync>
				<execFileSync public="1" set="method">
					<f a="command:args:?options">
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<t path="js.node.ChildProcessSpawnSyncOptions"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<t path="js.node.Buffer"/>
						</x>
					</f>
					<haxe_doc>Synchronous version of `execFile`.

		`execFileSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.

		If the process times out, or has a non-zero exit code, this method will throw.
		The Error object will contain the entire result from `spawnSync`</haxe_doc>
				</execFileSync>
			</overloads>
		</execFileSync>
		<execSync public="1" set="method" static="1">
			<f a="command:?options">
				<c path="String"/>
				<t path="js.node.ChildProcessSpawnSyncOptions"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="js.node.Buffer"/>
				</x>
			</f>
			<haxe_doc>Synchronous version of `exec`.

		`execSync` will not return until the child process has fully closed.
		When a timeout has been encountered and `killSignal` is sent, the method won't return until the process
		has completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,
		your process will wait until the child process has exited.

		If the process times out, or has a non-zero exit code, this method will throw.
		The Error object will contain the entire result from `spawnSync`</haxe_doc>
		</execSync>
		<meta><m n=":jsRequire"><e>"child_process"</e></m></meta>
	</class>
	<class path="js.node.events.IEventEmitter" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/events/EventEmitter.hx" module="js.node.events.EventEmitter" extern="1" interface="1">
		<addListener public="1" params="T" set="method"><f a="event:listener">
	<x path="js.node.events.Event"><c path="addListener.T"/></x>
	<c path="addListener.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></addListener>
		<on public="1" params="T" set="method"><f a="event:listener">
	<x path="js.node.events.Event"><c path="on.T"/></x>
	<c path="on.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></on>
		<once public="1" params="T" set="method"><f a="event:listener">
	<x path="js.node.events.Event"><c path="once.T"/></x>
	<c path="once.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></once>
		<prependListener public="1" params="T" set="method"><f a="event:listener">
	<x path="js.node.events.Event"><c path="prependListener.T"/></x>
	<c path="prependListener.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></prependListener>
		<prependOnceListener public="1" params="T" set="method"><f a="event:listener">
	<x path="js.node.events.Event"><c path="prependOnceListener.T"/></x>
	<c path="prependOnceListener.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></prependOnceListener>
		<removeListener public="1" params="T" set="method"><f a="event:listener">
	<x path="js.node.events.Event"><c path="removeListener.T"/></x>
	<c path="removeListener.T"/>
	<c path="js.node.events.IEventEmitter"/>
</f></removeListener>
		<removeAllListeners public="1" params="T" set="method"><f a="?event">
	<x path="js.node.events.Event"><c path="removeAllListeners.T"/></x>
	<c path="js.node.events.IEventEmitter"/>
</f></removeAllListeners>
		<setMaxListeners public="1" set="method"><f a="n">
	<x path="Int"/>
	<x path="Void"/>
</f></setMaxListeners>
		<getMaxListeners public="1" set="method"><f a=""><x path="Int"/></f></getMaxListeners>
		<listeners public="1" params="T" set="method"><f a="event">
	<x path="js.node.events.Event"><c path="listeners.T"/></x>
	<c path="Array"><c path="listeners.T"/></c>
</f></listeners>
		<emit public="1" params="T" set="method"><f a="event:args">
	<x path="js.node.events.Event"><c path="emit.T"/></x>
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Bool"/>
</f></emit>
		<eventNames public="1" set="method"><f a=""><c path="Array"><c path="String"/></c></f></eventNames>
		<haxe_doc>`IEventEmitter` interface is used as "any EventEmitter".

	See `EventEmitter` for actual class documentation.</haxe_doc>
		<meta><m n=":remove"/></meta>
	</class>
	<class path="js.node.events.EventEmitter" params="TSelf" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/events/EventEmitter.hx" extern="1">
		<defaultMaxListeners public="1" static="1">
			<x path="Int"/>
			<haxe_doc>`setMaxListeners` sets the maximum on a per-instance basis.
		This class property lets you set it for all EventEmitter instances,
		current and future, effective immediately. Use with care.

		Note that `setMaxListeners` still has precedence over `defaultMaxListeners`.</haxe_doc>
		</defaultMaxListeners>
		<listenerCount public="1" params="T" set="method" static="1">
			<f a="emitter:event">
				<c path="js.node.events.IEventEmitter"/>
				<x path="js.node.events.Event"><c path="listenerCount.T"/></x>
				<x path="Int"/>
			</f>
			<haxe_doc>Return the number of listeners for a given event.</haxe_doc>
		</listenerCount>
		<addListener public="1" params="T" set="method">
			<f a="event:listener">
				<x path="js.node.events.Event"><c path="addListener.T"/></x>
				<c path="addListener.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds a `listener` to the end of the listeners array for the specified `event`.</haxe_doc>
		</addListener>
		<on public="1" params="T" set="method">
			<f a="event:listener">
				<x path="js.node.events.Event"><c path="on.T"/></x>
				<c path="on.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds a `listener` to the end of the listeners array for the specified `event`.</haxe_doc>
		</on>
		<prependListener public="1" params="T" set="method">
			<f a="event:listener">
				<x path="js.node.events.Event"><c path="prependListener.T"/></x>
				<c path="prependListener.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds the `listener` function to the beginning of the listeners array for the `event`.</haxe_doc>
		</prependListener>
		<prependOnceListener public="1" params="T" set="method">
			<f a="event:listener">
				<x path="js.node.events.Event"><c path="prependOnceListener.T"/></x>
				<c path="prependOnceListener.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds a one time `listener` function for the `event` to the beginning of the listeners array.

		This listener is invoked only the next time event is triggered, after which it is removed.</haxe_doc>
		</prependOnceListener>
		<once public="1" params="T" set="method">
			<f a="event:listener">
				<x path="js.node.events.Event"><c path="once.T"/></x>
				<c path="once.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Adds a one time `listener` for the `event`.

		This listener is invoked only the next time the event is fired, after which it is removed.</haxe_doc>
		</once>
		<removeListener public="1" params="T" set="method">
			<f a="event:listener">
				<x path="js.node.events.Event"><c path="removeListener.T"/></x>
				<c path="removeListener.T"/>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Remove a `listener` from the listener array for the specified `event`.

		Caution: changes array indices in the listener array behind the listener.</haxe_doc>
		</removeListener>
		<removeAllListeners public="1" params="T" set="method">
			<f a="?event">
				<x path="js.node.events.Event"><c path="removeAllListeners.T"/></x>
				<c path="js.node.events.EventEmitter.TSelf"/>
			</f>
			<haxe_doc>Removes all listeners, or those of the specified `event`.</haxe_doc>
		</removeAllListeners>
		<setMaxListeners public="1" set="method">
			<f a="n">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>By default `EventEmitter`s will print a warning if more than 10 listeners are added for a particular event.
		This is a useful default which helps finding memory leaks.

		Obviously not all Emitters should be limited to 10. This function allows that to be increased.
		Set to zero for unlimited.</haxe_doc>
		</setMaxListeners>
		<getMaxListeners public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the current max listener value for the `EventEmitter` which is either set by `setMaxListeners`
		or defaults to `defaultMaxListeners`.</haxe_doc>
		</getMaxListeners>
		<listeners public="1" params="T" set="method">
			<f a="event">
				<x path="js.node.events.Event"><c path="listeners.T"/></x>
				<c path="Array"><c path="listeners.T"/></c>
			</f>
			<haxe_doc>Returns an array of listeners for the specified event.</haxe_doc>
		</listeners>
		<emit public="1" params="T" set="method">
			<f a="event:args">
				<x path="js.node.events.Event"><c path="emit.T"/></x>
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Execute each of the listeners in order with the supplied arguments.
		Returns true if event had listeners, false otherwise.</haxe_doc>
		</emit>
		<eventNames public="1" set="method">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns an array listing the events for which the emitter has registered listeners.</haxe_doc>
		</eventNames>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc>All objects which emit events are instances of `EventEmitter`.

	Typically, event names are represented by a camel-cased string, however,
	there aren't any strict restrictions on that, as any string will be accepted.

	Functions can then be attached to objects, to be executed when an event is emitted.
	These functions are called listeners.

	When an `EventEmitter` instance experiences an error, the typical action is to emit an 'error' event.
	Error events are treated as a special case in node. If there is no listener for it, then the default action
	is to print a stack trace and exit the program.

	All `EventEmitter`s emit the event `newListener` when new listeners are added
	and `removeListener` when a listener is removed.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"events"</e>
	<e>"EventEmitter"</e>
</m></meta>
	</class>
	<class path="js.node.IStream" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/Stream.hx" module="js.node.Stream" extern="1" interface="1">
		<haxe_doc>`IStream` interface is used as "any Stream".

    See `Stream` for actual class.</haxe_doc>
		<meta><m n=":remove"/></meta>
	</class>
	<class path="js.node.Stream" params="TSelf" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/Stream.hx" extern="1">
		<extends path="js.node.events.EventEmitter"><c path="js.node.Stream.TSelf"/></extends>
		<new set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Base class for all streams.</haxe_doc>
		<meta><m n=":jsRequire"><e>"stream"</e></m></meta>
	</class>
	<class path="js.node.buffer.Buffer" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/buffer/Buffer.hx" extern="1">
		<extends path="js.lib.Uint8Array"/>
		<INSPECT_MAX_BYTES public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>How many bytes will be returned when `buffer.inspect()` is called.
		This can be overridden by user modules.
		Default: 50</haxe_doc>
		</INSPECT_MAX_BYTES>
		<get_INSPECT_MAX_BYTES get="inline" set="null" line="48" static="1"><f a=""><x path="Int"/></f></get_INSPECT_MAX_BYTES>
		<set_INSPECT_MAX_BYTES get="inline" set="null" line="51" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_INSPECT_MAX_BYTES>
		<kMaxLength public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Maximum length of a `Buffer`.</haxe_doc>
		</kMaxLength>
		<get_kMaxLength get="inline" set="null" line="59" static="1"><f a=""><x path="Int"/></f></get_kMaxLength>
		<isEncoding public="1" set="method" static="1">
			<f a="encoding">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the encoding is a valid encoding argument, or `false` otherwise.</haxe_doc>
		</isEncoding>
		<isBuffer public="1" set="method" static="1">
			<f a="obj">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tests if `obj` is a `Buffer`.</haxe_doc>
		</isBuffer>
		<byteLength public="1" set="method" static="1">
			<f a="string:?encoding">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Gives the actual byte length of a string.

		`encoding` defaults to 'utf8'.

		This is not the same as `String.length` since that
		returns the number of characters in a string.</haxe_doc>
		</byteLength>
		<_byteLength public="1" get="inline" set="null" line="94" static="1">
			<f a="string:?encoding">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":deprecated"><e>"In haxe 3.3+, use Buffer.byteLength instead!"</e></m>
			</meta>
			<haxe_doc>Gives the actual byte length of a string.

		`encoding` defaults to 'utf8'.

		This is not the same as `String.length` since that
		returns the number of characters in a string.</haxe_doc>
		</_byteLength>
		<concat public="1" set="method" static="1">
			<f a="list:?totalLength">
				<c path="Array"><c path="js.node.buffer.Buffer"/></c>
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Returns a buffer which is the result of concatenating all the buffers in the `list` together.

		If the `list` has no items, or if the `totalLength` is 0, then it returns a zero-length buffer.
		If the `list` has exactly one item, then the first item of the `list` is returned.
		If the `list` has more than one item, then a new `Buffer` is created.

		If `totalLength` is not provided, it is read from the buffers in the `list`.
		However, this adds an additional loop to the function, so it is faster to provide the length explicitly.</haxe_doc>
		</concat>
		<compareBuffers public="1" set="method" static="1">
			<f a="buf1:buf2">
				<c path="js.node.buffer.Buffer"/>
				<c path="js.node.buffer.Buffer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"compare"</e></m></meta>
			<haxe_doc>The same as `buf1.compare(buf2)`. Useful for sorting an Array of Buffers.</haxe_doc>
		</compareBuffers>
		<alloc public="1" set="method" static="1">
			<f a="size:?fill">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Allocates a new `Buffer` of `size` bytes.

		If `fill` is undefined, the `Buffer` will be zero-filled.

		Calling `Buffer.alloc(size)` can be significantly slower than the alternative `Buffer.allocUnsafe(size)`
		but ensures that the newly created `Buffer` instance contents will never contain sensitive data.</haxe_doc>
			<overloads><alloc public="1" set="method">
	<f a="size:fill:?encoding">
		<x path="Int"/>
		<c path="String"/>
		<c path="String"/>
		<c path="js.node.buffer.Buffer"/>
	</f>
	<haxe_doc>Allocates a new `Buffer` of `size` bytes.

		If `fill` is undefined, the `Buffer` will be zero-filled.

		Calling `Buffer.alloc(size)` can be significantly slower than the alternative `Buffer.allocUnsafe(size)`
		but ensures that the newly created `Buffer` instance contents will never contain sensitive data.</haxe_doc>
</alloc></overloads>
		</alloc>
		<allocUnsafe public="1" set="method" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Allocates a new non-zero-filled `Buffer` of `size` bytes.

		The underlying memory for `Buffer` instances created in this way is not initialized.
		The contents of the newly created `Buffer` are unknown and may contain sensitive data.
		Use `buf.fill(0)` to initialize such `Buffer` instances to zeroes.</haxe_doc>
		</allocUnsafe>
		<allocUnsafeSlow public="1" set="method" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Allocates a new non-zero-filled and non-pooled `Buffer` of `size` bytes.

		The underlying memory for `Buffer` instances created in this way is not initialized.
		The contents of the newly created `Buffer` are unknown and may contain sensitive data.
		Use `buf.fill(0)` to initialize such `Buffer` instances to zeroes.</haxe_doc>
		</allocUnsafeSlow>
		<from public="1" set="method" static="1">
			<f a="arrayBuffer:?byteOffset:?length">
				<c path="js.lib.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<overloads>
				<from public="1" set="method"><f a="buffer">
	<c path="js.node.buffer.Buffer"/>
	<c path="js.node.buffer.Buffer"/>
</f></from>
				<from public="1" set="method"><f a="str:?encoding">
	<c path="String"/>
	<c path="String"/>
	<c path="js.node.buffer.Buffer"/>
</f></from>
			</overloads>
		</from>
		<hxFromBytes public="1" get="inline" set="null" line="591" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Create `Buffer` object from `haxe.io.Bytes` using the same underlying data storage.
		Any modifications done using the returned object will be reflected in given `haxe.io.Bytes` object.</haxe_doc>
		</hxFromBytes>
		<toJSON public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>Returns a JSON-representation of the `Buffer` instance.</haxe_doc>
		</toJSON>
		<write public="1" set="method">
			<f a="string:?encoding">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Writes `string` to the buffer at `offset` using the given `encoding`.

		`offset` defaults to 0, encoding defaults to 'utf8'. `length` is the number of bytes to write.

		Returns number of octets written. If buffer did not contain enough space to fit the entire `string`,
		it will write a partial amount of the `string`. `length` defaults to `buffer.length - offset`.

		The method will not write partial characters.</haxe_doc>
			<overloads>
				<write public="1" set="method">
					<f a="string:offset:length:?encoding">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="String"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Writes `string` to the buffer at `offset` using the given `encoding`.

		`offset` defaults to 0, encoding defaults to 'utf8'. `length` is the number of bytes to write.

		Returns number of octets written. If buffer did not contain enough space to fit the entire `string`,
		it will write a partial amount of the `string`. `length` defaults to `buffer.length - offset`.

		The method will not write partial characters.</haxe_doc>
				</write>
				<write public="1" set="method">
					<f a="string:offset:?encoding">
						<c path="String"/>
						<x path="Int"/>
						<c path="String"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Writes `string` to the buffer at `offset` using the given `encoding`.

		`offset` defaults to 0, encoding defaults to 'utf8'. `length` is the number of bytes to write.

		Returns number of octets written. If buffer did not contain enough space to fit the entire `string`,
		it will write a partial amount of the `string`. `length` defaults to `buffer.length - offset`.

		The method will not write partial characters.</haxe_doc>
				</write>
			</overloads>
		</write>
		<toString public="1" set="method" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Decodes and returns a string from buffer data encoded with `encoding` (defaults to 'utf8')
		beginning at `start` (defaults to 0) and ending at `end` (defaults to `buffer.length`).</haxe_doc>
			<overloads><toString public="1" set="method">
	<f a="encoding:?start:?end">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<c path="String"/>
	</f>
	<haxe_doc>Decodes and returns a string from buffer data encoded with `encoding` (defaults to 'utf8')
		beginning at `start` (defaults to 0) and ending at `end` (defaults to `buffer.length`).</haxe_doc>
</toString></overloads>
		</toString>
		<copy public="1" set="method">
			<f a="targetBuffer:?targetStart:?sourceStart:?sourceEnd">
				<c path="js.node.buffer.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Does copy between buffers.
		The source and target regions can be overlapped.
		`targetStart` and `sourceStart` default to 0. `sourceEnd` defaults to `buffer.length`.</haxe_doc>
		</copy>
		<slice public="1" set="method" override="1">
			<f a="?start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Returns a new buffer which references the same memory as the old,
		but offset and cropped by the `start` (defaults to 0) and `end` (defaults to `buffer.length`) indexes.
		Negative indexes start from the end of the buffer.

		Modifying the new buffer slice will modify memory in the original buffer!</haxe_doc>
		</slice>
		<swap16 public="1" set="method">
			<f a=""><c path="js.node.buffer.Buffer"/></f>
			<haxe_doc>Interprets the `Buffer` as an array of unsigned 16-bit integers and swaps the byte-order in-place.

		Throws a `RangeError` if the `Buffer` length is not a multiple of 16 bits.
		The method returns a reference to the `Buffer`, so calls can be chained.</haxe_doc>
		</swap16>
		<swap32 public="1" set="method">
			<f a=""><c path="js.node.buffer.Buffer"/></f>
			<haxe_doc>Interprets the `Buffer` as an array of unsigned 32-bit integers and swaps the byte-order in-place.

		Throws a `RangeError` if the `Buffer` length is not a multiple of 32 bits.
		The method returns a reference to the `Buffer`, so calls can be chained.</haxe_doc>
		</swap32>
		<swap64 public="1" set="method">
			<f a=""><c path="js.node.buffer.Buffer"/></f>
			<haxe_doc>Interprets the `Buffer` as an array of 64-bit numbers and swaps the byte-order in-place.

		Throws a `RangeError` if the `Buffer` length is not a multiple of 64 bits.
		The method returns a reference to the `Buffer`, so calls can be chained.</haxe_doc>
		</swap64>
		<readUInt8 public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 8 bit integer from the buffer at the specified offset.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readUInt8>
		<readUInt16LE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 16 bit integer from the buffer at the specified `offset` with little-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readUInt16LE>
		<readUInt16BE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 16 bit integer from the buffer at the specified `offset` with big-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readUInt16BE>
		<readUInt32LE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 32 bit integer from the buffer at the specified `offset` with little-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readUInt32LE>
		<readUInt32BE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned 32 bit integer from the buffer at the specified `offset` with big-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readUInt32BE>
		<readInt8 public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 8 bit integer from the buffer at the specified `offset`.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.

		Works as `readUInt8`, except buffer contents are treated as two's complement signed values.</haxe_doc>
		</readInt8>
		<readInt16LE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 16 bit integer from the buffer at the specified `offset` with little-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.

		Works as `readUInt16LE`, except buffer contents are treated as two's complement signed values.</haxe_doc>
		</readInt16LE>
		<readInt16BE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 16 bit integer from the buffer at the specified `offset` with big-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.

		Works as `readUInt16BE`, except buffer contents are treated as two's complement signed values.</haxe_doc>
		</readInt16BE>
		<readInt32LE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 32 bit integer from the buffer at the specified `offset` with little-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.

		Works as `readUInt32LE`, except buffer contents are treated as two's complement signed values.</haxe_doc>
		</readInt32LE>
		<readInt32BE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed 32 bit integer from the buffer at the specified `offset` with big-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.

		Works as `readUInt32BE`, except buffer contents are treated as two's complement signed values.</haxe_doc>
		</readInt32BE>
		<readFloatLE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Reads a 32 bit float from the buffer at the specified `offset` with little-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readFloatLE>
		<readFloatBE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Reads a 32 bit float from the buffer at the specified `offset` with big-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readFloatBE>
		<readDoubleLE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Reads a 64 bit double from the buffer at the specified `offset` with little-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readDoubleLE>
		<readDoubleBE public="1" set="method">
			<f a="offset:?noAssert">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Reads a 64 bit double from the buffer at the specified `offset` with big-endian format.

		Set `noAssert` to `true` to skip validation of `offset`.
		This means that `offset` may be beyond the end of the buffer. Defaults to `false`.</haxe_doc>
		</readDoubleBE>
		<writeUInt8 public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset`.
		Note, `value` must be a valid unsigned 8 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeUInt8>
		<writeUInt16LE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with little-endian format.
		Note, `value` must be a valid unsigned 16 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeUInt16LE>
		<writeUInt16BE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with big-endian format.
		Note, `value` must be a valid unsigned 16 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeUInt16BE>
		<writeUInt32LE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with little-endian format.
		Note, `value` must be a valid unsigned 32 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeUInt32LE>
		<writeUInt32BE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with big-endian format.
		Note, `value` must be a valid unsigned 32 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeUInt32BE>
		<writeInt8 public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset`.
		Note, `value` must be a valid signed 8 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.

		Works as `writeUInt8`, except `value` is written out as a two's complement signed integer into buffer.</haxe_doc>
		</writeInt8>
		<writeInt16LE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with little-endian format.
		Note, value must be a valid signed 16 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.

		Works as `writeUInt16LE`, except `value` is written out as a two's complement signed integer into buffer.</haxe_doc>
		</writeInt16LE>
		<writeInt16BE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with big-endian format.
		Note, value must be a valid signed 16 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.

		Works as `writeUInt16BE`, except `value` is written out as a two's complement signed integer into buffer.</haxe_doc>
		</writeInt16BE>
		<writeInt32LE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with little-endian format.
		Note, value must be a valid signed 32 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.

		Works as `writeUInt32LE`, except `value` is written out as a two's complement signed integer into buffer.</haxe_doc>
		</writeInt32LE>
		<writeInt32BE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with big-endian format.
		Note, value must be a valid signed 32 bit integer.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.

		Works as `writeUInt32BE`, except `value` is written out as a two's complement signed integer into buffer.</haxe_doc>
		</writeInt32BE>
		<writeFloatLE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with little-endian format.
		Note, behavior is unspecified if `value` is not a 32 bit float.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeFloatLE>
		<writeFloatBE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with big-endian format.
		Note, behavior is unspecified if `value` is not a 32 bit float.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeFloatBE>
		<writeDoubleLE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with little-endian format.
		Note, `value` must be a valid 64 bit double.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeDoubleLE>
		<writeDoubleBE public="1" set="method">
			<f a="value:offset:?noAssert">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes `value` to the buffer at the specified `offset` with big-endian format.
		Note, `value` must be a valid 64 bit double.

		Set `noAssert` to `true` to skip validation of `value` and `offset`.
		This means that `value` may be too large for the specific function
		and `offset` may be beyond the end of the buffer leading to the values
		being silently dropped. This should not be used unless you are certain
		of correctness. Defaults to `false`.</haxe_doc>
		</writeDoubleBE>
		<fill public="1" set="method" override="1">
			<f a="value:?offset:?end">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.node.buffer.Buffer"/>
			</f>
			<haxe_doc>Fills the buffer with the specified `value`.
		If the `offset` (defaults to 0) and `end` (defaults to `buffer.length`)
		are not given it will fill the entire buffer.

		The method returns a reference to the `Buffer`, so calls can be chained.</haxe_doc>
			<overloads>
				<fill public="1" set="method">
					<f a="value:encoding">
						<c path="String"/>
						<c path="String"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Fills the buffer with the specified `value`.
		If the `offset` (defaults to 0) and `end` (defaults to `buffer.length`)
		are not given it will fill the entire buffer.

		The method returns a reference to the `Buffer`, so calls can be chained.</haxe_doc>
				</fill>
				<fill public="1" set="method">
					<f a="value:offset:encoding">
						<c path="String"/>
						<x path="Int"/>
						<c path="String"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Fills the buffer with the specified `value`.
		If the `offset` (defaults to 0) and `end` (defaults to `buffer.length`)
		are not given it will fill the entire buffer.

		The method returns a reference to the `Buffer`, so calls can be chained.</haxe_doc>
				</fill>
				<fill public="1" set="method">
					<f a="value:offset:end:encoding">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="String"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Fills the buffer with the specified `value`.
		If the `offset` (defaults to 0) and `end` (defaults to `buffer.length`)
		are not given it will fill the entire buffer.

		The method returns a reference to the `Buffer`, so calls can be chained.</haxe_doc>
				</fill>
				<fill public="1" set="method">
					<f a="value:?offset:?end">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.node.buffer.Buffer"/>
					</f>
					<haxe_doc>Fills the buffer with the specified `value`.
		If the `offset` (defaults to 0) and `end` (defaults to `buffer.length`)
		are not given it will fill the entire buffer.

		The method returns a reference to the `Buffer`, so calls can be chained.</haxe_doc>
				</fill>
			</overloads>
		</fill>
		<equals public="1" set="method">
			<f a="otherBuffer">
				<c path="js.node.buffer.Buffer"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns a boolean of whether `this` and `otherBuffer` have the same bytes.</haxe_doc>
		</equals>
		<compare public="1" set="method">
			<f a="otherBuffer:?targetStart:?targetEnd:?sourceStart:?sourceEnd">
				<c path="js.node.buffer.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns a number indicating whether `this` comes before or after or is the same as the `otherBuffer` in sort order.

		The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used
		to limit the comparison to specific ranges within the two `Buffer` objects.</haxe_doc>
		</compare>
		<indexOf public="1" set="method" override="1">
			<f a="value:?byteOffset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Operates similar to `Array.indexOf` in that it returns either

		the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.
		The value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.
		Buffers will use the entire `Buffer` (to compare a partial `Buffer` use buf.slice()).
		Numbers can range from 0 to 255.</haxe_doc>
			<overloads>
				<indexOf public="1" set="method">
					<f a="value:byteOffset:?encoding">
						<c path="String"/>
						<x path="Int"/>
						<c path="String"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Operates similar to `Array.indexOf` in that it returns either

		the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.
		The value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.
		Buffers will use the entire `Buffer` (to compare a partial `Buffer` use buf.slice()).
		Numbers can range from 0 to 255.</haxe_doc>
				</indexOf>
				<indexOf public="1" set="method">
					<f a="value:?encoding">
						<c path="String"/>
						<c path="String"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Operates similar to `Array.indexOf` in that it returns either

		the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.
		The value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.
		Buffers will use the entire `Buffer` (to compare a partial `Buffer` use buf.slice()).
		Numbers can range from 0 to 255.</haxe_doc>
				</indexOf>
				<indexOf public="1" set="method">
					<f a="value:?byteOffset">
						<c path="js.node.buffer.Buffer"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Operates similar to `Array.indexOf` in that it returns either

		the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.
		The value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.
		Buffers will use the entire `Buffer` (to compare a partial `Buffer` use buf.slice()).
		Numbers can range from 0 to 255.</haxe_doc>
				</indexOf>
			</overloads>
		</indexOf>
		<lastIndexOf public="1" set="method" override="1">
			<f a="value:?byteOffset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Identical to `indexOf`, but searches the `Buffer` from back to front instead of front to back.

		Returns the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.
		The value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.
		If `byteOffset` is provided, will return the last match that begins at or before `byteOffset`.</haxe_doc>
			<overloads>
				<lastIndexOf public="1" set="method">
					<f a="value:byteOffset:?encoding">
						<c path="String"/>
						<x path="Int"/>
						<c path="String"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Identical to `indexOf`, but searches the `Buffer` from back to front instead of front to back.

		Returns the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.
		The value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.
		If `byteOffset` is provided, will return the last match that begins at or before `byteOffset`.</haxe_doc>
				</lastIndexOf>
				<lastIndexOf public="1" set="method">
					<f a="value:?encoding">
						<c path="String"/>
						<c path="String"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Identical to `indexOf`, but searches the `Buffer` from back to front instead of front to back.

		Returns the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.
		The value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.
		If `byteOffset` is provided, will return the last match that begins at or before `byteOffset`.</haxe_doc>
				</lastIndexOf>
				<lastIndexOf public="1" set="method">
					<f a="value:?byteOffset">
						<c path="js.node.buffer.Buffer"/>
						<x path="Int"/>
						<x path="Int"/>
					</f>
					<haxe_doc>Identical to `indexOf`, but searches the `Buffer` from back to front instead of front to back.

		Returns the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.
		The value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.
		If `byteOffset` is provided, will return the last match that begins at or before `byteOffset`.</haxe_doc>
				</lastIndexOf>
			</overloads>
		</lastIndexOf>
		<includes public="1" set="method" override="1">
			<f a="value:?byteOffset">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<overloads>
				<includes public="1" set="method"><f a="value:byteOffset:?encoding">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
</f></includes>
				<includes public="1" set="method"><f a="value:?encoding">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></includes>
				<includes public="1" set="method"><f a="value:?byteOffset">
	<c path="js.node.buffer.Buffer"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></includes>
			</overloads>
		</includes>
		<hxToBytes public="1" get="inline" set="null" line="583">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Create `haxe.io.Bytes` object that uses the same underlying data storage as `this` buffer.
		Any modifications done using the returned object will be reflected in the `this` buffer.</haxe_doc>
		</hxToBytes>
		<new public="1" set="method">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allocates a new buffer.</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="string:?encoding">
						<c path="String"/>
						<c path="String"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Allocates a new buffer.</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="buffer">
						<c path="js.node.buffer.Buffer"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Allocates a new buffer.</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="arrayBuffer:?byteOffset:?length">
						<c path="js.lib.ArrayBuffer"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>Allocates a new buffer.</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>Allocates a new buffer.</haxe_doc>
				</new>
			</overloads>
		</new>
		<haxe_doc>The Buffer class is a global type for dealing with binary data directly. It can be constructed in a variety of ways.

	It supports array access syntax to get and set the octet at index. The values refer to individual bytes,
	so the legal range is between 0x00 and 0xFF hex or 0 and 255.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"buffer"</e>
	<e>"Buffer"</e>
</m></meta>
	</class>
	<abstract path="js.node.child_process.ChildProcessEvent" params="T" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/child_process/ChildProcess.hx" module="js.node.child_process.ChildProcess">
		<this><x path="js.node.events.Event"><c path="js.node.child_process.ChildProcessEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.child_process.ChildProcessEvent.T"/></x></icast></to>
		<haxe_doc>Enumeration of events emitted by `ChildProcess` objects.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.child_process._ChildProcess.ChildProcessEvent_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/child_process/ChildProcess.hx" private="1" module="js.node.child_process.ChildProcess" extern="1">
	<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="49" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "error"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Emitted when:
			1. The process could not be spawned, or
			2. The process could not be killed, or
			3. Sending a message to the child process failed for whatever reason.

		Note that the exit-event may or may not fire after an error has occured.
		If you are listening on both events to fire a function, remember to guard against calling your function twice.

		See also `ChildProcess.kill` and `ChildProcess.send`.</haxe_doc>
	</Error>
	<Exit public="1" get="inline" set="null" expr="cast &quot;exit&quot;" line="67" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "exit"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>This event is emitted after the child process ends.

		Listener arguments:
			code - the exit code, if it exited normally.
			signal - the signal passed to kill the child process, if it was killed by the parent.

		If the process terminated normally, `code` is the final exit code of the process, otherwise null.
		If the process terminated due to receipt of a signal, `signal` is the string name of the signal, otherwise null.

		Note that the child process stdio streams might still be open.

		Also, note that node establishes signal handlers for 'SIGINT' and 'SIGTERM',
		so it will not terminate due to receipt of those signals, it will exit.
		See waitpid(2).</haxe_doc>
	</Exit>
	<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="77" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "close"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>This event is emitted when the stdio streams of a child process have all terminated.
		This is distinct from `Exit`, since multiple processes might share the same stdio streams.

		Listener arguments:
			code - the exit code, if it exited normally.
			signal - the signal passed to kill the child process, if it was killed by the parent.</haxe_doc>
	</Close>
	<Disconnect public="1" get="inline" set="null" expr="cast &quot;disconnect&quot;" line="83" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "disconnect"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>This event is emitted after calling the `disconnect` method in the parent or in the child.
		After disconnecting it is no longer possible to send messages, and the `connected` property is false.</haxe_doc>
	</Disconnect>
	<Message public="1" get="inline" set="null" expr="cast &quot;message&quot;" line="94" static="1">
		<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "message"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Messages send by `send` are obtained using the message event.

		This event can also be listened on the `process` object to receive messages from the parent.

		Listener arguments:
			message - a parsed JSON object or primitive value
			sendHandle - a Socket or Server object</haxe_doc>
	</Message>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.child_process._ChildProcess.ChildProcessEvent_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/child_process/ChildProcess.hx" private="1" module="js.node.child_process.ChildProcess" extern="1">
		<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="49" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "error"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Emitted when:
			1. The process could not be spawned, or
			2. The process could not be killed, or
			3. Sending a message to the child process failed for whatever reason.

		Note that the exit-event may or may not fire after an error has occured.
		If you are listening on both events to fire a function, remember to guard against calling your function twice.

		See also `ChildProcess.kill` and `ChildProcess.send`.</haxe_doc>
		</Error>
		<Exit public="1" get="inline" set="null" expr="cast &quot;exit&quot;" line="67" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "exit"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>This event is emitted after the child process ends.

		Listener arguments:
			code - the exit code, if it exited normally.
			signal - the signal passed to kill the child process, if it was killed by the parent.

		If the process terminated normally, `code` is the final exit code of the process, otherwise null.
		If the process terminated due to receipt of a signal, `signal` is the string name of the signal, otherwise null.

		Note that the child process stdio streams might still be open.

		Also, note that node establishes signal handlers for 'SIGINT' and 'SIGTERM',
		so it will not terminate due to receipt of those signals, it will exit.
		See waitpid(2).</haxe_doc>
		</Exit>
		<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="77" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "close"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>This event is emitted when the stdio streams of a child process have all terminated.
		This is distinct from `Exit`, since multiple processes might share the same stdio streams.

		Listener arguments:
			code - the exit code, if it exited normally.
			signal - the signal passed to kill the child process, if it was killed by the parent.</haxe_doc>
		</Close>
		<Disconnect public="1" get="inline" set="null" expr="cast &quot;disconnect&quot;" line="83" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "disconnect"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>This event is emitted after calling the `disconnect` method in the parent or in the child.
		After disconnecting it is no longer possible to send messages, and the `connected` property is false.</haxe_doc>
		</Disconnect>
		<Message public="1" get="inline" set="null" expr="cast &quot;message&quot;" line="94" static="1">
			<x path="js.node.child_process.ChildProcessEvent"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "message"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Messages send by `send` are obtained using the message event.

		This event can also be listened on the `process` object to receive messages from the parent.

		Listener arguments:
			message - a parsed JSON object or primitive value
			sendHandle - a Socket or Server object</haxe_doc>
		</Message>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="js.node.child_process.ChildProcessSendOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/child_process/ChildProcess.hx" module="js.node.child_process.ChildProcess"><a><keepOpen>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Can be used when passing instances of `js.node.net.Socket`.

		When true, the socket is kept open in the sending process.

		Defaults to false.</haxe_doc>
</keepOpen></a></typedef>
	<class path="js.node.child_process.ChildProcess" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/child_process/ChildProcess.hx" extern="1">
		<extends path="js.node.events.EventEmitter"><c path="js.node.child_process.ChildProcess"/></extends>
		<stdin public="1" set="null">
			<c path="js.node.stream.IWritable"/>
			<haxe_doc>A Writable Stream that represents the child process's stdin.
		Closing this stream via `end` often causes the child process to terminate.

		If the child stdio streams are shared with the parent, then this will not be set.</haxe_doc>
		</stdin>
		<stdout public="1" set="null">
			<c path="js.node.stream.IReadable"/>
			<haxe_doc>A Readable Stream that represents the child process's stdout.

		If the child stdio streams are shared with the parent, then this will not be set.</haxe_doc>
		</stdout>
		<stderr public="1" set="null">
			<c path="js.node.stream.IReadable"/>
			<haxe_doc>A Readable Stream that represents the child process's stderr.

		If the child stdio streams are shared with the parent, then this will not be set.</haxe_doc>
		</stderr>
		<stdio public="1" set="null">
			<c path="Array"><c path="js.node.IStream"/></c>
			<haxe_doc>The parent end of the stdio pipes.</haxe_doc>
		</stdio>
		<pid public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The PID of the child process.</haxe_doc>
		</pid>
		<connected public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Set to false after `disconnect' is called
		If `connected` is false, it is no longer possible to send messages.</haxe_doc>
		</connected>
		<kill public="1" set="method">
			<f a="?signal">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Send a signal to the child process.

		If no argument is given, the process will be sent 'SIGTERM'.
		See signal(7) for a list of available signals.

		May emit an 'error' event when the signal cannot be delivered.

		Sending a signal to a child process that has already exited is not an error
		but may have unforeseen consequences: if the PID (the process ID) has been reassigned to another process,
		the signal will be delivered to that process instead. What happens next is anyone's guess.

		Note that while the function is called `kill`, the signal delivered to the child process may not actually kill it.
		`kill` really just sends a signal to a process. See kill(2)</haxe_doc>
		</kill>
		<send public="1" set="method">
			<f a="message:?callback">
				<d/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>When using `fork` you can write to the child using `send` and messages are received by a 'message' event on the child.

		In the child the `Process` object will have a `send` method, and process will emit objects each time it receives
		a message on its channel.

		Please note that the `send` method on both the parent and child are synchronous - sending large chunks of data is
		not advised (pipes can be used instead, see `spawn`).

		There is a special case when sending a {cmd: 'NODE_foo'} `message`. All messages containing a `NODE_` prefix in
		its cmd property will not be emitted in the 'message' event, since they are internal messages used by node core.
		Messages containing the prefix are emitted in the 'internalMessage' event, you should by all means avoid using
		this feature, it is subject to change without notice.

		The `sendHandle` option is for sending a TCP server or socket object to another process.
		The child will receive the object as its second argument to the message event.

		The `callback` option is a function that is invoked after the message is sent but before the target may have received it.
		It is called with a single argument: null on success, or an `Error` object on failure.

		Emits an 'error' event if the message cannot be sent, for example because the child process has already exited.

		Returns true under normal circumstances or false when the backlog of unsent messages exceeds a threshold that
		makes it unwise to send more. Use the callback mechanism to implement flow control.</haxe_doc>
			<overloads>
				<send public="1" set="method">
					<f a="message:sendHandle:options:?callback">
						<d/>
						<d/>
						<t path="js.node.child_process.ChildProcessSendOptions"/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
					</f>
					<haxe_doc>When using `fork` you can write to the child using `send` and messages are received by a 'message' event on the child.

		In the child the `Process` object will have a `send` method, and process will emit objects each time it receives
		a message on its channel.

		Please note that the `send` method on both the parent and child are synchronous - sending large chunks of data is
		not advised (pipes can be used instead, see `spawn`).

		There is a special case when sending a {cmd: 'NODE_foo'} `message`. All messages containing a `NODE_` prefix in
		its cmd property will not be emitted in the 'message' event, since they are internal messages used by node core.
		Messages containing the prefix are emitted in the 'internalMessage' event, you should by all means avoid using
		this feature, it is subject to change without notice.

		The `sendHandle` option is for sending a TCP server or socket object to another process.
		The child will receive the object as its second argument to the message event.

		The `callback` option is a function that is invoked after the message is sent but before the target may have received it.
		It is called with a single argument: null on success, or an `Error` object on failure.

		Emits an 'error' event if the message cannot be sent, for example because the child process has already exited.

		Returns true under normal circumstances or false when the backlog of unsent messages exceeds a threshold that
		makes it unwise to send more. Use the callback mechanism to implement flow control.</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="message:sendHandle:?callback">
						<d/>
						<d/>
						<f a="">
							<c path="js.lib.Error"/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
					</f>
					<haxe_doc>When using `fork` you can write to the child using `send` and messages are received by a 'message' event on the child.

		In the child the `Process` object will have a `send` method, and process will emit objects each time it receives
		a message on its channel.

		Please note that the `send` method on both the parent and child are synchronous - sending large chunks of data is
		not advised (pipes can be used instead, see `spawn`).

		There is a special case when sending a {cmd: 'NODE_foo'} `message`. All messages containing a `NODE_` prefix in
		its cmd property will not be emitted in the 'message' event, since they are internal messages used by node core.
		Messages containing the prefix are emitted in the 'internalMessage' event, you should by all means avoid using
		this feature, it is subject to change without notice.

		The `sendHandle` option is for sending a TCP server or socket object to another process.
		The child will receive the object as its second argument to the message event.

		The `callback` option is a function that is invoked after the message is sent but before the target may have received it.
		It is called with a single argument: null on success, or an `Error` object on failure.

		Emits an 'error' event if the message cannot be sent, for example because the child process has already exited.

		Returns true under normal circumstances or false when the backlog of unsent messages exceeds a threshold that
		makes it unwise to send more. Use the callback mechanism to implement flow control.</haxe_doc>
				</send>
			</overloads>
		</send>
		<disconnect public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the IPC channel between parent and child, allowing the child to exit gracefully once there are no other
		connections keeping it alive.

		After calling this method the `connected` flag will be set to false in both the parent and child,
		and it is no longer possible to send messages.

		The 'disconnect' event will be emitted when there are no messages in the process of being received,
		most likely immediately.

		Note that you can also call `process.disconnect` in the child process.</haxe_doc>
		</disconnect>
		<unref public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>By default, the parent will wait for the detached child to exit.
		To prevent the parent from waiting for a given child, use the `unref` method,
		and the parent's event loop will not include the child in its reference count.</haxe_doc>
		</unref>
		<haxe_doc>An object representing a child process.

	The `ChildProcess` class is not intended to be used directly. Use the spawn() or fork() module methods
	to create a `ChildProcess` instance.</haxe_doc>
	</class>
	<abstract path="js.node.events.EventEmitterEvent" params="T" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/events/EventEmitter.hx" module="js.node.events.EventEmitter">
		<this><x path="js.node.events.Event"><c path="js.node.events.EventEmitterEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.events.EventEmitterEvent.T"/></x></icast></to>
		<haxe_doc>Enumeration of events emitted by all `EventEmitter` instances.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.events._EventEmitter.EventEmitterEvent_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/events/EventEmitter.hx" private="1" module="js.node.events.EventEmitter" extern="1">
	<NewListener public="1" get="inline" set="null" expr="cast &quot;newListener&quot;" line="39" static="1">
		<x path="js.node.events.EventEmitterEvent"><f a=":">
	<c path="String"/>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "newListener"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>This event is emitted any time someone adds a new listener.

		Listener arguments:
			event - The event name
			listener - The event handler function

		It is unspecified if listener is in the list returned by emitter.listeners(event).</haxe_doc>
	</NewListener>
	<RemoveListener public="1" get="inline" set="null" expr="cast &quot;removeListener&quot;" line="50" static="1">
		<x path="js.node.events.EventEmitterEvent"><f a=":">
	<c path="String"/>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "removeListener"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>This event is emitted any time someone removes a listener.

		Listener arguments:
			event - The event name
			listener - The event handler function

		It is unspecified if listener is in the list returned by emitter.listeners(event).</haxe_doc>
	</RemoveListener>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.events._EventEmitter.EventEmitterEvent_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/events/EventEmitter.hx" private="1" module="js.node.events.EventEmitter" extern="1">
		<NewListener public="1" get="inline" set="null" expr="cast &quot;newListener&quot;" line="39" static="1">
			<x path="js.node.events.EventEmitterEvent"><f a=":">
	<c path="String"/>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "newListener"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>This event is emitted any time someone adds a new listener.

		Listener arguments:
			event - The event name
			listener - The event handler function

		It is unspecified if listener is in the list returned by emitter.listeners(event).</haxe_doc>
		</NewListener>
		<RemoveListener public="1" get="inline" set="null" expr="cast &quot;removeListener&quot;" line="50" static="1">
			<x path="js.node.events.EventEmitterEvent"><f a=":">
	<c path="String"/>
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "removeListener"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>This event is emitted any time someone removes a listener.

		Listener arguments:
			event - The event name
			listener - The event handler function

		It is unspecified if listener is in the list returned by emitter.listeners(event).</haxe_doc>
		</RemoveListener>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="js.node.events.Event" params="T" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/events/EventEmitter.hx" module="js.node.events.EventEmitter">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>Abstract type for events. Its type parameter is a signature
	of a listener for a concrete event.</haxe_doc>
		<impl><class path="js.node.events._EventEmitter.Event_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/events/EventEmitter.hx" private="1" module="js.node.events.EventEmitter" extern="1"/></impl>
	</abstract>
	<class path="js.node.events._EventEmitter.Event_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/events/EventEmitter.hx" private="1" module="js.node.events.EventEmitter" extern="1"/>
	<abstract path="js.node.stream.ReadableEvent" params="T" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Readable.hx" module="js.node.stream.Readable">
		<this><x path="js.node.events.Event"><c path="js.node.stream.ReadableEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.stream.ReadableEvent.T"/></x></icast></to>
		<haxe_doc>Enumeration of events emitted by the `Readable` class.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.stream._Readable.ReadableEvent_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Readable.hx" private="1" module="js.node.stream.Readable" extern="1">
	<Readable public="1" get="inline" set="null" expr="cast &quot;readable&quot;" line="47" static="1">
		<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "readable"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>When a chunk of data can be read from the stream, it will emit a `readable` event.

		In some cases, listening for a `readable` event will cause some data to be read into
		the internal buffer from the underlying system, if it hadn't already.

		Once the internal buffer is drained, a 'readable' event will fire again when more data is available.</haxe_doc>
	</Readable>
	<Data public="1" get="inline" set="null" expr="cast &quot;data&quot;" line="55" static="1">
		<x path="js.node.stream.ReadableEvent"><f a="">
	<x path="haxe.extern.EitherType">
		<t path="js.node.Buffer"/>
		<c path="String"/>
	</x>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "data"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>If you attach a 'data' event listener, then it will switch the stream into flowing mode,
		and data will be passed to your handler as soon as it is available.

		If you just want to get all the data out of the stream as fast as possible, this is the best way to do so.</haxe_doc>
	</Data>
	<End public="1" get="inline" set="null" expr="cast &quot;end&quot;" line="63" static="1">
		<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "end"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>This event fires when there will be no more data to read.

		Note that the 'end' event will not fire unless the data is completely consumed.
		This can be done by switching into flowing mode, or by calling 'read' repeatedly until you get to the end.</haxe_doc>
	</End>
	<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="70" static="1">
		<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "close"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Emitted when the underlying resource (for example, the backing file descriptor) has been closed.

		Not all streams will emit this.</haxe_doc>
	</Close>
	<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="75" static="1">
		<x path="js.node.stream.ReadableEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "error"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Emitted if there was an error receiving data.</haxe_doc>
	</Error>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.stream._Readable.ReadableEvent_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Readable.hx" private="1" module="js.node.stream.Readable" extern="1">
		<Readable public="1" get="inline" set="null" expr="cast &quot;readable&quot;" line="47" static="1">
			<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "readable"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>When a chunk of data can be read from the stream, it will emit a `readable` event.

		In some cases, listening for a `readable` event will cause some data to be read into
		the internal buffer from the underlying system, if it hadn't already.

		Once the internal buffer is drained, a 'readable' event will fire again when more data is available.</haxe_doc>
		</Readable>
		<Data public="1" get="inline" set="null" expr="cast &quot;data&quot;" line="55" static="1">
			<x path="js.node.stream.ReadableEvent"><f a="">
	<x path="haxe.extern.EitherType">
		<t path="js.node.Buffer"/>
		<c path="String"/>
	</x>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "data"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>If you attach a 'data' event listener, then it will switch the stream into flowing mode,
		and data will be passed to your handler as soon as it is available.

		If you just want to get all the data out of the stream as fast as possible, this is the best way to do so.</haxe_doc>
		</Data>
		<End public="1" get="inline" set="null" expr="cast &quot;end&quot;" line="63" static="1">
			<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "end"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>This event fires when there will be no more data to read.

		Note that the 'end' event will not fire unless the data is completely consumed.
		This can be done by switching into flowing mode, or by calling 'read' repeatedly until you get to the end.</haxe_doc>
		</End>
		<Close public="1" get="inline" set="null" expr="cast &quot;close&quot;" line="70" static="1">
			<x path="js.node.stream.ReadableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "close"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Emitted when the underlying resource (for example, the backing file descriptor) has been closed.

		Not all streams will emit this.</haxe_doc>
		</Close>
		<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="75" static="1">
			<x path="js.node.stream.ReadableEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "error"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Emitted if there was an error receiving data.</haxe_doc>
		</Error>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="js.node.stream.IReadable" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Readable.hx" module="js.node.stream.Readable" extern="1" interface="1">
		<read public="1" set="method"><f a="?size">
	<x path="Int"/>
	<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="js.node.Buffer"/>
</x></x>
</f></read>
		<setEncoding public="1" set="method"><f a="encoding">
	<c path="String"/>
	<x path="Void"/>
</f></setEncoding>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<pipe public="1" params="T" set="method"><f a="destination:?options">
	<c path="pipe.T"/>
	<a><end>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</end></a>
	<c path="pipe.T"/>
</f></pipe>
		<unpipe public="1" set="method">
			<f a="destination">
				<c path="js.node.stream.IWritable"/>
				<x path="Void"/>
			</f>
			<overloads><unpipe public="1" set="method"><f a=""><x path="Void"/></f></unpipe></overloads>
		</unpipe>
		<unshift public="1" set="method">
			<f a="chunk">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><unshift public="1" set="method"><f a="chunk">
	<t path="js.node.Buffer"/>
	<x path="Void"/>
</f></unshift></overloads>
		</unshift>
		<wrap public="1" set="method"><f a="stream">
	<d/>
	<c path="js.node.stream.IReadable"/>
</f></wrap>
		<haxe_doc>`IReadable` interface is used as "any Readable".

    See `Readable` for actual class documentation.</haxe_doc>
		<meta><m n=":remove"/></meta>
	</class>
	<class path="js.node.stream.Readable" params="TSelf" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Readable.hx" extern="1">
		<extends path="js.node.Stream"><c path="js.node.stream.Readable.TSelf"/></extends>
		<read public="1" set="method">
			<f a="?size">
				<x path="Int"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="js.node.Buffer"/>
</x></x>
			</f>
			<haxe_doc>The `read` method pulls some data out of the internal buffer and returns it.
		If there is no data available, then it will return null.

		If you pass in a `size` argument, then it will return that many bytes.
		If `size` bytes are not available, then it will return null.

		If you do not specify a `size` argument, then it will return all the data in the internal buffer.

		This method should only be called in non-flowing mode.
		In flowing-mode, this method is called automatically until the internal buffer is drained.</haxe_doc>
		</read>
		<setEncoding public="1" set="method">
			<f a="encoding">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Call this function to cause the stream to return strings of the specified encoding instead of `Buffer` objects.
		For example, if you do `setEncoding('utf8')`, then the output data will be interpreted as UTF-8 data,
		and returned as strings. If you do `setEncoding('hex')`, then the data will be encoded in hexadecimal string format.

		This properly handles multi-byte characters that would otherwise be potentially mangled if you simply pulled
		the `Buffer`s directly and called `buf.toString(encoding)` on them.

		If you want to read the data as strings, always use this method.</haxe_doc>
		</setEncoding>
		<resume public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method will cause the readable stream to resume emitting 'data' events.

		This method will switch the stream into flowing-mode.
		If you do not want to consume the data from a stream, but you do want to get to its `end` event,
		you can call `resume` to open the flow of data.</haxe_doc>
		</resume>
		<pause public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method will cause a stream in flowing-mode to stop emitting 'data' events.

		Any data that becomes available will remain in the internal buffer.

		This method is only relevant in flowing mode. When called on a non-flowing stream,
		it will switch into flowing mode, but remain paused.</haxe_doc>
		</pause>
		<pipe public="1" params="T" set="method">
			<f a="destination:?options">
				<c path="pipe.T"/>
				<a><end>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</end></a>
				<c path="pipe.T"/>
			</f>
			<haxe_doc>This method pulls all the data out of a readable stream, and writes it to the supplied destination,
		automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.

		Multiple destinations can be piped to safely.

		This function returns the destination stream, so you can set up pipe chains.

		By default `end` is called on the destination when the source stream emits 'end',
		so that destination is no longer writable. Pass `{end: false}` as `options`
		to keep the destination stream open.

		Note that `Process.stderr` and `Process.stdout` are never closed until the process exits,
		regardless of the specified options.</haxe_doc>
		</pipe>
		<unpipe public="1" set="method">
			<f a="destination">
				<c path="js.node.stream.IWritable"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method will remove the hooks set up for a previous `pipe` call.

		If the `destination` is not specified, then all pipes are removed.

		If the `destination` is specified, but no pipe is set up for it, then this is a no-op.</haxe_doc>
			<overloads><unpipe public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>This method will remove the hooks set up for a previous `pipe` call.

		If the `destination` is not specified, then all pipes are removed.

		If the `destination` is specified, but no pipe is set up for it, then this is a no-op.</haxe_doc>
</unpipe></overloads>
		</unpipe>
		<unshift public="1" set="method">
			<f a="chunk">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is useful in certain cases where a stream is being consumed by a parser,
		which needs to "un-consume" some data that it has optimistically pulled out of the source,
		so that the stream can be passed on to some other party.

		If you find that you must often call `unshift` in your programs,
		consider implementing a `Transform` stream instead.</haxe_doc>
			<overloads><unshift public="1" set="method">
	<f a="chunk">
		<t path="js.node.Buffer"/>
		<x path="Void"/>
	</f>
	<haxe_doc>This is useful in certain cases where a stream is being consumed by a parser,
		which needs to "un-consume" some data that it has optimistically pulled out of the source,
		so that the stream can be passed on to some other party.

		If you find that you must often call `unshift` in your programs,
		consider implementing a `Transform` stream instead.</haxe_doc>
</unshift></overloads>
		</unshift>
		<wrap public="1" set="method">
			<f a="stream">
				<d/>
				<c path="js.node.stream.IReadable"/>
			</f>
			<haxe_doc>Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today.

		If you are using an older Node library that emits 'data' events and has a 'pause' method that is advisory only,
		then you can use the `wrap` method to create a `Readable` stream that uses the old stream as its data source.</haxe_doc>
		</wrap>
		<_read set="method"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></_read>
		<push set="method">
			<f a="chunk:?encoding">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<overloads><push set="method"><f a="chunk">
	<t path="js.node.Buffer"/>
	<x path="Bool"/>
</f></push></overloads>
		</push>
		<new set="method"><f a="?options">
	<t path="js.node.stream.ReadableNewOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Readable stream interface is the abstraction for a source of data that you are reading from.
	In other words, data comes out of a Readable stream.

	A Readable stream will not start emitting data until you indicate that you are ready to receive it.

	Readable streams have two "modes": a flowing mode and a non-flowing mode.
	When in flowing mode, data is read from the underlying system and provided to your program as fast as possible.
	In non-flowing mode, you must explicitly call `read` to get chunks of data out.

	Examples of readable streams include:
		- http responses, on the client
		- http requests, on the server
		- fs read streams
		- zlib streams
		- crypto streams
		- tcp sockets
		- child process stdout and stderr
		- process.stdin</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"stream"</e>
	<e>"Readable"</e>
</m></meta>
	</class>
	<typedef path="js.node.stream.ReadableNewOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Readable.hx" module="js.node.stream.Readable">
		<a>
			<read>
				<x path="Null"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
			</read>
			<objectMode>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</objectMode>
			<highWaterMark>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</highWaterMark>
			<encoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
			</encoding>
			<destroy>
				<x path="Null"><f a=":">
	<x path="Null"><c path="js.lib.Error"/></x>
	<f a="">
		<x path="Null"><c path="js.lib.Error"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
			</destroy>
		</a>
		<haxe_doc>Options for `Readable` private constructor.
	For stream implementors only, see node.js API documentation</haxe_doc>
	</typedef>
	<abstract path="js.node.stream.WritableEvent" params="T" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Writable.hx" module="js.node.stream.Writable">
		<this><x path="js.node.events.Event"><c path="js.node.stream.WritableEvent.T"/></x></this>
		<to><icast><x path="js.node.events.Event"><c path="js.node.stream.WritableEvent.T"/></x></icast></to>
		<haxe_doc>Enumeration for `Writable` class events.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.node.stream._Writable.WritableEvent_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Writable.hx" private="1" module="js.node.stream.Writable" extern="1">
	<Drain public="1" get="inline" set="null" expr="cast &quot;drain&quot;" line="43" static="1">
		<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "drain"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>If a `writable.write(chunk)` call returns `false`, then the `drain` event will indicate
		when it is appropriate to begin writing more data to the stream.</haxe_doc>
	</Drain>
	<Finish public="1" get="inline" set="null" expr="cast &quot;finish&quot;" line="48" static="1">
		<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
		<meta>
			<m n=":value"><e>cast "finish"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>When the `end()` method has been called, and all data has been flushed to the underlying system, this event is emitted.</haxe_doc>
	</Finish>
	<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="57" static="1">
		<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.node.stream.IReadable"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "pipe"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Lister arguments:
			src - source stream that is piping to `this` writable

		This is emitted whenever the `pipe()` method is called on a readable stream,
		adding `this` writable to its set of destinations.</haxe_doc>
	</Pipe>
	<Unpipe public="1" get="inline" set="null" expr="cast &quot;unpipe&quot;" line="66" static="1">
		<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.node.stream.IReadable"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "unpipe"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Listener arguments:
			src - source stream that unpiped `this` writable

		This is emitted whenever the `unpipe()` method is called on a readable stream,
		removing `this` writable from its set of destinations.</haxe_doc>
	</Unpipe>
	<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="71" static="1">
		<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
		<meta>
			<m n=":value"><e>cast "error"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Emitted if there was an error when writing or piping data.</haxe_doc>
	</Error>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="js.node.stream._Writable.WritableEvent_Impl_" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Writable.hx" private="1" module="js.node.stream.Writable" extern="1">
		<Drain public="1" get="inline" set="null" expr="cast &quot;drain&quot;" line="43" static="1">
			<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "drain"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>If a `writable.write(chunk)` call returns `false`, then the `drain` event will indicate
		when it is appropriate to begin writing more data to the stream.</haxe_doc>
		</Drain>
		<Finish public="1" get="inline" set="null" expr="cast &quot;finish&quot;" line="48" static="1">
			<x path="js.node.stream.WritableEvent"><f a=""><x path="Void"/></f></x>
			<meta>
				<m n=":value"><e>cast "finish"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>When the `end()` method has been called, and all data has been flushed to the underlying system, this event is emitted.</haxe_doc>
		</Finish>
		<Pipe public="1" get="inline" set="null" expr="cast &quot;pipe&quot;" line="57" static="1">
			<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.node.stream.IReadable"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "pipe"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Lister arguments:
			src - source stream that is piping to `this` writable

		This is emitted whenever the `pipe()` method is called on a readable stream,
		adding `this` writable to its set of destinations.</haxe_doc>
		</Pipe>
		<Unpipe public="1" get="inline" set="null" expr="cast &quot;unpipe&quot;" line="66" static="1">
			<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.node.stream.IReadable"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "unpipe"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Listener arguments:
			src - source stream that unpiped `this` writable

		This is emitted whenever the `unpipe()` method is called on a readable stream,
		removing `this` writable from its set of destinations.</haxe_doc>
		</Unpipe>
		<Error public="1" get="inline" set="null" expr="cast &quot;error&quot;" line="71" static="1">
			<x path="js.node.stream.WritableEvent"><f a="">
	<c path="js.lib.Error"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>cast "error"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Emitted if there was an error when writing or piping data.</haxe_doc>
		</Error>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="js.node.stream.IWritable" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Writable.hx" module="js.node.stream.Writable" extern="1" interface="1">
		<write public="1" set="method">
			<f a="chunk:encoding:?callback">
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
			</f>
			<overloads>
				<write public="1" set="method"><f a="chunk:?callback">
	<t path="js.node.Buffer"/>
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
</f></write>
				<write public="1" set="method"><f a="chunk:?callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
</f></write>
			</overloads>
		</write>
		<end public="1" set="method">
			<f a="chunk:encoding:?callback">
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<overloads>
				<end public="1" set="method"><f a="?callback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></end>
				<end public="1" set="method"><f a="chunk:?callback">
	<t path="js.node.Buffer"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></end>
				<end public="1" set="method"><f a="chunk:?callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></end>
			</overloads>
		</end>
		<cork public="1" set="method"><f a=""><x path="Void"/></f></cork>
		<uncork public="1" set="method"><f a=""><x path="Void"/></f></uncork>
		<setDefaultEncoding public="1" set="method"><f a="encoding">
	<c path="String"/>
	<c path="js.node.stream.IWritable"/>
</f></setDefaultEncoding>
		<isTTY public="1" set="null"><x path="Bool"/></isTTY>
		<haxe_doc>Writable interface used for type parameter constraints.
    See `Writable` for actual class documentation.</haxe_doc>
		<meta><m n=":remove"/></meta>
	</class>
	<class path="js.node.stream.Writable" params="TSelf" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Writable.hx" extern="1">
		<extends path="js.node.Stream"><c path="js.node.stream.Writable.TSelf"/></extends>
		<write public="1" set="method">
			<f a="chunk:encoding:?callback">
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
			</f>
			<haxe_doc>This method writes some data to the underlying system,
		and calls the supplied callback once the data has been fully handled.

		The return value indicates if you should continue writing right now. If the data had to be buffered internally,
		then it will return `false`. Otherwise, it will return `true`.

		This return value is strictly advisory. You MAY continue to write, even if it returns `false`.
		However, writes will be buffered in memory, so it is best not to do this excessively.
		Instead, wait for the `drain` event before writing more data.</haxe_doc>
			<overloads>
				<write public="1" set="method">
					<f a="chunk:?callback">
						<t path="js.node.Buffer"/>
						<f a=""><x path="Void"/></f>
						<x path="Bool"/>
					</f>
					<haxe_doc>This method writes some data to the underlying system,
		and calls the supplied callback once the data has been fully handled.

		The return value indicates if you should continue writing right now. If the data had to be buffered internally,
		then it will return `false`. Otherwise, it will return `true`.

		This return value is strictly advisory. You MAY continue to write, even if it returns `false`.
		However, writes will be buffered in memory, so it is best not to do this excessively.
		Instead, wait for the `drain` event before writing more data.</haxe_doc>
				</write>
				<write public="1" set="method">
					<f a="chunk:?callback">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<x path="Bool"/>
					</f>
					<haxe_doc>This method writes some data to the underlying system,
		and calls the supplied callback once the data has been fully handled.

		The return value indicates if you should continue writing right now. If the data had to be buffered internally,
		then it will return `false`. Otherwise, it will return `true`.

		This return value is strictly advisory. You MAY continue to write, even if it returns `false`.
		However, writes will be buffered in memory, so it is best not to do this excessively.
		Instead, wait for the `drain` event before writing more data.</haxe_doc>
				</write>
			</overloads>
		</write>
		<end public="1" set="method">
			<f a="chunk:encoding:?callback">
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Call this method when no more data will be written to the stream.
		If supplied, the callback is attached as a listener on the `finish` event.

		Calling `write()` after calling `end()` will raise an error.</haxe_doc>
			<overloads>
				<end public="1" set="method">
					<f a="?callback">
						<f a=""><x path="Void"/></f>
						<x path="Void"/>
					</f>
					<haxe_doc>Call this method when no more data will be written to the stream.
		If supplied, the callback is attached as a listener on the `finish` event.

		Calling `write()` after calling `end()` will raise an error.</haxe_doc>
				</end>
				<end public="1" set="method">
					<f a="chunk:?callback">
						<t path="js.node.Buffer"/>
						<f a=""><x path="Void"/></f>
						<x path="Void"/>
					</f>
					<haxe_doc>Call this method when no more data will be written to the stream.
		If supplied, the callback is attached as a listener on the `finish` event.

		Calling `write()` after calling `end()` will raise an error.</haxe_doc>
				</end>
				<end public="1" set="method">
					<f a="chunk:?callback">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<x path="Void"/>
					</f>
					<haxe_doc>Call this method when no more data will be written to the stream.
		If supplied, the callback is attached as a listener on the `finish` event.

		Calling `write()` after calling `end()` will raise an error.</haxe_doc>
				</end>
			</overloads>
		</end>
		<isTTY public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Terminal write streams (i.e. process.stdout) have this property set to true.
		It is false for any other write streams.</haxe_doc>
		</isTTY>
		<cork public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The writable.cork() method forces all written data to be buffered in memory.
		The buffered data will be flushed when either the stream.uncork() or stream.end() methods are called.</haxe_doc>
		</cork>
		<uncork public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The writable.uncork() method flushes all data buffered since stream.cork() was called.</haxe_doc>
		</uncork>
		<setDefaultEncoding public="1" set="method">
			<f a="encoding">
				<c path="String"/>
				<c path="js.node.stream.Writable.TSelf"/>
			</f>
			<haxe_doc>The writable.setDefaultEncoding() method sets the default encoding for a Writable stream.</haxe_doc>
		</setDefaultEncoding>
		<_write set="method">
			<f a="chunk:encoding:callback">
				<t path="js.node.Buffer"/>
				<c path="String"/>
				<f a="">
					<c path="js.lib.Error"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<overloads><_write set="method"><f a="chunk:encoding:callback">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="js.lib.Error"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_write></overloads>
		</_write>
		<new set="method"><f a="?options">
	<t path="js.node.stream.WritableNewOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Writable stream interface is an abstraction for a destination that you are writing data to.

	Examples of writable streams include:
		- http requests, on the client
		- http responses, on the server
		- fs write streams
		- zlib streams
		- crypto streams
		- tcp sockets
		- child process stdin
		- process.stdout, process.stderr</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"stream"</e>
	<e>"Writable"</e>
</m></meta>
	</class>
	<typedef path="js.node.stream.WritableNewOptions" params="" file="/home/travis/haxe/lib/hxnodejs/10,0,0/src/js/node/stream/Writable.hx" module="js.node.stream.Writable">
		<a>
			<writev>
				<x path="Null"><f a=":">
	<c path="Array"><a>
	<encoding><c path="String"/></encoding>
	<chunk><d/></chunk>
</a></c>
	<f a="">
		<x path="Null"><c path="js.lib.Error"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
			</writev>
			<write>
				<x path="Null"><f a="::">
	<d/>
	<c path="String"/>
	<f a="">
		<x path="Null"><c path="js.lib.Error"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
			</write>
			<objectMode>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</objectMode>
			<highWaterMark>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</highWaterMark>
			<emitClose>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</emitClose>
			<destroy>
				<x path="Null"><f a=":">
	<x path="Null"><c path="js.lib.Error"/></x>
	<f a="">
		<x path="Null"><c path="js.lib.Error"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
			</destroy>
			<defaultEncoding>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
			</defaultEncoding>
			<decodeStrings>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</decodeStrings>
		</a>
		<haxe_doc>Options for `Writable` private constructor.
	For stream implementors only, see node.js API documentation</haxe_doc>
	</typedef>
	<class path="vscode.debugAdapter.Source" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<name public="1"><c path="String"/></name>
		<path public="1"><c path="String"/></path>
		<sourceReference public="1"><x path="Int"/></sourceReference>
		<new public="1" set="method">
			<f a="name:path:?id:?origin:?data" v="::0::">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Source"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Scope" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<name public="1"><c path="String"/></name>
		<variablesReference public="1"><x path="Int"/></variablesReference>
		<namedVariables public="1"><x path="Int"/></namedVariables>
		<indexedVariables public="1"><x path="Int"/></indexedVariables>
		<expensive public="1"><x path="Bool"/></expensive>
		<new public="1" set="method">
			<f a="name:reference:?expensive" v="::false">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ expensive : false }</e></m></meta>
		</new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Scope"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.StackFrame" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<id public="1"><x path="Int"/></id>
		<source public="1"><c path="vscode.debugAdapter.Source"/></source>
		<line public="1"><x path="Int"/></line>
		<column public="1"><x path="Int"/></column>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method">
			<f a="i:nm:?src:?ln:?col" v=":::0:0">
				<x path="Int"/>
				<c path="String"/>
				<c path="vscode.debugAdapter.Source"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ col : 0, ln : 0 }</e></m></meta>
		</new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"StackFrame"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Thread" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<id public="1"><x path="Int"/></id>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="id:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Thread"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Variable" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<variablesReference public="1"><x path="Int"/></variablesReference>
		<new public="1" set="method">
			<f a="name:value:?ref:?indexedVariables:?namedVariables" v="::0::">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ref : 0 }</e></m></meta>
		</new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Variable"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Breakpoint" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<id public="1"><x path="Int"/></id>
		<verified public="1"><x path="Bool"/></verified>
		<message public="1"><c path="String"/></message>
		<source public="1"><t path="vscode.debugProtocol._DebugProtocol.TSource"/></source>
		<line public="1"><x path="Int"/></line>
		<column public="1"><x path="Int"/></column>
		<endLine public="1"><x path="Int"/></endLine>
		<endColumn public="1"><x path="Int"/></endColumn>
		<new public="1" set="method"><f a="verified:?line:?column:?source">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="vscode.debugAdapter.Source"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Breakpoint"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Module" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<id public="1"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<c path="String"/>
</x></id>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="id:name">
	<x path="haxe.extern.EitherType">
		<x path="Int"/>
		<c path="String"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Module"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.CompletionItem" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<label public="1"><c path="String"/></label>
		<start public="1"><x path="Int"/></start>
		<length public="1"><x path="Int"/></length>
		<new public="1" set="method">
			<f a="label:start:?length" v="::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0 }</e></m></meta>
		</new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"CompletionItem"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Message" params="" file="src/vscode/debugAdapter/Messages.hx" module="vscode.debugAdapter.Messages" extern="1">
		<seq public="1"><x path="Int"/></seq>
		<type public="1"><x path="vscode.debugProtocol.MessageType"/></type>
		<new public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Message"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Event" params="T" file="src/vscode/debugAdapter/Messages.hx" module="vscode.debugAdapter.Messages" extern="1">
		<extends path="vscode.debugAdapter.Message"/>
		<event public="1"><c path="String"/></event>
		<body public="1"><c path="vscode.debugAdapter.Event.T"/></body>
		<new public="1" set="method"><f a="event:?body">
	<c path="String"/>
	<c path="vscode.debugAdapter.Event.T"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Event"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.StoppedEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TStoppedEvent"/></extends>
		<reason public="1"><c path="String"/></reason>
		<threadId public="1"><x path="Int"/></threadId>
		<text public="1"><c path="String"/></text>
		<allThreadsStopped public="1"><x path="Bool"/></allThreadsStopped>
		<new public="1" set="method"><f a="reason:?threadId:?exception_text">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"StoppedEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.ContinuedEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TContinuedEvent"/></extends>
		<new public="1" set="method"><f a="threadId:?allThreadsContinued">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"ContinuedEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.InitializedEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><a/></extends>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"InitializedEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.TerminatedEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TTerminatedEvent"/></extends>
		<new public="1" set="method"><f a="?restart">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"TerminatedEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.OutputEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TOutputEvent"/></extends>
		<new public="1" set="method">
			<f a="output:?category" v=":Console">
				<c path="String"/>
				<x path="vscode.debugProtocol.OutputEventCategory"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ category : Console }</e></m></meta>
		</new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"OutputEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.ThreadEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TThreadEvent"/></extends>
		<new public="1" set="method"><f a="reason:threadId">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"ThreadEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.BreakpointEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TBreakpointEvent"/></extends>
		<new public="1" set="method"><f a="reason:breakpoint">
	<x path="vscode.debugProtocol.BreakpointEventReason"/>
	<c path="vscode.debugAdapter.Breakpoint"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"BreakpointEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.ModuleEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TModuleEvent"/></extends>
		<new public="1" set="method"><f a="reason:module">
	<x path="vscode.debugProtocol.ModuleEventReason"/>
	<c path="vscode.debugAdapter.Module"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"ModuleEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.LoadedSourceEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TLoadedSourceEvent"/></extends>
		<new public="1" set="method"><f a="reason:source">
	<x path="vscode.debugProtocol.LoadedSourceEventReason"/>
	<c path="vscode.debugAdapter.Source"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"LoadedSourceEvent"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.CapabilitiesEvent" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession" extern="1">
		<extends path="vscode.debugAdapter.Event"><t path="vscode.debugProtocol.TCapabilitiesEvent"/></extends>
		<new public="1" set="method"><f a="capabilities">
	<t path="vscode.debugProtocol.Capabilities"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"CapabilitiesEvent"</e>
</m></meta>
	</class>
	<abstract path="vscode.debugAdapter.ErrorDestination" params="" file="src/vscode/debugAdapter/DebugSession.hx" module="vscode.debugAdapter.DebugSession">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugAdapter._DebugSession.ErrorDestination_Impl_" params="" file="src/vscode/debugAdapter/DebugSession.hx" private="1" module="vscode.debugAdapter.DebugSession" extern="1">
	<User public="1" get="inline" set="null" expr="cast 1" line="135" static="1">
		<x path="vscode.debugAdapter.ErrorDestination"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</User>
	<Telemetry public="1" get="inline" set="null" expr="cast 2" line="136" static="1">
		<x path="vscode.debugAdapter.ErrorDestination"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Telemetry>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugAdapter._DebugSession.ErrorDestination_Impl_" params="" file="src/vscode/debugAdapter/DebugSession.hx" private="1" module="vscode.debugAdapter.DebugSession" extern="1">
		<User public="1" get="inline" set="null" expr="cast 1" line="135" static="1">
			<x path="vscode.debugAdapter.ErrorDestination"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</User>
		<Telemetry public="1" get="inline" set="null" expr="cast 2" line="136" static="1">
			<x path="vscode.debugAdapter.ErrorDestination"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Telemetry>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="vscode.debugAdapter.ProtocolServer" params="" file="src/vscode/debugAdapter/Protocol.hx" module="vscode.debugAdapter.Protocol" extern="1">
		<sendEvent public="1" params="T" set="method"><f a="event">
	<t path="vscode.debugProtocol.Event"><c path="sendEvent.T"/></t>
	<x path="Void"/>
</f></sendEvent>
		<sendResponse public="1" params="T" set="method"><f a="response">
	<t path="vscode.debugProtocol.Response"><c path="sendResponse.T"/></t>
	<x path="Void"/>
</f></sendResponse>
		<sendRequest public="1" params="T" set="method"><f a="command:args:timeout:cb">
	<c path="String"/>
	<d/>
	<x path="Float"/>
	<f a="response">
		<t path="vscode.debugProtocol.Response"><c path="sendRequest.T"/></t>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></sendRequest>
		<onDidSendMessage public="1" set="null">
			<t path="vscode.debugAdapter.Event0"><t path="vscode.debugAdapter.DebugProtocolMessage"/></t>
			<haxe_doc>vscode.DebugAdapter methods</haxe_doc>
		</onDidSendMessage>
		<dispose public="1" set="method"><f a=""><x path="Any"/></f></dispose>
		<handleMessage public="1" set="method"><f a="message">
	<t path="vscode.debugProtocol.ProtocolMessage"/>
	<x path="Void"/>
</f></handleMessage>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"ProtocolServer"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.DebugSession" params="" file="src/vscode/debugAdapter/DebugSession.hx" extern="1">
		<extends path="vscode.debugAdapter.ProtocolServer"/>
		<run public="1" set="method" static="1"><f a="debugSession">
	<x path="Class"><c path="vscode.debugAdapter.DebugSession"/></x>
	<x path="Void"/>
</f></run>
		<setDebuggerPathFormat public="1" set="method"><f a="format">
	<c path="String"/>
	<x path="Void"/>
</f></setDebuggerPathFormat>
		<setDebuggerLinesStartAt1 public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebuggerLinesStartAt1>
		<setDebuggerColumnsStartAt1 public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebuggerColumnsStartAt1>
		<setRunAsServer public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setRunAsServer>
		<shutdown public="1" set="method"><f a=""><x path="Void"/></f></shutdown>
		<sendErrorResponse params="T" set="method">
			<f a="response:codeOrMessage:?format:?variables:?dest" v="::::User">
				<c path="vscode.debugAdapter.Response"><c path="sendErrorResponse.T"/></c>
				<x path="haxe.extern.EitherType">
					<x path="Int"/>
					<c path="vscode.debugAdapter.Message"/>
				</x>
				<c path="String"/>
				<d/>
				<x path="vscode.debugAdapter.ErrorDestination"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dest : User }</e></m></meta>
		</sendErrorResponse>
		<runInTerminalRequest set="method"><f a="args:timeout:cb">
	<t path="vscode.debugProtocol.RunInTerminalRequestArguments"/>
	<x path="Float"/>
	<f a="response">
		<t path="vscode.debugProtocol.RunInTerminalResponse"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></runInTerminalRequest>
		<dispatchRequest params="T" set="method"><f a="request">
	<t path="vscode.debugProtocol.Request"><c path="dispatchRequest.T"/></t>
	<x path="Void"/>
</f></dispatchRequest>
		<initializeRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.InitializeResponse"/>
	<t path="vscode.debugProtocol.InitializeRequestArguments"/>
	<x path="Void"/>
</f></initializeRequest>
		<disconnectRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.DisconnectResponse"/>
	<t path="vscode.debugProtocol.DisconnectArguments"/>
	<x path="Void"/>
</f></disconnectRequest>
		<launchRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.LaunchResponse"/>
	<t path="vscode.debugProtocol.LaunchRequestArguments"/>
	<x path="Void"/>
</f></launchRequest>
		<attachRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.AttachResponse"/>
	<t path="vscode.debugProtocol.AttachRequestArguments"/>
	<x path="Void"/>
</f></attachRequest>
		<terminateRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.TerminateResponse"/>
	<t path="vscode.debugProtocol.TerminateArguments"/>
	<x path="Void"/>
</f></terminateRequest>
		<restartRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.RestartResponse"/>
	<t path="vscode.debugProtocol.RestartArguments"/>
	<x path="Void"/>
</f></restartRequest>
		<setBreakPointsRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.SetBreakpointsResponse"/>
	<t path="vscode.debugProtocol.SetBreakpointsArguments"/>
	<x path="Void"/>
</f></setBreakPointsRequest>
		<setFunctionBreakPointsRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.SetFunctionBreakpointsResponse"/>
	<t path="vscode.debugProtocol.SetFunctionBreakpointsArguments"/>
	<x path="Void"/>
</f></setFunctionBreakPointsRequest>
		<setExceptionBreakPointsRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.SetExceptionBreakpointsResponse"/>
	<t path="vscode.debugProtocol.SetExceptionBreakpointsArguments"/>
	<x path="Void"/>
</f></setExceptionBreakPointsRequest>
		<configurationDoneRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.ConfigurationDoneResponse"/>
	<t path="vscode.debugProtocol.ConfigurationDoneArguments"/>
	<x path="Void"/>
</f></configurationDoneRequest>
		<continueRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.ContinueResponse"/>
	<t path="vscode.debugProtocol.ContinueArguments"/>
	<x path="Void"/>
</f></continueRequest>
		<nextRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.NextResponse"/>
	<t path="vscode.debugProtocol.NextArguments"/>
	<x path="Void"/>
</f></nextRequest>
		<stepInRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.StepInResponse"/>
	<t path="vscode.debugProtocol.StepInArguments"/>
	<x path="Void"/>
</f></stepInRequest>
		<stepOutRequest set="method"><f a="responses:args">
	<t path="vscode.debugProtocol.StepOutResponse"/>
	<t path="vscode.debugProtocol.StepOutArguments"/>
	<x path="Void"/>
</f></stepOutRequest>
		<stepBackRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.StepBackResponse"/>
	<t path="vscode.debugProtocol.StepBackArguments"/>
	<x path="Void"/>
</f></stepBackRequest>
		<reverseContinueRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.ReverseContinueResponse"/>
	<t path="vscode.debugProtocol.ReverseContinueArguments"/>
	<x path="Void"/>
</f></reverseContinueRequest>
		<restartFrameRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.RestartFrameResponse"/>
	<t path="vscode.debugProtocol.RestartFrameArguments"/>
	<x path="Void"/>
</f></restartFrameRequest>
		<gotoRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.GotoResponse"/>
	<t path="vscode.debugProtocol.GotoArguments"/>
	<x path="Void"/>
</f></gotoRequest>
		<pauseRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.PauseResponse"/>
	<t path="vscode.debugProtocol.PauseArguments"/>
	<x path="Void"/>
</f></pauseRequest>
		<sourceRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.SourceResponse"/>
	<t path="vscode.debugProtocol.SourceArguments"/>
	<x path="Void"/>
</f></sourceRequest>
		<threadsRequest set="method"><f a="response">
	<t path="vscode.debugProtocol.ThreadsResponse"/>
	<x path="Void"/>
</f></threadsRequest>
		<terminateThreadsRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.TerminateThreadsResponse"/>
	<t path="vscode.debugProtocol.TerminateThreadsRequest"/>
	<x path="Void"/>
</f></terminateThreadsRequest>
		<stackTraceRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.StackTraceResponse"/>
	<t path="vscode.debugProtocol.StackTraceArguments"/>
	<x path="Void"/>
</f></stackTraceRequest>
		<scopesRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.ScopesResponse"/>
	<t path="vscode.debugProtocol.ScopesArguments"/>
	<x path="Void"/>
</f></scopesRequest>
		<variablesRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.VariablesResponse"/>
	<t path="vscode.debugProtocol.VariablesArguments"/>
	<x path="Void"/>
</f></variablesRequest>
		<setVariableRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.SetVariableResponse"/>
	<t path="vscode.debugProtocol.SetVariableArguments"/>
	<x path="Void"/>
</f></setVariableRequest>
		<setExpressionRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.SetExpressionResponse"/>
	<t path="vscode.debugProtocol.SetExpressionArguments"/>
	<x path="Void"/>
</f></setExpressionRequest>
		<evaluateRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.EvaluateResponse"/>
	<t path="vscode.debugProtocol.EvaluateArguments"/>
	<x path="Void"/>
</f></evaluateRequest>
		<stepInTargetsRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.StepInTargetsResponse"/>
	<t path="vscode.debugProtocol.StepInTargetsArguments"/>
	<x path="Void"/>
</f></stepInTargetsRequest>
		<gotoTargetsRequest set="method"><f a="responses:args">
	<t path="vscode.debugProtocol.GotoTargetsResponse"/>
	<t path="vscode.debugProtocol.GotoTargetsArguments"/>
	<x path="Void"/>
</f></gotoTargetsRequest>
		<completionsRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.CompletionsResponse"/>
	<t path="vscode.debugProtocol.CompletionsArguments"/>
	<x path="Void"/>
</f></completionsRequest>
		<exceptionInfoRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.ExceptionInfoResponse"/>
	<t path="vscode.debugProtocol.ExceptionInfoArguments"/>
	<x path="Void"/>
</f></exceptionInfoRequest>
		<loadedSourcesRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.LoadedSourcesResponse"/>
	<t path="vscode.debugProtocol.LoadedSourcesArguments"/>
	<x path="Void"/>
</f></loadedSourcesRequest>
		<dataBreakpointInfoRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.DataBreakpointInfoResponse"/>
	<t path="vscode.debugProtocol.DataBreakpointInfoArguments"/>
	<x path="Void"/>
</f></dataBreakpointInfoRequest>
		<setDataBreakpointsRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.SetDataBreakpointsResponse"/>
	<t path="vscode.debugProtocol.SetDataBreakpointsArguments"/>
	<x path="Void"/>
</f></setDataBreakpointsRequest>
		<readMemoryRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.ReadMemoryResponse"/>
	<t path="vscode.debugProtocol.ReadMemoryArguments"/>
	<x path="Void"/>
</f></readMemoryRequest>
		<disassembleRequest set="method"><f a="response:args">
	<t path="vscode.debugProtocol.DisassembleResponse"/>
	<t path="vscode.debugProtocol.DisassembleArguments"/>
	<x path="Void"/>
</f></disassembleRequest>
		<customRequest params="T" set="method"><f a="command:response:args">
	<c path="String"/>
	<c path="vscode.debugAdapter.Response"><c path="customRequest.T"/></c>
	<d/>
	<x path="Void"/>
</f></customRequest>
		<convertClientLineToDebugger set="method"><f a="line">
	<x path="Int"/>
	<x path="Int"/>
</f></convertClientLineToDebugger>
		<convertDebuggerLineToClient set="method"><f a="line">
	<x path="Int"/>
	<x path="Int"/>
</f></convertDebuggerLineToClient>
		<convertClientColumnToDebugger set="method"><f a="line">
	<x path="Int"/>
	<x path="Int"/>
</f></convertClientColumnToDebugger>
		<convertDebuggerColumnToClient set="method"><f a="line">
	<x path="Int"/>
	<x path="Int"/>
</f></convertDebuggerColumnToClient>
		<convertClientPathToDebugger set="method"><f a="clientPath">
	<c path="String"/>
	<c path="String"/>
</f></convertClientPathToDebugger>
		<convertDebuggerPathToClient set="method"><f a="debugPath">
	<c path="String"/>
	<c path="String"/>
</f></convertDebuggerPathToClient>
		<new public="1" set="method"><f a="?obsolete_debuggerLinesAndColumnsStartAt1:?obsolete_isServer">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"DebugSession"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Handles" params="T" file="src/vscode/debugAdapter/Handles.hx" extern="1">
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
		<create public="1" set="method"><f a="value">
	<c path="vscode.debugAdapter.Handles.T"/>
	<x path="Int"/>
</f></create>
		<get public="1" set="method"><f a="handle:?dflt">
	<x path="Int"/>
	<c path="vscode.debugAdapter.Handles.T"/>
	<c path="vscode.debugAdapter.Handles.T"/>
</f></get>
		<new public="1" set="method"><f a="?startHandle">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Handles"</e>
</m></meta>
	</class>
	<abstract path="vscode.debugAdapter.LogLevel" params="" file="src/vscode/debugAdapter/Logger.hx" module="vscode.debugAdapter.Logger">
		<this><x path="Int"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode-debugadapter"</e>
				<e>"LogLevel"</e>
			</m>
		</meta>
		<impl><class path="vscode.debugAdapter._Logger.LogLevel_Impl_" params="" file="src/vscode/debugAdapter/Logger.hx" private="1" module="vscode.debugAdapter.Logger" extern="1">
	<Verbose public="1" set="null" static="1">
		<x path="vscode.debugAdapter.LogLevel"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Verbose>
	<Log public="1" set="null" static="1">
		<x path="vscode.debugAdapter.LogLevel"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Log>
	<Warn public="1" set="null" static="1">
		<x path="vscode.debugAdapter.LogLevel"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Warn>
	<Error public="1" set="null" static="1">
		<x path="vscode.debugAdapter.LogLevel"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Error>
	<Stop public="1" set="null" static="1">
		<x path="vscode.debugAdapter.LogLevel"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Stop>
	<meta>
		<m n=":jsRequire">
			<e>"vscode-debugadapter"</e>
			<e>"LogLevel"</e>
		</m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode.debugAdapter._Logger.LogLevel_Impl_" params="" file="src/vscode/debugAdapter/Logger.hx" private="1" module="vscode.debugAdapter.Logger" extern="1">
		<Verbose public="1" set="null" static="1">
			<x path="vscode.debugAdapter.LogLevel"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Verbose>
		<Log public="1" set="null" static="1">
			<x path="vscode.debugAdapter.LogLevel"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Log>
		<Warn public="1" set="null" static="1">
			<x path="vscode.debugAdapter.LogLevel"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Warn>
		<Error public="1" set="null" static="1">
			<x path="vscode.debugAdapter.LogLevel"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Error>
		<Stop public="1" set="null" static="1">
			<x path="vscode.debugAdapter.LogLevel"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Stop>
		<meta>
			<m n=":jsRequire">
				<e>"vscode-debugadapter"</e>
				<e>"LogLevel"</e>
			</m>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="vscode.debugAdapter.ILogCallback" params="" file="src/vscode/debugAdapter/Logger.hx" module="vscode.debugAdapter.Logger"><f a="outputEvent">
	<t path="vscode.debugProtocol.OutputEvent"/>
	<x path="Void"/>
</f></typedef>
	<typedef path="vscode.debugAdapter.ILogger" params="" file="src/vscode/debugAdapter/Logger.hx" module="vscode.debugAdapter.Logger"><a>
	<warn set="method"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></warn>
	<verbose set="method"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></verbose>
	<log set="method"><f a="msg:?level">
	<c path="String"/>
	<x path="vscode.debugAdapter.LogLevel"/>
	<x path="Void"/>
</f></log>
	<error set="method"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></error>
</a></typedef>
	<class path="vscode.debugAdapter.Logger" params="" file="src/vscode/debugAdapter/Logger.hx" extern="1">
		<log public="1" set="method"><f a="msg:?level">
	<c path="String"/>
	<x path="vscode.debugAdapter.LogLevel"/>
	<x path="Void"/>
</f></log>
		<verbose public="1" set="method"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></verbose>
		<warn public="1" set="method"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></warn>
		<error public="1" set="method"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></error>
		<dispose public="1" set="method"><f a=""><c path="js.lib.Promise"><x path="Void"/></c></f></dispose>
		<setup public="1" set="method">
			<f a="consoleMinLogLevel:?_logFilePath:?prependTimestamp" v="::true">
				<x path="vscode.debugAdapter.LogLevel"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<x path="Bool"/>
				</x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ prependTimestamp : true }</e></m></meta>
			<haxe_doc>Set the logger's minimum level to log in the console, and whether to log to the file. Log messages are queued before this is
		called the first time, because minLogLevel defaults to Warn.</haxe_doc>
		</setup>
		<init public="1" set="method"><f a="logCallback:?logFilePath:?logToConsole">
	<t path="vscode.debugAdapter.ILogCallback"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></init>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Logger"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.LoggingDebugSession" params="" file="src/vscode/debugAdapter/LoggingDebugSession.hx" extern="1">
		<extends path="vscode.debugAdapter.DebugSession"/>
		<new public="1" set="method"><f a="?obsolete_logFilePath:?obsolete_debuggerLinesAndColumnsStartAt1:?obsolete_isServer">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"LoggingDebugSession"</e>
</m></meta>
	</class>
	<class path="vscode.debugAdapter.Response" params="T" file="src/vscode/debugAdapter/Messages.hx" module="vscode.debugAdapter.Messages" extern="1">
		<extends path="vscode.debugAdapter.Message"/>
		<request_seq public="1"><x path="Int"/></request_seq>
		<success public="1"><x path="Bool"/></success>
		<command public="1"><c path="String"/></command>
		<new public="1" set="method"><f a="request:?message">
	<t path="vscode.debugProtocol.Request"><c path="vscode.debugAdapter.Response.T"/></t>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Response"</e>
</m></meta>
	</class>
	<typedef path="vscode.debugAdapter.DebugProtocolMessage" params="" file="src/vscode/debugAdapter/Protocol.hx" module="vscode.debugAdapter.Protocol"><a/></typedef>
	<class path="vscode.debugAdapter.Disposable0" params="" file="src/vscode/debugAdapter/Protocol.hx" module="vscode.debugAdapter.Protocol" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Any"/></f></dispose>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter"</e>
	<e>"Disposable0"</e>
</m></meta>
	</class>
	<typedef path="vscode.debugAdapter.Event0" params="T" file="src/vscode/debugAdapter/Protocol.hx" module="vscode.debugAdapter.Protocol"><f a="listener:?thisArg">
	<f a="e">
		<c path="vscode.debugAdapter.Event0.T"/>
		<x path="Any"/>
	</f>
	<x path="Any"/>
	<c path="vscode.debugAdapter.Disposable0"/>
</f></typedef>
	<typedef path="vscode.debugAdapter.testSupport.ILocation" params="" file="src/vscode/debugAdapter/testSupport/DebugClient.hx" module="vscode.debugAdapter.testSupport.DebugClient"><a>
	<verified>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</verified>
	<path><c path="String"/></path>
	<line><x path="Int"/></line>
	<column>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</column>
</a></typedef>
	<typedef path="vscode.debugAdapter.testSupport.IPartialLocation" params="" file="src/vscode/debugAdapter/testSupport/DebugClient.hx" module="vscode.debugAdapter.testSupport.DebugClient"><a>
	<verified>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</verified>
	<path>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</path>
	<line>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</line>
	<column>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</column>
</a></typedef>
	<class path="vscode.debugAdapter.testSupport.DebugClient" params="" file="src/vscode/debugAdapter/testSupport/DebugClient.hx" extern="1">
		<defaultTimeout public="1"><x path="Int"/></defaultTimeout>
		<start public="1" set="method">
			<f a="?port">
				<x path="Int"/>
				<c path="js.lib.Promise"><d/></c>
			</f>
			<haxe_doc>Starts a new debug adapter and sets up communication via stdin/stdout.
		If a port number is specified the adapter is not launched but a connection to
		a debug adapter running in server mode is established. This is useful for debugging
		the adapter while running tests. For this reason all timeouts are disabled in server mode.</haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a=""><c path="js.lib.Promise"><d/></c></f>
			<haxe_doc>Shutdown the debuggee and the debug adapter (or disconnect if in server mode).</haxe_doc>
		</stop>
		<initializeRequest public="1" set="method"><f a="?args">
	<t path="vscode.debugProtocol.InitializeRequestArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.InitializeResponse"/></c>
</f></initializeRequest>
		<configurationDoneRequest public="1" set="method"><f a="?args">
	<t path="vscode.debugProtocol.ConfigurationDoneArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.ConfigurationDoneResponse"/></c>
</f></configurationDoneRequest>
		<launchRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.LaunchRequestArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.LaunchResponse"/></c>
</f></launchRequest>
		<attachRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.AttachRequestArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.AttachResponse"/></c>
</f></attachRequest>
		<restartRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.RestartArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.RestartResponse"/></c>
</f></restartRequest>
		<terminateRequest public="1" set="method"><f a="?args">
	<t path="vscode.debugProtocol.TerminateArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.TerminateResponse"/></c>
</f></terminateRequest>
		<disconnectRequest public="1" set="method"><f a="?args">
	<t path="vscode.debugProtocol.DisconnectArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.DisconnectResponse"/></c>
</f></disconnectRequest>
		<setBreakpointsRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.SetBreakpointsArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.SetBreakpointsResponse"/></c>
</f></setBreakpointsRequest>
		<setFunctionBreakpointsRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.SetFunctionBreakpointsArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.SetFunctionBreakpointsResponse"/></c>
</f></setFunctionBreakpointsRequest>
		<setExceptionBreakpointsRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.SetExceptionBreakpointsArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.SetExceptionBreakpointsResponse"/></c>
</f></setExceptionBreakpointsRequest>
		<dataBreakpointInfoRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.DataBreakpointInfoArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.DataBreakpointInfoResponse"/></c>
</f></dataBreakpointInfoRequest>
		<setDataBreakpointsRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.SetDataBreakpointsArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.SetDataBreakpointsResponse"/></c>
</f></setDataBreakpointsRequest>
		<continueRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.ContinueArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.ContinueResponse"/></c>
</f></continueRequest>
		<nextRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.NextArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.NextResponse"/></c>
</f></nextRequest>
		<stepInRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.StepInArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.StepInResponse"/></c>
</f></stepInRequest>
		<stepOutRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.StepOutArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.StepOutResponse"/></c>
</f></stepOutRequest>
		<stepBackRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.StepBackArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.StepBackResponse"/></c>
</f></stepBackRequest>
		<reverseContinueRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.ReverseContinueArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.ReverseContinueResponse"/></c>
</f></reverseContinueRequest>
		<restartFrameRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.RestartFrameArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.RestartFrameResponse"/></c>
</f></restartFrameRequest>
		<gotoRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.GotoArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.GotoResponse"/></c>
</f></gotoRequest>
		<pauseRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.PauseArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.PauseResponse"/></c>
</f></pauseRequest>
		<stackTraceRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.StackTraceArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.StackTraceResponse"/></c>
</f></stackTraceRequest>
		<scopesRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.ScopesArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.ScopesResponse"/></c>
</f></scopesRequest>
		<variablesRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.VariablesArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.VariablesResponse"/></c>
</f></variablesRequest>
		<setVariableRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.SetVariableArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.SetVariableResponse"/></c>
</f></setVariableRequest>
		<sourceRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.SourceArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.SourceResponse"/></c>
</f></sourceRequest>
		<threadsRequest public="1" set="method"><f a=""><c path="js.lib.Promise"><t path="vscode.debugProtocol.ThreadsResponse"/></c></f></threadsRequest>
		<modulesRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.ModulesArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.ModulesResponse"/></c>
</f></modulesRequest>
		<evaluateRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.EvaluateArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.EvaluateResponse"/></c>
</f></evaluateRequest>
		<stepInTargetsRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.StepInTargetsArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.StepInTargetsResponse"/></c>
</f></stepInTargetsRequest>
		<gotoTargetsRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.GotoTargetsArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.GotoTargetsResponse"/></c>
</f></gotoTargetsRequest>
		<completionsRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.CompletionsArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.CompletionsResponse"/></c>
</f></completionsRequest>
		<exceptionInfoRequest public="1" set="method"><f a="args">
	<t path="vscode.debugProtocol.ExceptionInfoArguments"/>
	<c path="js.lib.Promise"><t path="vscode.debugProtocol.ExceptionInfoResponse"/></c>
</f></exceptionInfoRequest>
		<customRequest public="1" params="T" set="method"><f a="command:?args">
	<c path="String"/>
	<d/>
	<t path="vscode.debugProtocol.Response"><c path="customRequest.T"/></t>
</f></customRequest>
		<waitForEvent public="1" params="T" set="method">
			<f a="eventType:?timeout">
				<c path="String"/>
				<x path="Int"/>
				<c path="js.lib.Promise"><t path="vscode.debugProtocol.Event"><c path="waitForEvent.T"/></t></c>
			</f>
			<haxe_doc>Returns a promise that will resolve if an event with a specific type was received within some specified time.
		The promise will be rejected if a timeout occurs.</haxe_doc>
		</waitForEvent>
		<configurationSequence public="1" set="method">
			<f a=""><c path="js.lib.Promise"><d/></c></f>
			<haxe_doc>Returns a promise that will resolve if an 'initialized' event was received within some specified time
		and a subsequent 'configurationDone' request was successfully executed.
		The promise will be rejected if a timeout occurs or if the 'configurationDone' request fails.</haxe_doc>
		</configurationSequence>
		<launch public="1" set="method">
			<f a="launchArgs">
				<d/>
				<c path="js.lib.Promise"><t path="vscode.debugProtocol.LaunchResponse"/></c>
			</f>
			<haxe_doc>Returns a promise that will resolve if a 'initialize' and a 'launch' request were successful.</haxe_doc>
		</launch>
		<assertStoppedLocation public="1" set="method">
			<f a="reason:expected">
				<c path="String"/>
				<a>
					<path>
						<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="js.lib.RegExp"/>
</x></x>
						<meta><m n=":optional"/></meta>
					</path>
					<line>
						<x path="Null"><x path="Int"/></x>
						<meta><m n=":optional"/></meta>
					</line>
					<column>
						<x path="Null"><x path="Int"/></x>
						<meta><m n=":optional"/></meta>
					</column>
				</a>
				<c path="js.lib.Promise"><t path="vscode.debugProtocol.StackTraceResponse"/></c>
			</f>
			<haxe_doc>Returns a promise that will resolve if a 'stopped' event was received within some specified time
		and the event's reason and line number was asserted.
		The promise will be rejected if a timeout occurs, the assertions fail, or if the 'stackTrace' request fails.</haxe_doc>
		</assertStoppedLocation>
		<assertOutput public="1" params="T" set="method">
			<f a="category:expected:?timeout">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="js.lib.Promise"><t path="vscode.debugProtocol.Event"><c path="assertOutput.T"/></t></c>
			</f>
			<haxe_doc>Returns a promise that will resolve if enough output events with the given category have been received
		and the concatenated data match the expected data.
		The promise will be rejected as soon as the received data cannot match the expected data or if a timeout occurs.</haxe_doc>
		</assertOutput>
		<assertPath public="1" set="method"><f a="path:expected:?message">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="String"/>
		<c path="js.lib.RegExp"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></assertPath>
		<hitBreakpoint public="1" set="method">
			<f a="launchArgs:location:?expectedStopLocation:?expectedBPLocation">
				<d/>
				<t path="vscode.debugAdapter.testSupport.ILocation"/>
				<t path="vscode.debugAdapter.testSupport.IPartialLocation"/>
				<t path="vscode.debugAdapter.testSupport.IPartialLocation"/>
				<c path="js.lib.Promise"><d/></c>
			</f>
			<haxe_doc>Returns a promise that will resolve if a configurable breakpoint has been hit within some time
		and the event's reason and line number was asserted.
		The promise will be rejected if a timeout occurs, the assertions fail, or if the requests fails.</haxe_doc>
		</hitBreakpoint>
		<new public="1" set="method">
			<f a="runtime:executable:debugType:?spawnOptions:?enableStderr">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="js.node.ChildProcessSpawnOptions"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Creates a DebugClient object that provides a promise-based API to write
		debug adapter tests.
		A simple mocha example for setting and hitting a breakpoint in line 15 of a program 'test.js' looks like this:

		var dc;
		setup( () => {
			dc = new DebugClient('node', './out/node/nodeDebug.js', 'node');
			return dc.start();
		});
		teardown( () => dc.stop() );

		test('should stop on a breakpoint', () => {
			return dc.hitBreakpoint({ program: 'test.js' }, 'test.js', 15);
		});]]></haxe_doc>
		</new>
		<meta><m n=":jsRequire">
	<e>"vscode-debugadapter-testsupport"</e>
	<e>"DebugClient"</e>
</m></meta>
	</class>
	<abstract path="vscode.debugProtocol.MessageType" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.MessageType_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Request public="1" get="inline" set="null" expr="cast &quot;request&quot;" line="7" static="1">
		<x path="vscode.debugProtocol.MessageType"/>
		<meta>
			<m n=":value"><e>cast "request"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Request>
	<Response public="1" get="inline" set="null" expr="cast &quot;response&quot;" line="8" static="1">
		<x path="vscode.debugProtocol.MessageType"/>
		<meta>
			<m n=":value"><e>cast "response"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Response>
	<Event public="1" get="inline" set="null" expr="cast &quot;event&quot;" line="9" static="1">
		<x path="vscode.debugProtocol.MessageType"/>
		<meta>
			<m n=":value"><e>cast "event"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Event>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.MessageType_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Request public="1" get="inline" set="null" expr="cast &quot;request&quot;" line="7" static="1">
			<x path="vscode.debugProtocol.MessageType"/>
			<meta>
				<m n=":value"><e>cast "request"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Request>
		<Response public="1" get="inline" set="null" expr="cast &quot;response&quot;" line="8" static="1">
			<x path="vscode.debugProtocol.MessageType"/>
			<meta>
				<m n=":value"><e>cast "response"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Response>
		<Event public="1" get="inline" set="null" expr="cast &quot;event&quot;" line="9" static="1">
			<x path="vscode.debugProtocol.MessageType"/>
			<meta>
				<m n=":value"><e>cast "event"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Event>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.ProtocolMessage" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<type>
				<x path="vscode.debugProtocol.MessageType"/>
				<haxe_doc>Message type.
		Values: 'request', 'response', 'event', etc.</haxe_doc>
			</type>
			<seq>
				<x path="Int"/>
				<haxe_doc>Sequence number (also known as message ID). For protocol messages of type 'request' this ID can be used to cancel the request.</haxe_doc>
			</seq>
		</a>
		<haxe_doc>Base class of requests, responses, and events.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Request" params="T" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<type>
				<x path="vscode.debugProtocol.MessageType"/>
				<haxe_doc>Message type.
		Values: 'request', 'response', 'event', etc.</haxe_doc>
			</type>
			<seq>
				<x path="Int"/>
				<haxe_doc>Sequence number (also known as message ID). For protocol messages of type 'request' this ID can be used to cancel the request.</haxe_doc>
			</seq>
			<command>
				<c path="String"/>
				<haxe_doc>The command to execute.</haxe_doc>
			</command>
			<arguments>
				<x path="Null"><c path="vscode.debugProtocol.Request.T"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Object containing arguments for the command.</haxe_doc>
			</arguments>
		</a>
		<haxe_doc>A client or debug adapter initiated request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Event" params="T" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<type>
				<x path="vscode.debugProtocol.MessageType"/>
				<haxe_doc>Message type.
		Values: 'request', 'response', 'event', etc.</haxe_doc>
			</type>
			<seq>
				<x path="Int"/>
				<haxe_doc>Sequence number (also known as message ID). For protocol messages of type 'request' this ID can be used to cancel the request.</haxe_doc>
			</seq>
			<event>
				<c path="String"/>
				<haxe_doc>Type of event.</haxe_doc>
			</event>
			<body>
				<x path="Null"><c path="vscode.debugProtocol.Event.T"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Event-specific information.</haxe_doc>
			</body>
		</a>
		<haxe_doc>A debug adapter initiated event.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Response" params="T" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<type>
				<x path="vscode.debugProtocol.MessageType"/>
				<haxe_doc>Message type.
		Values: 'request', 'response', 'event', etc.</haxe_doc>
			</type>
			<success>
				<x path="Bool"/>
				<haxe_doc>Outcome of the request.
		If true, the request was successful and the 'body' attribute may contain the result of the request.
		If the value is false, the attribute 'message' contains the error in short form and the 'body' may contain additional information (see 'ErrorResponse.body.error').</haxe_doc>
			</success>
			<seq>
				<x path="Int"/>
				<haxe_doc>Sequence number (also known as message ID). For protocol messages of type 'request' this ID can be used to cancel the request.</haxe_doc>
			</seq>
			<request_seq>
				<x path="Int"/>
				<haxe_doc>Sequence number of the corresponding request.</haxe_doc>
			</request_seq>
			<message>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Contains error message if success == false.
		This raw error might be interpreted by the frontend and is not shown in the UI.
		Some predefined values exist.
		Values:
		'cancelled': request was cancelled.
		etc.</haxe_doc>
			</message>
			<command>
				<c path="String"/>
				<haxe_doc>The command requested.</haxe_doc>
			</command>
			<body>
				<x path="Null"><c path="vscode.debugProtocol.Response.T"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Contains request result if success is true and optional error details if success is false.</haxe_doc>
			</body>
		</a>
		<haxe_doc>Response to a request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ErrorResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><error>
	<x path="Null"><t path="vscode.debugProtocol.Message"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>An optional, structured error message.</haxe_doc>
</error></a></t>
		<haxe_doc>On error (whenever 'success' is false), the body can provide more details.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.CancelRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.CancelArguments"/></t>
		<haxe_doc>Cancel request; value of command field is 'cancel'.
	The 'cancel' request is used by the frontend to indicate that it is no longer interested in the result produced by a specific request issued earlier.
	This request has a hint characteristic: a debug adapter can only be expected to make a 'best effort' in honouring this request but there are no guarantees.
	The 'cancel' request may return an error if it could not cancel an operation but a frontend should refrain from presenting this error to end users.
	A frontend client should only call this request if the capability 'supportsCancelRequest' is true.
	The request that got canceled still needs to send a response back.
	This can either be a normal result ('success' attribute true) or an error response ('success' attribute false and the 'message' set to 'cancelled').
	Returning partial results from a cancelled request is possible but please note that a frontend client has no generic way for detecting that a response is partial or not.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.CancelArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><requestId>
	<x path="Null"><x path="Int"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The ID (attribute 'seq') of the request to cancel.</haxe_doc>
</requestId></a>
		<haxe_doc>Arguments for 'cancel' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.CancelResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'cancel' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.InitializedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><d/></t>
		<haxe_doc>Event message for 'initialized' event type.
	This event indicates that the debug adapter is ready to accept configuration requests (e.g. SetBreakpointsRequest, SetExceptionBreakpointsRequest).
	A debug adapter is expected to send this event when it is ready to accept configuration requests (but not before the 'initialize' request has finished).
	The sequence of events/requests is as follows:
	- adapters sends 'initialized' event (after the 'initialize' request has returned)
	- frontend sends zero or more 'setBreakpoints' requests
	- frontend sends one 'setFunctionBreakpoints' request (if capability 'supportsFunctionBreakpoints' is true)
	- frontend sends a 'setExceptionBreakpoints' request if one or more 'exceptionBreakpointFilters' have been defined (or if 'supportsConfigurationDoneRequest' is not defined or false)
	- frontend sends other future configuration requests
	- frontend sends one 'configurationDone' request to indicate the end of the configuration.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.StopReason" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.StopReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Step public="1" get="inline" set="null" expr="cast &quot;step&quot;" line="147" static="1">
		<x path="vscode.debugProtocol.StopReason"/>
		<meta>
			<m n=":value"><e>cast "step"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Step>
	<Breakpoint public="1" get="inline" set="null" expr="cast &quot;breakpoint&quot;" line="148" static="1">
		<x path="vscode.debugProtocol.StopReason"/>
		<meta>
			<m n=":value"><e>cast "breakpoint"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Breakpoint>
	<Exception public="1" get="inline" set="null" expr="cast &quot;exception&quot;" line="149" static="1">
		<x path="vscode.debugProtocol.StopReason"/>
		<meta>
			<m n=":value"><e>cast "exception"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Exception>
	<Pause public="1" get="inline" set="null" expr="cast &quot;pause&quot;" line="150" static="1">
		<x path="vscode.debugProtocol.StopReason"/>
		<meta>
			<m n=":value"><e>cast "pause"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Pause>
	<Entry public="1" get="inline" set="null" expr="cast &quot;entry&quot;" line="151" static="1">
		<x path="vscode.debugProtocol.StopReason"/>
		<meta>
			<m n=":value"><e>cast "entry"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Entry>
	<Goto public="1" get="inline" set="null" expr="cast &quot;goto&quot;" line="152" static="1">
		<x path="vscode.debugProtocol.StopReason"/>
		<meta>
			<m n=":value"><e>cast "goto"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Goto>
	<FunctionBreakpoint public="1" get="inline" set="null" expr="cast &quot;function breakpoint&quot;" line="153" static="1">
		<x path="vscode.debugProtocol.StopReason"/>
		<meta>
			<m n=":value"><e>cast "function breakpoint"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FunctionBreakpoint>
	<DataBreakpoint public="1" get="inline" set="null" expr="cast &quot;data breakpoint&quot;" line="154" static="1">
		<x path="vscode.debugProtocol.StopReason"/>
		<meta>
			<m n=":value"><e>cast "data breakpoint"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DataBreakpoint>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.StopReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Step public="1" get="inline" set="null" expr="cast &quot;step&quot;" line="147" static="1">
			<x path="vscode.debugProtocol.StopReason"/>
			<meta>
				<m n=":value"><e>cast "step"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Step>
		<Breakpoint public="1" get="inline" set="null" expr="cast &quot;breakpoint&quot;" line="148" static="1">
			<x path="vscode.debugProtocol.StopReason"/>
			<meta>
				<m n=":value"><e>cast "breakpoint"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Breakpoint>
		<Exception public="1" get="inline" set="null" expr="cast &quot;exception&quot;" line="149" static="1">
			<x path="vscode.debugProtocol.StopReason"/>
			<meta>
				<m n=":value"><e>cast "exception"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Exception>
		<Pause public="1" get="inline" set="null" expr="cast &quot;pause&quot;" line="150" static="1">
			<x path="vscode.debugProtocol.StopReason"/>
			<meta>
				<m n=":value"><e>cast "pause"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Pause>
		<Entry public="1" get="inline" set="null" expr="cast &quot;entry&quot;" line="151" static="1">
			<x path="vscode.debugProtocol.StopReason"/>
			<meta>
				<m n=":value"><e>cast "entry"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Entry>
		<Goto public="1" get="inline" set="null" expr="cast &quot;goto&quot;" line="152" static="1">
			<x path="vscode.debugProtocol.StopReason"/>
			<meta>
				<m n=":value"><e>cast "goto"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Goto>
		<FunctionBreakpoint public="1" get="inline" set="null" expr="cast &quot;function breakpoint&quot;" line="153" static="1">
			<x path="vscode.debugProtocol.StopReason"/>
			<meta>
				<m n=":value"><e>cast "function breakpoint"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FunctionBreakpoint>
		<DataBreakpoint public="1" get="inline" set="null" expr="cast &quot;data breakpoint&quot;" line="154" static="1">
			<x path="vscode.debugProtocol.StopReason"/>
			<meta>
				<m n=":value"><e>cast "data breakpoint"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DataBreakpoint>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.TStoppedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a>
	<threadId>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The thread which was stopped.</haxe_doc>
	</threadId>
	<text>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Additional information. E.g. if reason is 'exception', text contains the exception name. This string is shown in the UI.</haxe_doc>
	</text>
	<reason>
		<x path="vscode.debugProtocol.StopReason"/>
		<haxe_doc>The reason for the event.
		For backward compatibility this string is shown in the UI if the 'description' attribute is missing (but it must not be translated).
		Values: 'step', 'breakpoint', 'exception', 'pause', 'entry', 'goto', 'function breakpoint', 'data breakpoint', etc.</haxe_doc>
	</reason>
	<preserveFocusHint>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A value of true hints to the frontend that this event should not change the focus.</haxe_doc>
	</preserveFocusHint>
	<description>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The full reason for the event, e.g. 'Paused on exception'. This string is shown in the UI as is and must be translated.</haxe_doc>
	</description>
	<allThreadsStopped>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>If 'allThreadsStopped' is true, a debug adapter can announce that all threads have stopped.
		- The client should use this information to enable that all threads can be expanded to access their stacktraces.
		- If the attribute is missing or false, only the thread with the given threadId can be expanded.</haxe_doc>
	</allThreadsStopped>
</a></typedef>
	<typedef path="vscode.debugProtocol.StoppedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TStoppedEvent"/></t>
		<haxe_doc>Event message for 'stopped' event type.
	The event indicates that the execution of the debuggee has stopped due to some condition.
	This can be caused by a break point previously set, a stepping action has completed, by executing a debugger statement etc.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TContinuedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a>
	<threadId>
		<x path="Int"/>
		<haxe_doc>The thread which was continued.</haxe_doc>
	</threadId>
	<allThreadsContinued>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>If 'allThreadsContinued' is true, a debug adapter can announce that all threads have continued.</haxe_doc>
	</allThreadsContinued>
</a></typedef>
	<typedef path="vscode.debugProtocol.ContinuedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TContinuedEvent"/></t>
		<haxe_doc>Event message for 'continued' event type.
	The event indicates that the execution of the debuggee has continued.
	Please note: a debug adapter is not expected to send this event in response to a request that implies that execution continues, e.g. 'launch' or 'continue'.
	It is only necessary to send a 'continued' event if there was no previous request that implied this.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TExitedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a><exitCode>
	<x path="Int"/>
	<haxe_doc>The exit code returned from the debuggee.</haxe_doc>
</exitCode></a></typedef>
	<typedef path="vscode.debugProtocol.ExitedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TExitedEvent"/></t>
		<haxe_doc>Event message for 'exited' event type.
	The event indicates that the debuggee has exited and returns its exit code.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TTerminatedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a><restart>
	<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a/>
</x></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>A debug adapter may set 'restart' to true (or to an arbitrary object) to request that the front end restarts the session.
		The value is not interpreted by the client and passed unmodified as an attribute '__restart' to the 'launch' and 'attach' requests.</haxe_doc>
</restart></a></typedef>
	<typedef path="vscode.debugProtocol.TerminatedEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TTerminatedEvent"/></t>
		<haxe_doc>Event message for 'terminated' event type.
	The event indicates that debugging of the debuggee has terminated. This does **not** mean that the debuggee itself has exited.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.ThreadEventReason" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.ThreadEventReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Started public="1" get="inline" set="null" expr="cast &quot;started&quot;" line="248" static="1">
		<x path="vscode.debugProtocol.ThreadEventReason"/>
		<meta>
			<m n=":value"><e>cast "started"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Started>
	<Exited public="1" get="inline" set="null" expr="cast &quot;exited&quot;" line="249" static="1">
		<x path="vscode.debugProtocol.ThreadEventReason"/>
		<meta>
			<m n=":value"><e>cast "exited"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Exited>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.ThreadEventReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Started public="1" get="inline" set="null" expr="cast &quot;started&quot;" line="248" static="1">
			<x path="vscode.debugProtocol.ThreadEventReason"/>
			<meta>
				<m n=":value"><e>cast "started"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Started>
		<Exited public="1" get="inline" set="null" expr="cast &quot;exited&quot;" line="249" static="1">
			<x path="vscode.debugProtocol.ThreadEventReason"/>
			<meta>
				<m n=":value"><e>cast "exited"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Exited>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.TThreadEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a>
	<threadId>
		<x path="Int"/>
		<haxe_doc>The identifier of the thread.</haxe_doc>
	</threadId>
	<reason>
		<x path="vscode.debugProtocol.ThreadEventReason"/>
		<haxe_doc>The reason for the event.
		Values: 'started', 'exited', etc.</haxe_doc>
	</reason>
</a></typedef>
	<typedef path="vscode.debugProtocol.ThreadEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TThreadEvent"/></t>
		<haxe_doc>Event message for 'thread' event type.
	The event indicates that a thread has started or exited.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.OutputEventCategory" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.OutputEventCategory_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Console public="1" get="inline" set="null" expr="cast &quot;console&quot;" line="272" static="1">
		<x path="vscode.debugProtocol.OutputEventCategory"/>
		<meta>
			<m n=":value"><e>cast "console"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Console>
	<Stdout public="1" get="inline" set="null" expr="cast &quot;stdout&quot;" line="273" static="1">
		<x path="vscode.debugProtocol.OutputEventCategory"/>
		<meta>
			<m n=":value"><e>cast "stdout"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Stdout>
	<Stderr public="1" get="inline" set="null" expr="cast &quot;stderr&quot;" line="274" static="1">
		<x path="vscode.debugProtocol.OutputEventCategory"/>
		<meta>
			<m n=":value"><e>cast "stderr"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Stderr>
	<Telemetry public="1" get="inline" set="null" expr="cast &quot;telemetry&quot;" line="275" static="1">
		<x path="vscode.debugProtocol.OutputEventCategory"/>
		<meta>
			<m n=":value"><e>cast "telemetry"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Telemetry>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.OutputEventCategory_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Console public="1" get="inline" set="null" expr="cast &quot;console&quot;" line="272" static="1">
			<x path="vscode.debugProtocol.OutputEventCategory"/>
			<meta>
				<m n=":value"><e>cast "console"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Console>
		<Stdout public="1" get="inline" set="null" expr="cast &quot;stdout&quot;" line="273" static="1">
			<x path="vscode.debugProtocol.OutputEventCategory"/>
			<meta>
				<m n=":value"><e>cast "stdout"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Stdout>
		<Stderr public="1" get="inline" set="null" expr="cast &quot;stderr&quot;" line="274" static="1">
			<x path="vscode.debugProtocol.OutputEventCategory"/>
			<meta>
				<m n=":value"><e>cast "stderr"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Stderr>
		<Telemetry public="1" get="inline" set="null" expr="cast &quot;telemetry&quot;" line="275" static="1">
			<x path="vscode.debugProtocol.OutputEventCategory"/>
			<meta>
				<m n=":value"><e>cast "telemetry"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Telemetry>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vscode.debugProtocol.OutputEventGroup" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.OutputEventGroup_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Start public="1" get="inline" set="null" expr="cast &quot;start&quot;" line="283" static="1">
		<x path="vscode.debugProtocol.OutputEventGroup"/>
		<meta>
			<m n=":value"><e>cast "start"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Start a new group in expanded mode. Subsequent output events are members of the group and should be shown indented.
		The 'output' attribute becomes the name of the group and is not indented.</haxe_doc>
	</Start>
	<StartCollapsed public="1" get="inline" set="null" expr="cast &quot;startCollapsed&quot;" line="289" static="1">
		<x path="vscode.debugProtocol.OutputEventGroup"/>
		<meta>
			<m n=":value"><e>cast "startCollapsed"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Start a new group in collapsed mode. Subsequent output events are members of the group and should be shown indented (as soon as the group is expanded).
		The 'output' attribute becomes the name of the group and is not indented.</haxe_doc>
	</StartCollapsed>
	<End public="1" get="inline" set="null" expr="cast &quot;end&quot;" line="295" static="1">
		<x path="vscode.debugProtocol.OutputEventGroup"/>
		<meta>
			<m n=":value"><e>cast "end"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>End the current group and decreases the indentation of subsequent output events.
		A non empty 'output' attribute is shown as the unindented end of the group.</haxe_doc>
	</End>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.OutputEventGroup_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Start public="1" get="inline" set="null" expr="cast &quot;start&quot;" line="283" static="1">
			<x path="vscode.debugProtocol.OutputEventGroup"/>
			<meta>
				<m n=":value"><e>cast "start"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Start a new group in expanded mode. Subsequent output events are members of the group and should be shown indented.
		The 'output' attribute becomes the name of the group and is not indented.</haxe_doc>
		</Start>
		<StartCollapsed public="1" get="inline" set="null" expr="cast &quot;startCollapsed&quot;" line="289" static="1">
			<x path="vscode.debugProtocol.OutputEventGroup"/>
			<meta>
				<m n=":value"><e>cast "startCollapsed"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Start a new group in collapsed mode. Subsequent output events are members of the group and should be shown indented (as soon as the group is expanded).
		The 'output' attribute becomes the name of the group and is not indented.</haxe_doc>
		</StartCollapsed>
		<End public="1" get="inline" set="null" expr="cast &quot;end&quot;" line="295" static="1">
			<x path="vscode.debugProtocol.OutputEventGroup"/>
			<meta>
				<m n=":value"><e>cast "end"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>End the current group and decreases the indentation of subsequent output events.
		A non empty 'output' attribute is shown as the unindented end of the group.</haxe_doc>
		</End>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.TOutputEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a>
	<variablesReference>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc><![CDATA[If an attribute 'variablesReference' exists and its value is > 0, the output contains objects which can be retrieved by passing 'variablesReference' to the 'variables' request.
		The value should be less than or equal to 2147483647 (2^31 - 1).]]></haxe_doc>
	</variablesReference>
	<source>
		<x path="Null"><t path="vscode.debugProtocol.Source"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional source location where the output was produced.</haxe_doc>
	</source>
	<output>
		<c path="String"/>
		<haxe_doc>The output to report.</haxe_doc>
	</output>
	<line>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional source location line where the output was produced.</haxe_doc>
	</line>
	<group>
		<x path="Null"><x path="vscode.debugProtocol.OutputEventGroup"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Support for keeping an output log organized by grouping related messages.</haxe_doc>
	</group>
	<data>
		<d/>
		<haxe_doc>Optional data to report. For the 'telemetry' category the data will be sent to telemetry, for the other categories the data is shown in JSON format.</haxe_doc>
	</data>
	<column>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional source location column where the output was produced.</haxe_doc>
	</column>
	<category>
		<x path="Null"><x path="vscode.debugProtocol.OutputEventCategory"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The output category. If not specified, 'console' is assumed.
		Values: 'console', 'stdout', 'stderr', 'telemetry', etc.</haxe_doc>
	</category>
</a></typedef>
	<typedef path="vscode.debugProtocol.OutputEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TOutputEvent"/></t>
		<haxe_doc>Event message for 'output' event type.
	The event indicates that the target has produced some output.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.BreakpointEventReason" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.BreakpointEventReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Changed public="1" get="inline" set="null" expr="cast &quot;changed&quot;" line="349" static="1">
		<x path="vscode.debugProtocol.BreakpointEventReason"/>
		<meta>
			<m n=":value"><e>cast "changed"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Changed>
	<New public="1" get="inline" set="null" expr="cast &quot;new&quot;" line="350" static="1">
		<x path="vscode.debugProtocol.BreakpointEventReason"/>
		<meta>
			<m n=":value"><e>cast "new"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</New>
	<Removed public="1" get="inline" set="null" expr="cast &quot;removed&quot;" line="351" static="1">
		<x path="vscode.debugProtocol.BreakpointEventReason"/>
		<meta>
			<m n=":value"><e>cast "removed"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Removed>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.BreakpointEventReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Changed public="1" get="inline" set="null" expr="cast &quot;changed&quot;" line="349" static="1">
			<x path="vscode.debugProtocol.BreakpointEventReason"/>
			<meta>
				<m n=":value"><e>cast "changed"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Changed>
		<New public="1" get="inline" set="null" expr="cast &quot;new&quot;" line="350" static="1">
			<x path="vscode.debugProtocol.BreakpointEventReason"/>
			<meta>
				<m n=":value"><e>cast "new"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</New>
		<Removed public="1" get="inline" set="null" expr="cast &quot;removed&quot;" line="351" static="1">
			<x path="vscode.debugProtocol.BreakpointEventReason"/>
			<meta>
				<m n=":value"><e>cast "removed"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Removed>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.TBreakpointEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a>
	<reason>
		<x path="vscode.debugProtocol.BreakpointEventReason"/>
		<haxe_doc>The reason for the event.
		Values: 'changed', 'new', 'removed', etc.</haxe_doc>
	</reason>
	<breakpoint>
		<t path="vscode.debugProtocol.Breakpoint"/>
		<haxe_doc>The 'id' attribute is used to find the target breakpoint and the other attributes are used as the new values.</haxe_doc>
	</breakpoint>
</a></typedef>
	<typedef path="vscode.debugProtocol.BreakpointEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TBreakpointEvent"/></t>
		<haxe_doc>Event message for 'breakpoint' event type.
	The event indicates that some information about a breakpoint has changed.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.ModuleEventReason" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>The reason for the module event.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.ModuleEventReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<New public="1" get="inline" set="null" expr="cast &quot;new&quot;" line="377" static="1">
		<x path="vscode.debugProtocol.ModuleEventReason"/>
		<meta>
			<m n=":value"><e>cast "new"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</New>
	<Changed public="1" get="inline" set="null" expr="cast &quot;changed&quot;" line="378" static="1">
		<x path="vscode.debugProtocol.ModuleEventReason"/>
		<meta>
			<m n=":value"><e>cast "changed"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Changed>
	<Removed public="1" get="inline" set="null" expr="cast &quot;removed&quot;" line="379" static="1">
		<x path="vscode.debugProtocol.ModuleEventReason"/>
		<meta>
			<m n=":value"><e>cast "removed"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Removed>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.ModuleEventReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<New public="1" get="inline" set="null" expr="cast &quot;new&quot;" line="377" static="1">
			<x path="vscode.debugProtocol.ModuleEventReason"/>
			<meta>
				<m n=":value"><e>cast "new"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</New>
		<Changed public="1" get="inline" set="null" expr="cast &quot;changed&quot;" line="378" static="1">
			<x path="vscode.debugProtocol.ModuleEventReason"/>
			<meta>
				<m n=":value"><e>cast "changed"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Changed>
		<Removed public="1" get="inline" set="null" expr="cast &quot;removed&quot;" line="379" static="1">
			<x path="vscode.debugProtocol.ModuleEventReason"/>
			<meta>
				<m n=":value"><e>cast "removed"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Removed>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.TModuleEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a>
	<reason>
		<x path="vscode.debugProtocol.ModuleEventReason"/>
		<haxe_doc>The reason for the event.</haxe_doc>
	</reason>
	<module>
		<t path="vscode.debugProtocol.Module"/>
		<haxe_doc>The new, changed, or removed module. In case of 'removed' only the module id is used.</haxe_doc>
	</module>
</a></typedef>
	<typedef path="vscode.debugProtocol.ModuleEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TModuleEvent"/></t>
		<haxe_doc>Event message for 'module' event type.
	The event indicates that some information about a module has changed.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.LoadedSourceEventReason" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.LoadedSourceEventReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<New public="1" get="inline" set="null" expr="cast &quot;new&quot;" line="401" static="1">
		<x path="vscode.debugProtocol.LoadedSourceEventReason"/>
		<meta>
			<m n=":value"><e>cast "new"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</New>
	<Changed public="1" get="inline" set="null" expr="cast &quot;changed&quot;" line="402" static="1">
		<x path="vscode.debugProtocol.LoadedSourceEventReason"/>
		<meta>
			<m n=":value"><e>cast "changed"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Changed>
	<Removed public="1" get="inline" set="null" expr="cast &quot;removed&quot;" line="403" static="1">
		<x path="vscode.debugProtocol.LoadedSourceEventReason"/>
		<meta>
			<m n=":value"><e>cast "removed"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Removed>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.LoadedSourceEventReason_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<New public="1" get="inline" set="null" expr="cast &quot;new&quot;" line="401" static="1">
			<x path="vscode.debugProtocol.LoadedSourceEventReason"/>
			<meta>
				<m n=":value"><e>cast "new"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</New>
		<Changed public="1" get="inline" set="null" expr="cast &quot;changed&quot;" line="402" static="1">
			<x path="vscode.debugProtocol.LoadedSourceEventReason"/>
			<meta>
				<m n=":value"><e>cast "changed"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Changed>
		<Removed public="1" get="inline" set="null" expr="cast &quot;removed&quot;" line="403" static="1">
			<x path="vscode.debugProtocol.LoadedSourceEventReason"/>
			<meta>
				<m n=":value"><e>cast "removed"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Removed>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.TLoadedSourceEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a>
	<source>
		<t path="vscode.debugProtocol.Source"/>
		<haxe_doc>The new, changed, or removed source.</haxe_doc>
	</source>
	<reason>
		<x path="vscode.debugProtocol.LoadedSourceEventReason"/>
		<haxe_doc>The reason for the event.</haxe_doc>
	</reason>
</a></typedef>
	<typedef path="vscode.debugProtocol.LoadedSourceEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TLoadedSourceEvent"/></t>
		<haxe_doc>Event message for 'loadedSource' event type.
	The event indicates that some source has been added, changed, or removed from the set of all loaded sources.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.ProcessEventStartMethod" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.ProcessEventStartMethod_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Launch public="1" get="inline" set="null" expr="cast &quot;launch&quot;" line="428" static="1">
		<x path="vscode.debugProtocol.ProcessEventStartMethod"/>
		<meta>
			<m n=":value"><e>cast "launch"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Process was launched under the debugger.</haxe_doc>
	</Launch>
	<Attach public="1" get="inline" set="null" expr="cast &quot;attach&quot;" line="433" static="1">
		<x path="vscode.debugProtocol.ProcessEventStartMethod"/>
		<meta>
			<m n=":value"><e>cast "attach"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Debugger attached to an existing process.</haxe_doc>
	</Attach>
	<AttachForSuspendedLaunch public="1" get="inline" set="null" expr="cast &quot;attachForSuspendedLaunch&quot;" line="438" static="1">
		<x path="vscode.debugProtocol.ProcessEventStartMethod"/>
		<meta>
			<m n=":value"><e>cast "attachForSuspendedLaunch"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>A project launcher component has launched a new process in a suspended state and then asked the debugger to attach.</haxe_doc>
	</AttachForSuspendedLaunch>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.ProcessEventStartMethod_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Launch public="1" get="inline" set="null" expr="cast &quot;launch&quot;" line="428" static="1">
			<x path="vscode.debugProtocol.ProcessEventStartMethod"/>
			<meta>
				<m n=":value"><e>cast "launch"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Process was launched under the debugger.</haxe_doc>
		</Launch>
		<Attach public="1" get="inline" set="null" expr="cast &quot;attach&quot;" line="433" static="1">
			<x path="vscode.debugProtocol.ProcessEventStartMethod"/>
			<meta>
				<m n=":value"><e>cast "attach"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Debugger attached to an existing process.</haxe_doc>
		</Attach>
		<AttachForSuspendedLaunch public="1" get="inline" set="null" expr="cast &quot;attachForSuspendedLaunch&quot;" line="438" static="1">
			<x path="vscode.debugProtocol.ProcessEventStartMethod"/>
			<meta>
				<m n=":value"><e>cast "attachForSuspendedLaunch"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>A project launcher component has launched a new process in a suspended state and then asked the debugger to attach.</haxe_doc>
		</AttachForSuspendedLaunch>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.TProcessEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a>
	<systemProcessId>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The system process id of the debugged process. This property will be missing for non-system processes.</haxe_doc>
	</systemProcessId>
	<startMethod>
		<x path="Null"><x path="vscode.debugProtocol.ProcessEventStartMethod"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Describes how the debug engine started debugging this process.</haxe_doc>
	</startMethod>
	<pointerSize>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The size of a pointer or address for this process, in bits. This value may be used by clients when formatting addresses for display.</haxe_doc>
	</pointerSize>
	<name>
		<c path="String"/>
		<haxe_doc>The logical name of the process. This is usually the full path to process's executable file. Example: /home/example/myproj/program.js.</haxe_doc>
	</name>
	<isLocalProcess>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>If true, the process is running on the same computer as the debug adapter.</haxe_doc>
	</isLocalProcess>
</a></typedef>
	<typedef path="vscode.debugProtocol.ProcessEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TProcessEvent"/></t>
		<haxe_doc>Event message for 'process' event type.
	The event indicates that the debugger has begun debugging a new process. Either one that it has launched, or one that it has attached to.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TCapabilitiesEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol"><a><capabilities>
	<t path="vscode.debugProtocol.Capabilities"/>
	<haxe_doc>The set of updated capabilities.</haxe_doc>
</capabilities></a></typedef>
	<typedef path="vscode.debugProtocol.CapabilitiesEvent" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Event"><t path="vscode.debugProtocol.TCapabilitiesEvent"/></t>
		<haxe_doc>Event message for 'capabilities' event type.
	The event indicates that one or more capabilities have changed.
	Since the capabilities are dependent on the frontend and its UI, it might not be possible to change that at random times (or too late).
	Consequently this event has a hint characteristic: a frontend can only be expected to make a 'best effort' in honouring individual capabilities but there are no guarantees.
	Only changed capabilities need to be included, all other capabilities keep their values.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.RunInTerminalRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.RunInTerminalRequestArguments"/></t>
		<haxe_doc>RunInTerminal request; value of command field is 'runInTerminal'.
	This request is sent from the debug adapter to the client to run a command in a terminal. This is typically used to launch the debuggee in a terminal provided by the client.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.RunInTerminalRequestArgumentsKind" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.RunInTerminalRequestArgumentsKind_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Integrated public="1" get="inline" set="null" expr="cast &quot;integrated&quot;" line="497" static="1">
		<x path="vscode.debugProtocol.RunInTerminalRequestArgumentsKind"/>
		<meta>
			<m n=":value"><e>cast "integrated"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Integrated>
	<External public="1" get="inline" set="null" expr="cast &quot;external&quot;" line="498" static="1">
		<x path="vscode.debugProtocol.RunInTerminalRequestArgumentsKind"/>
		<meta>
			<m n=":value"><e>cast "external"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</External>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.RunInTerminalRequestArgumentsKind_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Integrated public="1" get="inline" set="null" expr="cast &quot;integrated&quot;" line="497" static="1">
			<x path="vscode.debugProtocol.RunInTerminalRequestArgumentsKind"/>
			<meta>
				<m n=":value"><e>cast "integrated"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Integrated>
		<External public="1" get="inline" set="null" expr="cast &quot;external&quot;" line="498" static="1">
			<x path="vscode.debugProtocol.RunInTerminalRequestArgumentsKind"/>
			<meta>
				<m n=":value"><e>cast "external"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</External>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.RunInTerminalRequestArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<title>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional title of the terminal.</haxe_doc>
			</title>
			<kind>
				<x path="Null"><x path="vscode.debugProtocol.RunInTerminalRequestArgumentsKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>What kind of terminal to launch.</haxe_doc>
			</kind>
			<env>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Environment key-value pairs that are added to the default environment.</haxe_doc>
			</env>
			<cwd>
				<c path="String"/>
				<haxe_doc>Working directory of the command.</haxe_doc>
			</cwd>
			<args>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>List of arguments. The first argument is the command to run.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Arguments for 'runInTerminal' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.RunInTerminalResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<shellProcessId>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The process ID of the terminal shell. The value should be less than or equal to 2147483647 (2^31 - 1).</haxe_doc>
	</shellProcessId>
	<processId>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The process ID. The value should be less than or equal to 2147483647 (2^31 - 1).</haxe_doc>
	</processId>
</a></t>
		<haxe_doc>Response to Initialize request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.InitializeRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.InitializeRequestArguments"/></t>
		<haxe_doc>Initialize request; value of command field is 'initialize'.
	The 'initialize' request is sent as the first request from the client to the debug adapter in order to configure it with client capabilities and to retrieve capabilities from the debug adapter.
	Until the debug adapter has responded to with an 'initialize' response, the client must not send any additional requests or events to the debug adapter. In addition the debug adapter is not allowed to send any requests or events to the client until it has responded with an 'initialize' response.
	The 'initialize' request may only be sent once.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.InitializeRequestArgumentsPathFormat" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.InitializeRequestArgumentsPathFormat_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Path public="1" get="inline" set="null" expr="cast &quot;path&quot;" line="555" static="1">
		<x path="vscode.debugProtocol.InitializeRequestArgumentsPathFormat"/>
		<meta>
			<m n=":value"><e>cast "path"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Path>
	<Uri public="1" get="inline" set="null" expr="cast &quot;uri&quot;" line="556" static="1">
		<x path="vscode.debugProtocol.InitializeRequestArgumentsPathFormat"/>
		<meta>
			<m n=":value"><e>cast "uri"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uri>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.InitializeRequestArgumentsPathFormat_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Path public="1" get="inline" set="null" expr="cast &quot;path&quot;" line="555" static="1">
			<x path="vscode.debugProtocol.InitializeRequestArgumentsPathFormat"/>
			<meta>
				<m n=":value"><e>cast "path"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Path>
		<Uri public="1" get="inline" set="null" expr="cast &quot;uri&quot;" line="556" static="1">
			<x path="vscode.debugProtocol.InitializeRequestArgumentsPathFormat"/>
			<meta>
				<m n=":value"><e>cast "uri"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uri>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.InitializeRequestArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<supportsVariableType>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client supports the optional type attribute for variables.</haxe_doc>
			</supportsVariableType>
			<supportsVariablePaging>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client supports the paging of variables.</haxe_doc>
			</supportsVariablePaging>
			<supportsRunInTerminalRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client supports the runInTerminal request.</haxe_doc>
			</supportsRunInTerminalRequest>
			<supportsMemoryReferences>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client supports memory references.</haxe_doc>
			</supportsMemoryReferences>
			<supportsBreakpointLocationsRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'breakpointLocations' request.</haxe_doc>
			</supportsBreakpointLocationsRequest>
			<pathFormat>
				<x path="Null"><x path="vscode.debugProtocol.InitializeRequestArgumentsPathFormat"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Determines in what format paths are specified. The default is 'path', which is the native format.
		Values: 'path', 'uri', etc.</haxe_doc>
			</pathFormat>
			<locale>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The ISO-639 locale of the (frontend) client using this adapter, e.g. en-US or de-CH.</haxe_doc>
			</locale>
			<linesStartAt1>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If true all line numbers are 1-based (default).</haxe_doc>
			</linesStartAt1>
			<columnsStartAt1>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If true all column numbers are 1-based (default).</haxe_doc>
			</columnsStartAt1>
			<clientName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The human readable name of the (frontend) client using this adapter.</haxe_doc>
			</clientName>
			<clientID>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The ID of the (frontend) client using this adapter.</haxe_doc>
			</clientID>
			<adapterID>
				<c path="String"/>
				<haxe_doc>The ID of the debug adapter.</haxe_doc>
			</adapterID>
		</a>
		<haxe_doc>Arguments for 'initialize' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.InitializeResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><t path="vscode.debugProtocol.Capabilities"/></t>
		<haxe_doc>Response to 'initialize' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ConfigurationDoneRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.ConfigurationDoneArguments"/></t>
		<haxe_doc>ConfigurationDone request; value of command field is 'configurationDone'.
	The client of the debug protocol must send this request at the end of the sequence of configuration requests (which was started by the 'initialized' event).</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ConfigurationDoneArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a/>
		<haxe_doc>Arguments for 'configurationDone' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ConfigurationDoneResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'configurationDone' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.LaunchRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.LaunchRequestArguments"/></t>
		<haxe_doc>Launch request; value of command field is 'launch'.
	The launch request is sent from the client to the debug adapter to start the debuggee with or without debugging (if 'noDebug' is true). Since launching is debugger/runtime specific, the arguments for this request are not part of this specification.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.LaunchRequestArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<noDebug>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If noDebug is true the launch request should launch the program without enabling debugging.</haxe_doc>
			</noDebug>
			<__restart>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional data from the previous, restarted session.
		The data is sent as the 'restart' attribute of the 'terminated' event.
		The client should leave the data intact.</haxe_doc>
			</__restart>
		</a>
		<haxe_doc>Arguments for 'launch' request. Additional attributes are implementation specific.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.LaunchResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'launch' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.AttachRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.AttachRequestArguments"/></t>
		<haxe_doc>Attach request; value of command field is 'attach'.
	The attach request is sent from the client to the debug adapter to attach to a debuggee that is already running. Since attaching is debugger/runtime specific, the arguments for this request are not part of this specification.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.AttachRequestArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><__restart>
	<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a/>
</x></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Optional data from the previous, restarted session.
		The data is sent as the 'restart' attribute of the 'terminated' event.
		The client should leave the data intact.</haxe_doc>
</__restart></a>
		<haxe_doc>Arguments for 'attach' request. Additional attributes are implementation specific.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.AttachResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'attach' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.RestartRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.RestartArguments"/></t>
		<haxe_doc>Restart request; value of command field is 'restart'.
	Restarts a debug session. If the capability 'supportsRestartRequest' is missing or has the value false,
	the client will implement 'restart' by terminating the debug adapter first and then launching it anew.
	A debug adapter can override this default behaviour by implementing a restart request
	and setting the capability 'supportsRestartRequest' to true.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.RestartArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a/>
		<haxe_doc>Arguments for 'restart' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.RestartResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'restart' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DisconnectRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.DisconnectArguments"/></t>
		<haxe_doc>Disconnect request; value of command field is 'disconnect'.
	The 'disconnect' request is sent from the client to the debug adapter in order to stop debugging. It asks the debug adapter to disconnect from the debuggee and to terminate the debug adapter. If the debuggee has been started with the 'launch' request, the 'disconnect' request terminates the debuggee. If the 'attach' request was used to connect to the debuggee, 'disconnect' does not terminate the debuggee. This behavior can be controlled with the 'terminateDebuggee' argument (if supported by the debug adapter).</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DisconnectArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<terminateDebuggee>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Indicates whether the debuggee should be terminated when the debugger is disconnected.
		If unspecified, the debug adapter is free to do whatever it thinks is best.
		A client can only rely on this attribute being properly honored if a debug adapter returns true for the 'supportTerminateDebuggee' capability.</haxe_doc>
			</terminateDebuggee>
			<restart>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A value of true indicates that this 'disconnect' request is part of a restart sequence.</haxe_doc>
			</restart>
		</a>
		<haxe_doc>Arguments for 'disconnect' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DisconnectResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'disconnect' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TerminateRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.TerminateArguments"/></t>
		<haxe_doc>Terminate request; value of command field is 'terminate'.
	The 'terminate' request is sent from the client to the debug adapter in order to give the debuggee a chance for terminating itself.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TerminateArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><restart>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>A value of true indicates that this 'terminate' request is part of a restart sequence.</haxe_doc>
</restart></a>
		<haxe_doc>Arguments for 'terminate' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TerminateResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'terminate' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.BreakpointLocationsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.BreakpointLocationsArguments"/></t>
		<haxe_doc>BreakpointLocations request; value of command field is 'breakpointLocations'.
	The 'breakpointLocations' request returns all possible locations for source breakpoints in a given range.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.BreakpointLocationsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<source>
				<t path="vscode.debugProtocol.Source"/>
				<haxe_doc>The source location of the breakpoints; either 'source.path' or 'source.reference' must be specified.</haxe_doc>
			</source>
			<line>
				<x path="Int"/>
				<haxe_doc>Start line of range to search possible breakpoint locations in. If only the line is specified, the request returns all possible locations in that line.</haxe_doc>
			</line>
			<endLine>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional end line of range to search possible breakpoint locations in. If no end line is given, then the end line is assumed to be the start line.</haxe_doc>
			</endLine>
			<endColumn>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional end column of range to search possible breakpoint locations in. If no end column is given, then it is assumed to be in the last column of the end line.</haxe_doc>
			</endColumn>
			<column>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional start column of range to search possible breakpoint locations in. If no start column is given, the first column in the start line is assumed.</haxe_doc>
			</column>
		</a>
		<haxe_doc>Arguments for 'breakpointLocations' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.BreakpointLocationsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><breakpoints>
	<c path="Array"><t path="vscode.debugProtocol.BreakpointLocation"/></c>
	<haxe_doc>Sorted set of possible breakpoint locations.</haxe_doc>
</breakpoints></a></t>
		<haxe_doc>Response to 'breakpointLocations' request.
	Contains possible locations for source breakpoints.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetBreakpointsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.SetBreakpointsArguments"/></t>
		<haxe_doc>SetBreakpoints request; value of command field is 'setBreakpoints'.
	Sets multiple breakpoints for a single source and clears all previous breakpoints in that source.
	To clear all breakpoint for a source, specify an empty array.
	When a breakpoint is hit, a 'stopped' event (with reason 'breakpoint') is generated.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetBreakpointsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<sourceModified>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A value of true indicates that the underlying source has been modified which results in new breakpoint locations.</haxe_doc>
			</sourceModified>
			<source>
				<t path="vscode.debugProtocol.Source"/>
				<haxe_doc>The source location of the breakpoints; either 'source.path' or 'source.reference' must be specified.</haxe_doc>
			</source>
			<lines>
				<x path="Null"><c path="Array"><x path="Int"/></c></x>
				<meta>
					<m n=":optional"/>
					<m n=":deprecated"/>
				</meta>
				<haxe_doc>Deprecated: The code locations of the breakpoints.</haxe_doc>
			</lines>
			<breakpoints>
				<x path="Null"><c path="Array"><t path="vscode.debugProtocol.SourceBreakpoint"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The code locations of the breakpoints.</haxe_doc>
			</breakpoints>
		</a>
		<haxe_doc>Arguments for "setBreakpoints" request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetBreakpointsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><breakpoints>
	<c path="Array"><t path="vscode.debugProtocol.Breakpoint"/></c>
	<haxe_doc>Information about the breakpoints. The array elements are in the same order as the elements of the 'breakpoints' (or the deprecated 'lines') array in the arguments.</haxe_doc>
</breakpoints></a></t>
		<haxe_doc>Response to 'setBreakpoints' request.
	Returned is information about each breakpoint created by this request.
	This includes the actual code location and whether the breakpoint could be verified.
	The breakpoints returned are in the same order as the elements of the 'breakpoints'
	(or the deprecated 'lines') array in the arguments.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetFunctionBreakpointsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.SetFunctionBreakpointsArguments"/></t>
		<haxe_doc>SetFunctionBreakpoints request; value of command field is 'setFunctionBreakpoints'.
	Replaces all existing function breakpoints with new function breakpoints.
	To clear all function breakpoints, specify an empty array.
	When a function breakpoint is hit, a 'stopped' event (with reason 'function breakpoint') is generated.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetFunctionBreakpointsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><breakpoints>
	<c path="Array"><t path="vscode.debugProtocol.FunctionBreakpoint"/></c>
	<haxe_doc>The function names of the breakpoints.</haxe_doc>
</breakpoints></a>
		<haxe_doc>Arguments for 'setFunctionBreakpoints' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetFunctionBreakpointsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><breakpoints>
	<c path="Array"><t path="vscode.debugProtocol.Breakpoint"/></c>
	<haxe_doc>Information about the breakpoints. The array elements correspond to the elements of the 'breakpoints' array.</haxe_doc>
</breakpoints></a></t>
		<haxe_doc>Response to 'setFunctionBreakpoints' request.
	Returned is information about each breakpoint created by this request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetExceptionBreakpointsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.SetExceptionBreakpointsArguments"/></t>
		<haxe_doc>SetExceptionBreakpoints request; value of command field is 'setExceptionBreakpoints'.
	The request configures the debuggers response to thrown exceptions. If an exception is configured to break, a 'stopped' event is fired (with reason 'exception').</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetExceptionBreakpointsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<filters>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>IDs of checked exception options. The set of IDs is returned via the 'exceptionBreakpointFilters' capability.</haxe_doc>
			</filters>
			<exceptionOptions>
				<x path="Null"><c path="Array"><t path="vscode.debugProtocol.ExceptionOptions"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Configuration options for selected exceptions.</haxe_doc>
			</exceptionOptions>
		</a>
		<haxe_doc>Arguments for 'setExceptionBreakpoints' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetExceptionBreakpointsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'setExceptionBreakpoints' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DataBreakpointInfoRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.DataBreakpointInfoArguments"/></t>
		<haxe_doc>DataBreakpointInfo request; value of command field is 'dataBreakpointInfo'.
	Obtains information on a possible data breakpoint that could be set on an expression or variable.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DataBreakpointInfoArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<variablesReference>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Reference to the Variable container if the data breakpoint is requested for a child of the container.</haxe_doc>
			</variablesReference>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the Variable's child to obtain data breakpoint information for. If variableReference isnt provided, this can be an expression.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Arguments for 'dataBreakpointInfo' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DataBreakpointInfoResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<description>
		<c path="String"/>
		<haxe_doc>UI string that describes on what data the breakpoint is set on or why a data breakpoint is not available.</haxe_doc>
	</description>
	<dataId>
		<x path="Null"><c path="String"/></x>
		<haxe_doc>An identifier for the data on which a data breakpoint can be registered with the setDataBreakpoints request or null if no data breakpoint is available.</haxe_doc>
	</dataId>
	<canPersist>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Optional attribute indicating that a potential data breakpoint could be persisted across sessions.</haxe_doc>
	</canPersist>
	<accessTypes>
		<x path="Null"><c path="Array"><x path="vscode.debugProtocol.DataBreakpointAccessType"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Optional attribute listing the available access types for a potential data breakpoint. A UI frontend could surface this information.</haxe_doc>
	</accessTypes>
</a></t>
		<haxe_doc>Response to 'dataBreakpointInfo' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetDataBreakpointsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.SetDataBreakpointsArguments"/></t>
		<haxe_doc>SetDataBreakpoints request; value of command field is 'setDataBreakpoints'.
	Replaces all existing data breakpoints with new data breakpoints.
	To clear all data breakpoints, specify an empty array.
	When a data breakpoint is hit, a 'stopped' event (with reason 'data breakpoint') is generated.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetDataBreakpointsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><breakpoints>
	<c path="Array"><t path="vscode.debugProtocol.DataBreakpoint"/></c>
	<haxe_doc>The contents of this array replaces all existing data breakpoints. An empty array clears all data breakpoints.</haxe_doc>
</breakpoints></a>
		<haxe_doc>Arguments for 'setDataBreakpoints' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetDataBreakpointsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><breakpoints>
	<c path="Array"><t path="vscode.debugProtocol.Breakpoint"/></c>
	<haxe_doc>Information about the data breakpoints. The array elements correspond to the elements of the input argument 'breakpoints' array.</haxe_doc>
</breakpoints></a></t>
		<haxe_doc>Response to 'setDataBreakpoints' request.
	Returned is information about each breakpoint created by this request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ContinueRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.ContinueArguments"/></t>
		<haxe_doc>Continue request; value of command field is 'continue'.
	The request starts the debuggee to run again.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ContinueArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><threadId>
	<x path="Int"/>
	<haxe_doc>Continue execution for the specified thread (if possible). If the backend cannot continue on a single thread but will continue on all threads, it should set the 'allThreadsContinued' attribute in the response to true.</haxe_doc>
</threadId></a>
		<haxe_doc>Arguments for 'continue' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ContinueResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><allThreadsContinued>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>If true, the 'continue' request has ignored the specified thread and continued all threads instead. If this attribute is missing a value of 'true' is assumed for backward compatibility.</haxe_doc>
</allThreadsContinued></a></t>
		<haxe_doc>Response to 'continue' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.NextRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.NextArguments"/></t>
		<haxe_doc>Next request; value of command field is 'next'.
	The request starts the debuggee to run again for one step.
	The debug adapter first sends the response and then a 'stopped' event (with reason 'step') after the step has completed.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.NextArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><threadId>
	<x path="Int"/>
	<haxe_doc>Execute 'next' for this thread.</haxe_doc>
</threadId></a>
		<haxe_doc>Arguments for 'next' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.NextResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'next' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepInRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.StepInArguments"/></t>
		<haxe_doc>StepIn request; value of command field is 'stepIn'.
	The request starts the debuggee to step into a function/method if possible.
	If it cannot step into a target, 'stepIn' behaves like 'next'.
	The debug adapter first sends the response and then a 'stopped' event (with reason 'step') after the step has completed.
	If there are multiple function/method calls (or other targets) on the source line,
	the optional argument 'targetId' can be used to control into which target the 'stepIn' should occur.
	The list of possible targets for a given source line can be retrieved via the 'stepInTargets' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepInArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<threadId>
				<x path="Int"/>
				<haxe_doc>Execute 'stepIn' for this thread.</haxe_doc>
			</threadId>
			<targetId>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional id of the target to step into.</haxe_doc>
			</targetId>
		</a>
		<haxe_doc>Arguments for 'stepIn' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepInResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'stepIn' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepOutRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.StepOutArguments"/></t>
		<haxe_doc>StepOut request; value of command field is 'stepOut'.
	The request starts the debuggee to run again for one step.
	The debug adapter first sends the response and then a 'stopped' event (with reason 'step') after the step has completed.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepOutArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><threadId>
	<x path="Int"/>
	<haxe_doc>Execute 'stepOut' for this thread.</haxe_doc>
</threadId></a>
		<haxe_doc>Arguments for 'stepOut' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepOutResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'stepOut' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepBackRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.StepBackArguments"/></t>
		<haxe_doc>StepBack request; value of command field is 'stepBack'.
	The request starts the debuggee to run one step backwards.
	The debug adapter first sends the response and then a 'stopped' event (with reason 'step') after the step has completed. Clients should only call this request if the capability 'supportsStepBack' is true.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepBackArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><threadId>
	<x path="Int"/>
	<haxe_doc>Execute 'stepBack' for this thread.</haxe_doc>
</threadId></a>
		<haxe_doc>Arguments for 'stepBack' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepBackResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'stepBack' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ReverseContinueRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.ReverseContinueArguments"/></t>
		<haxe_doc>ReverseContinue request; value of command field is 'reverseContinue'.
	The request starts the debuggee to run backward. Clients should only call this request if the capability 'supportsStepBack' is true.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ReverseContinueArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><threadId>
	<x path="Int"/>
	<haxe_doc>Execute 'reverseContinue' for this thread.</haxe_doc>
</threadId></a>
		<haxe_doc>Arguments for 'reverseContinue' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ReverseContinueResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'reverseContinue' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.RestartFrameRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.RestartFrameArguments"/></t>
		<haxe_doc>RestartFrame request; value of command field is 'restartFrame'.
	The request restarts execution of the specified stackframe.
	The debug adapter first sends the response and then a 'stopped' event (with reason 'restart') after the restart has completed.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.RestartFrameArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><frameId>
	<x path="Int"/>
	<haxe_doc>Restart this stackframe.</haxe_doc>
</frameId></a>
		<haxe_doc>Arguments for 'restartFrame' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.RestartFrameResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'restartFrame' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.GotoRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.GotoArguments"/></t>
		<haxe_doc>Goto request; value of command field is 'goto'.
	The request sets the location where the debuggee will continue to run.
	This makes it possible to skip the execution of code or to executed code again.
	The code between the current location and the goto target is not executed but skipped.
	The debug adapter first sends the response and then a 'stopped' event with reason 'goto'.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.GotoArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<threadId>
				<x path="Int"/>
				<haxe_doc>Set the goto target for this thread.</haxe_doc>
			</threadId>
			<targetId>
				<x path="Int"/>
				<haxe_doc>The location where the debuggee will continue to run.</haxe_doc>
			</targetId>
		</a>
		<haxe_doc>Arguments for 'goto' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.GotoResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'goto' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.PauseRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.PauseArguments"/></t>
		<haxe_doc>Pause request; value of command field is 'pause'.
	The request suspends the debuggee.
	The debug adapter first sends the response and then a 'stopped' event (with reason 'pause') after the thread has been paused successfully.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.PauseArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><threadId><x path="Int"/></threadId></a>
		<haxe_doc>Arguments for 'pause' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.PauseResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'pause' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StackTraceRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.StackTraceArguments"/></t>
		<haxe_doc>StackTrace request; value of command field is 'stackTrace'.
	The request returns a stacktrace from the current execution state.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StackTraceArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<threadId>
				<x path="Int"/>
				<haxe_doc>Retrieve the stacktrace for this thread.</haxe_doc>
			</threadId>
			<startFrame>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The index of the first frame to return; if omitted frames start at 0.</haxe_doc>
			</startFrame>
			<levels>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The maximum number of frames to return. If levels is not specified or 0, all frames are returned.</haxe_doc>
			</levels>
			<format>
				<x path="Null"><t path="vscode.debugProtocol.StackFrameFormat"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies details on how to format the stack frames.</haxe_doc>
			</format>
		</a>
		<haxe_doc>Arguments for 'stackTrace' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StackTraceResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<totalFrames>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The total number of frames available.</haxe_doc>
	</totalFrames>
	<stackFrames>
		<c path="Array"><t path="vscode.debugProtocol.StackFrame"/></c>
		<haxe_doc>The frames of the stackframe. If the array has length zero, there are no stackframes available.
		This means that there is no location information available.</haxe_doc>
	</stackFrames>
</a></t>
		<haxe_doc>Response to 'stackTrace' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ScopesRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.ScopesArguments"/></t>
		<haxe_doc>Scopes request; value of command field is 'scopes'.
	The request returns the variable scopes for a given stackframe ID.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ScopesArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><frameId>
	<x path="Int"/>
	<haxe_doc>Retrieve the scopes for this stackframe.</haxe_doc>
</frameId></a>
		<haxe_doc>Arguments for 'scopes' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ScopesResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><scopes>
	<c path="Array"><t path="vscode.debugProtocol.Scope"/></c>
	<haxe_doc>The scopes of the stackframe. If the array has length zero, there are no scopes available.</haxe_doc>
</scopes></a></t>
		<haxe_doc>Response to 'scopes' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.VariablesRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.VariablesArguments"/></t>
		<haxe_doc>Variables request; value of command field is 'variables'.
	Retrieves all child variables for the given variable reference.
	An optional filter can be used to limit the fetched children to either named or indexed children.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.VariableArgumentsFilter" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.VariableArgumentsFilter_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Indexed public="1" get="inline" set="null" expr="cast &quot;indexed&quot;" line="1285" static="1">
		<x path="vscode.debugProtocol.VariableArgumentsFilter"/>
		<meta>
			<m n=":value"><e>cast "indexed"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Indexed>
	<Named public="1" get="inline" set="null" expr="cast &quot;named&quot;" line="1286" static="1">
		<x path="vscode.debugProtocol.VariableArgumentsFilter"/>
		<meta>
			<m n=":value"><e>cast "named"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Named>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.VariableArgumentsFilter_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Indexed public="1" get="inline" set="null" expr="cast &quot;indexed&quot;" line="1285" static="1">
			<x path="vscode.debugProtocol.VariableArgumentsFilter"/>
			<meta>
				<m n=":value"><e>cast "indexed"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Indexed>
		<Named public="1" get="inline" set="null" expr="cast &quot;named&quot;" line="1286" static="1">
			<x path="vscode.debugProtocol.VariableArgumentsFilter"/>
			<meta>
				<m n=":value"><e>cast "named"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Named>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.VariablesArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<variablesReference>
				<x path="Int"/>
				<haxe_doc>The Variable reference.</haxe_doc>
			</variablesReference>
			<start>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The index of the first variable to return; if omitted children start at 0.</haxe_doc>
			</start>
			<format>
				<x path="Null"><t path="vscode.debugProtocol.ValueFormat"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies details on how to format the Variable values.</haxe_doc>
			</format>
			<filter>
				<x path="Null"><x path="vscode.debugProtocol.VariableArgumentsFilter"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional filter to limit the child variables to either named or indexed. If ommited, both types are fetched.</haxe_doc>
			</filter>
			<count>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The number of variables to return. If count is missing or 0, all variables are returned.</haxe_doc>
			</count>
		</a>
		<haxe_doc>Arguments for 'variables' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.VariablesResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><variables>
	<c path="Array"><t path="vscode.debugProtocol.Variable"/></c>
	<haxe_doc>All (or a range) of variables for the given variable reference.</haxe_doc>
</variables></a></t>
		<haxe_doc>Response to 'variables' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetVariableRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.SetVariableArguments"/></t>
		<haxe_doc>SetVariable request; value of command field is 'setVariable'.
	Set the variable with the given name in the variable container to a new value.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetVariableArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<variablesReference>
				<x path="Int"/>
				<haxe_doc>The reference of the variable container.</haxe_doc>
			</variablesReference>
			<value>
				<c path="String"/>
				<haxe_doc>The value of the variable.</haxe_doc>
			</value>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<format>
				<x path="Null"><t path="vscode.debugProtocol.ValueFormat"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies details on how to format the response value.</haxe_doc>
			</format>
		</a>
		<haxe_doc>Arguments for 'setVariable' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetVariableResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<variablesReference>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc><![CDATA[If variablesReference is > 0, the new value is structured and its children can be retrieved by passing variablesReference to the VariablesRequest.
		The value should be less than or equal to 2147483647 (2^31 - 1).]]></haxe_doc>
	</variablesReference>
	<value>
		<c path="String"/>
		<haxe_doc>The new value of the variable.</haxe_doc>
	</value>
	<type>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The type of the new value. Typically shown in the UI when hovering over the value.</haxe_doc>
	</type>
	<namedVariables>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The number of named child variables.
		The client can use this optional information to present the variables in a paged UI and fetch them in chunks. The value should be less than or equal to 2147483647 (2^31 - 1).</haxe_doc>
	</namedVariables>
	<indexedVariables>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The number of indexed child variables.
		The client can use this optional information to present the variables in a paged UI and fetch them in chunks. The value should be less than or equal to 2147483647 (2^31 - 1).</haxe_doc>
	</indexedVariables>
</a></t>
		<haxe_doc>Response to 'setVariable' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SourceRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.SourceArguments"/></t>
		<haxe_doc>Source request; value of command field is 'source'.
	The request retrieves the source code for a given source reference.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SourceArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<sourceReference>
				<x path="Int"/>
				<haxe_doc>The reference to the source. This is the same as source.sourceReference. This is provided for backward compatibility since old backends do not understand the 'source' attribute.</haxe_doc>
			</sourceReference>
			<source>
				<x path="Null"><t path="vscode.debugProtocol.Source"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies the source content to load. Either source.path or source.sourceReference must be specified.</haxe_doc>
			</source>
		</a>
		<haxe_doc>Arguments for 'source' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SourceResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<mimeType>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Optional content type (mime type) of the source.</haxe_doc>
	</mimeType>
	<content>
		<c path="String"/>
		<haxe_doc>Content of the source reference.</haxe_doc>
	</content>
</a></t>
		<haxe_doc>Response to 'source' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ThreadsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><a/></t>
		<haxe_doc>Threads request; value of command field is 'threads'.
	The request retrieves a list of all threads.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ThreadsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><threads>
	<c path="Array"><t path="vscode.debugProtocol.Thread"/></c>
	<haxe_doc>All threads.</haxe_doc>
</threads></a></t>
		<haxe_doc>Response to 'threads' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TerminateThreadsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.TerminateThreadsArguments"/></t>
		<haxe_doc>TerminateThreads request; value of command field is 'terminateThreads'.
	The request terminates the threads with the given ids.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TerminateThreadsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><threadIds>
	<x path="Null"><c path="Array"><x path="Int"/></c></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Ids of threads to be terminated.</haxe_doc>
</threadIds></a>
		<haxe_doc>Arguments for 'terminateThreads' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.TerminateThreadsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a/></t>
		<haxe_doc>Response to 'terminateThreads' request. This is just an acknowledgement, so no body field is required.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ModulesRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.ModulesArguments"/></t>
		<haxe_doc>Modules request; value of command field is 'modules'.
	Modules can be retrieved from the debug adapter with the ModulesRequest which can either return all modules or a range of modules to support paging.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ModulesArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<startModule>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The index of the first module to return; if omitted modules start at 0.</haxe_doc>
			</startModule>
			<moduleCount>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The number of modules to return. If moduleCount is not specified or 0, all modules are returned.</haxe_doc>
			</moduleCount>
		</a>
		<haxe_doc>Arguments for 'modules' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ModulesResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<totalModules>
		<x path="Int"/>
		<haxe_doc>The total number of modules available.</haxe_doc>
	</totalModules>
	<modules>
		<c path="Array"><t path="vscode.debugProtocol.Module"/></c>
		<haxe_doc>All modules or range of modules.</haxe_doc>
	</modules>
</a></t>
		<haxe_doc>Response to 'modules' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.LoadedSourcesRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.LoadedSourcesArguments"/></t>
		<haxe_doc>LoadedSources request; value of command field is 'loadedSources'.
	Retrieves the set of all sources currently loaded by the debugged process.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.LoadedSourcesArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a/>
		<haxe_doc>Arguments for 'loadedSources' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.LoadedSourcesResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><sources>
	<c path="Array"><t path="vscode.debugProtocol.Source"/></c>
	<haxe_doc>Set of loaded sources.</haxe_doc>
</sources></a></t>
		<haxe_doc>Response to 'loadedSources' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.EvaluateRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.EvaluateArguments"/></t>
		<haxe_doc>Evaluate request; value of command field is 'evaluate'.
	Evaluates the given expression in the context of the top most stack frame.
	The expression has access to any variables and arguments that are in scope.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.EvaluateArgumentsContext" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.EvaluateArgumentsContext_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Watch public="1" get="inline" set="null" expr="cast &quot;watch&quot;" line="1534" static="1">
		<x path="vscode.debugProtocol.EvaluateArgumentsContext"/>
		<meta>
			<m n=":value"><e>cast "watch"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>evaluate is run in a watch.</haxe_doc>
	</Watch>
	<Repl public="1" get="inline" set="null" expr="cast &quot;repl&quot;" line="1539" static="1">
		<x path="vscode.debugProtocol.EvaluateArgumentsContext"/>
		<meta>
			<m n=":value"><e>cast "repl"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>evaluate is run from REPL console.</haxe_doc>
	</Repl>
	<Hover public="1" get="inline" set="null" expr="cast &quot;hover&quot;" line="1544" static="1">
		<x path="vscode.debugProtocol.EvaluateArgumentsContext"/>
		<meta>
			<m n=":value"><e>cast "hover"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>evaluate is run from a data hover.</haxe_doc>
	</Hover>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.EvaluateArgumentsContext_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Watch public="1" get="inline" set="null" expr="cast &quot;watch&quot;" line="1534" static="1">
			<x path="vscode.debugProtocol.EvaluateArgumentsContext"/>
			<meta>
				<m n=":value"><e>cast "watch"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>evaluate is run in a watch.</haxe_doc>
		</Watch>
		<Repl public="1" get="inline" set="null" expr="cast &quot;repl&quot;" line="1539" static="1">
			<x path="vscode.debugProtocol.EvaluateArgumentsContext"/>
			<meta>
				<m n=":value"><e>cast "repl"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>evaluate is run from REPL console.</haxe_doc>
		</Repl>
		<Hover public="1" get="inline" set="null" expr="cast &quot;hover&quot;" line="1544" static="1">
			<x path="vscode.debugProtocol.EvaluateArgumentsContext"/>
			<meta>
				<m n=":value"><e>cast "hover"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>evaluate is run from a data hover.</haxe_doc>
		</Hover>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.EvaluateArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<frameId>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Evaluate the expression in the scope of this stack frame. If not specified, the expression is evaluated in the global scope.</haxe_doc>
			</frameId>
			<format>
				<x path="Null"><t path="vscode.debugProtocol.ValueFormat"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies details on how to format the Evaluate result.</haxe_doc>
			</format>
			<expression>
				<c path="String"/>
				<haxe_doc>The expression to evaluate.</haxe_doc>
			</expression>
			<context>
				<x path="Null"><x path="vscode.debugProtocol.EvaluateArgumentsContext"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The context in which the evaluate request is run.</haxe_doc>
			</context>
		</a>
		<haxe_doc>Arguments for 'evaluate' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.EvaluateResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<variablesReference>
		<x path="Int"/>
		<haxe_doc><![CDATA[If variablesReference is > 0, the evaluate result is structured and its children can be retrieved by passing variablesReference to the VariablesRequest.
		The value should be less than or equal to 2147483647 (2^31 - 1).]]></haxe_doc>
	</variablesReference>
	<type>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The optional type of the evaluate result.</haxe_doc>
	</type>
	<result>
		<c path="String"/>
		<haxe_doc>The result of the evaluate request.</haxe_doc>
	</result>
	<namedVariables>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The number of named child variables.
		The client can use this optional information to present the variables in a paged UI and fetch them in chunks. The value should be less than or equal to 2147483647 (2^31 - 1).</haxe_doc>
	</namedVariables>
	<memoryReference>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Memory reference to a location appropriate for this result. For pointer type eval results, this is generally a reference to the memory address contained in the pointer.</haxe_doc>
	</memoryReference>
	<indexedVariables>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The number of indexed child variables.
		The client can use this optional information to present the variables in a paged UI and fetch them in chunks. The value should be less than or equal to 2147483647 (2^31 - 1).</haxe_doc>
	</indexedVariables>
</a></t>
		<haxe_doc>Response to 'evaluate' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetExpressionRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.SetExpressionArguments"/></t>
		<haxe_doc>SetExpression request; value of command field is 'setExpression'.
	Evaluates the given 'value' expression and assigns it to the 'expression' which must be a modifiable l-value.
	The expressions have access to any variables and arguments that are in scope of the specified frame.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetExpressionArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<value>
				<c path="String"/>
				<haxe_doc>The value expression to assign to the l-value expression.</haxe_doc>
			</value>
			<frameId>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Evaluate the expressions in the scope of this stack frame. If not specified, the expressions are evaluated in the global scope.</haxe_doc>
			</frameId>
			<format>
				<x path="Null"><t path="vscode.debugProtocol.ValueFormat"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specifies how the resulting value should be formatted.</haxe_doc>
			</format>
			<expression>
				<c path="String"/>
				<haxe_doc>The l-value expression to assign to.</haxe_doc>
			</expression>
		</a>
		<haxe_doc>Arguments for 'setExpression' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SetExpressionResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<variablesReference>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc><![CDATA[If variablesReference is > 0, the value is structured and its children can be retrieved by passing variablesReference to the VariablesRequest.
		The value should be less than or equal to 2147483647 (2^31 - 1).]]></haxe_doc>
	</variablesReference>
	<value>
		<c path="String"/>
		<haxe_doc>The new value of the expression.</haxe_doc>
	</value>
	<type>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The optional type of the value.</haxe_doc>
	</type>
	<presentationHint>
		<x path="Null"><t path="vscode.debugProtocol.VariablePresentationHint"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Properties of a value that can be used to determine how to render the result in the UI.</haxe_doc>
	</presentationHint>
	<namedVariables>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The number of named child variables.
		The client can use this optional information to present the variables in a paged UI and fetch them in chunks. The value should be less than or equal to 2147483647 (2^31 - 1).</haxe_doc>
	</namedVariables>
	<indexedVariables>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The number of indexed child variables.
		The client can use this optional information to present the variables in a paged UI and fetch them in chunks. The value should be less than or equal to 2147483647 (2^31 - 1).</haxe_doc>
	</indexedVariables>
</a></t>
		<haxe_doc>Response to 'setExpression' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepInTargetsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.StepInTargetsArguments"/></t>
		<haxe_doc>StepInTargets request; value of command field is 'stepInTargets'.
	This request retrieves the possible stepIn targets for the specified stack frame.
	These targets can be used in the 'stepIn' request.
	The StepInTargets may only be called if the 'supportsStepInTargetsRequest' capability exists and is true.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepInTargetsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><frameId>
	<x path="Int"/>
	<haxe_doc>The stack frame for which to retrieve the possible stepIn targets.</haxe_doc>
</frameId></a>
		<haxe_doc>Arguments for 'stepInTargets' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepInTargetsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><targets>
	<c path="Array"><t path="vscode.debugProtocol.StepInTarget"/></c>
	<haxe_doc>The possible stepIn targets of the specified source location.</haxe_doc>
</targets></a></t>
		<haxe_doc>Response to 'stepInTargets' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.GotoTargetsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.GotoTargetsArguments"/></t>
		<haxe_doc>GotoTargets request; value of command field is 'gotoTargets'.
	This request retrieves the possible goto targets for the specified source location.
	These targets can be used in the 'goto' request.
	The GotoTargets request may only be called if the 'supportsGotoTargetsRequest' capability exists and is true.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.GotoTargetsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<source>
				<t path="vscode.debugProtocol.Source"/>
				<haxe_doc>The source location for which the goto targets are determined.</haxe_doc>
			</source>
			<line>
				<x path="Int"/>
				<haxe_doc>The line location for which the goto targets are determined.</haxe_doc>
			</line>
			<column>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional column location for which the goto targets are determined.</haxe_doc>
			</column>
		</a>
		<haxe_doc>Arguments for 'gotoTargets' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.GotoTargetsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><targets>
	<c path="Array"><t path="vscode.debugProtocol.GotoTarget"/></c>
	<haxe_doc>The possible goto targets of the specified location.</haxe_doc>
</targets></a></t>
		<haxe_doc>Response to 'gotoTargets' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.CompletionsRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.CompletionsArguments"/></t>
		<haxe_doc>Completions request; value of command field is 'completions'.
	Returns a list of possible completions for a given caret position and text.
	The CompletionsRequest may only be called if the 'supportsCompletionsRequest' capability exists and is true.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.CompletionsArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<text>
				<c path="String"/>
				<haxe_doc>One or more source lines. Typically this is the text a user has typed into the debug console before he asked for completion.</haxe_doc>
			</text>
			<line>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional line for which to determine the completion proposals. If missing the first line of the text is assumed.</haxe_doc>
			</line>
			<frameId>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Returns completions in the scope of this stack frame. If not specified, the completions are returned for the global scope.</haxe_doc>
			</frameId>
			<column>
				<x path="Int"/>
				<haxe_doc>The character position for which to determine the completion proposals.</haxe_doc>
			</column>
		</a>
		<haxe_doc>Arguments for 'completions' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.CompletionsResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><targets>
	<c path="Array"><t path="vscode.debugProtocol.CompletionItem"/></c>
	<haxe_doc>The possible completions for .</haxe_doc>
</targets></a></t>
		<haxe_doc>Response to 'completions' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ExceptionInfoRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.ExceptionInfoArguments"/></t>
		<haxe_doc>ExceptionInfo request; value of command field is 'exceptionInfo'.
	Retrieves the details of the exception that caused this event to be raised.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ExceptionInfoArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><threadId>
	<x path="Int"/>
	<haxe_doc>Thread for which exception information should be retrieved.</haxe_doc>
</threadId></a>
		<haxe_doc>Arguments for 'exceptionInfo' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ExceptionInfoResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<exceptionId>
		<c path="String"/>
		<haxe_doc>ID of the exception that was thrown.</haxe_doc>
	</exceptionId>
	<details>
		<x path="Null"><t path="vscode.debugProtocol.ExceptionDetails"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Detailed information about the exception.</haxe_doc>
	</details>
	<description>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Descriptive text for the exception provided by the debug adapter.</haxe_doc>
	</description>
	<breakMode>
		<x path="vscode.debugProtocol.ExceptionBreakMode"/>
		<haxe_doc>Mode that caused the exception notification to be raised.</haxe_doc>
	</breakMode>
</a></t>
		<haxe_doc>Response to 'exceptionInfo' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ReadMemoryRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.ReadMemoryArguments"/></t>
		<haxe_doc>ReadMemory request; value of command field is 'readMemory'.
	Reads bytes from memory at the provided location.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ReadMemoryArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<offset>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional offset (in bytes) to be applied to the reference location before reading data. Can be negative.</haxe_doc>
			</offset>
			<memoryReference>
				<c path="String"/>
				<haxe_doc>Memory reference to the base location from which data should be read.</haxe_doc>
			</memoryReference>
			<count>
				<x path="Int"/>
				<haxe_doc>Number of bytes to read at the specified location and offset.</haxe_doc>
			</count>
		</a>
		<haxe_doc>Arguments for 'readMemory' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ReadMemoryResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a>
	<unreadableBytes>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The number of unreadable bytes encountered after the last successfully read byte.
		This can be used to determine the number of bytes that must be skipped before a subsequent 'readMemory' request will succeed.</haxe_doc>
	</unreadableBytes>
	<data>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The bytes read from memory, encoded using base64.</haxe_doc>
	</data>
	<address>
		<c path="String"/>
		<haxe_doc>The address of the first byte of data returned. Treated as a hex value if prefixed with '0x', or as a decimal value otherwise.</haxe_doc>
	</address>
</a></t>
		<haxe_doc>Response to 'readMemory' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DisassembleRequest" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Request"><t path="vscode.debugProtocol.DisassembleArguments"/></t>
		<haxe_doc>Disassemble request; value of command field is 'disassemble'.
	Disassembles code stored at the provided location.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DisassembleArguments" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<resolveSymbols>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If true, the adapter should attempt to resolve memory addresses and other values to symbolic names.</haxe_doc>
			</resolveSymbols>
			<offset>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional offset (in bytes) to be applied to the reference location before disassembling. Can be negative.</haxe_doc>
			</offset>
			<memoryReference>
				<c path="String"/>
				<haxe_doc>Memory reference to the base location containing the instructions to disassemble.</haxe_doc>
			</memoryReference>
			<instructionOffset>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional offset (in instructions) to be applied after the byte offset (if any) before disassembling. Can be negative.</haxe_doc>
			</instructionOffset>
			<instructionCount>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Number of instructions to disassemble starting at the specified location and offset. An adapter must return exactly this number of instructions -
		any unavailable instructions should be replaced with an implementation-defined 'invalid instruction' value.</haxe_doc>
			</instructionCount>
		</a>
		<haxe_doc>Arguments for 'disassemble' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DisassembleResponse" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<t path="vscode.debugProtocol.Response"><a><instructions>
	<c path="Array"><t path="vscode.debugProtocol.DisassembledInstruction"/></c>
	<haxe_doc>The list of disassembled instructions.</haxe_doc>
</instructions></a></t>
		<haxe_doc>Response to 'disassemble' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Capabilities" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<supportsValueFormattingOptions>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports a 'format' attribute on the stackTraceRequest, variablesRequest, and evaluateRequest.</haxe_doc>
			</supportsValueFormattingOptions>
			<supportsTerminateThreadsRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'terminateThreads' request.</haxe_doc>
			</supportsTerminateThreadsRequest>
			<supportsTerminateRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'terminate' request.</haxe_doc>
			</supportsTerminateRequest>
			<supportsStepInTargetsRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the stepInTargetsRequest.</haxe_doc>
			</supportsStepInTargetsRequest>
			<supportsStepBack>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports stepping back via the stepBack and reverseContinue requests.</haxe_doc>
			</supportsStepBack>
			<supportsSetVariable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports setting a variable to a value.</haxe_doc>
			</supportsSetVariable>
			<supportsSetExpression>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'setExpression' request.</haxe_doc>
			</supportsSetExpression>
			<supportsRestartRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the RestartRequest. In this case a client should not implement 'restart' by terminating and relaunching the adapter but by calling the RestartRequest.</haxe_doc>
			</supportsRestartRequest>
			<supportsRestartFrame>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports restarting a frame.</haxe_doc>
			</supportsRestartFrame>
			<supportsReadMemoryRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'readMemory' request.</haxe_doc>
			</supportsReadMemoryRequest>
			<supportsModulesRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the modules request.</haxe_doc>
			</supportsModulesRequest>
			<supportsLogPoints>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports logpoints by interpreting the 'logMessage' attribute of the SourceBreakpoint.</haxe_doc>
			</supportsLogPoints>
			<supportsLoadedSourcesRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'loadedSources' request.</haxe_doc>
			</supportsLoadedSourcesRequest>
			<supportsHitConditionalBreakpoints>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports breakpoints that break execution after a specified number of hits.</haxe_doc>
			</supportsHitConditionalBreakpoints>
			<supportsGotoTargetsRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the gotoTargetsRequest.</haxe_doc>
			</supportsGotoTargetsRequest>
			<supportsFunctionBreakpoints>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports function breakpoints.</haxe_doc>
			</supportsFunctionBreakpoints>
			<supportsExceptionOptions>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports 'exceptionOptions' on the setExceptionBreakpoints request.</haxe_doc>
			</supportsExceptionOptions>
			<supportsExceptionInfoRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the exceptionInfo request.</haxe_doc>
			</supportsExceptionInfoRequest>
			<supportsEvaluateForHovers>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports a (side effect free) evaluate request for data hovers.</haxe_doc>
			</supportsEvaluateForHovers>
			<supportsDisassembleRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'disassemble' request.</haxe_doc>
			</supportsDisassembleRequest>
			<supportsDelayedStackTraceLoading>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the delayed loading of parts of the stack, which requires that both the 'startFrame' and 'levels' arguments and the 'totalFrames' result of the 'StackTrace' request are supported.</haxe_doc>
			</supportsDelayedStackTraceLoading>
			<supportsDataBreakpoints>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports data breakpoints.</haxe_doc>
			</supportsDataBreakpoints>
			<supportsConfigurationDoneRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the configurationDoneRequest.</haxe_doc>
			</supportsConfigurationDoneRequest>
			<supportsConditionalBreakpoints>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports conditional breakpoints.</haxe_doc>
			</supportsConditionalBreakpoints>
			<supportsCompletionsRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the completionsRequest.</haxe_doc>
			</supportsCompletionsRequest>
			<supportsCancelRequest>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'cancel' request.</haxe_doc>
			</supportsCancelRequest>
			<supportedChecksumAlgorithms>
				<x path="Null"><c path="Array"><x path="vscode.debugProtocol.ChecksumAlgorithm"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Checksum algorithms supported by the debug adapter.</haxe_doc>
			</supportedChecksumAlgorithms>
			<supportTerminateDebuggee>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The debug adapter supports the 'terminateDebuggee' attribute on the 'disconnect' request.</haxe_doc>
			</supportTerminateDebuggee>
			<exceptionBreakpointFilters>
				<x path="Null"><c path="Array"><t path="vscode.debugProtocol.ExceptionBreakpointsFilter"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Available filters or options for the setExceptionBreakpoints request.</haxe_doc>
			</exceptionBreakpointFilters>
			<additionalModuleColumns>
				<x path="Null"><c path="Array"><t path="vscode.debugProtocol.ColumnDescriptor"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The set of additional module information exposed by the debug adapter.</haxe_doc>
			</additionalModuleColumns>
		</a>
		<haxe_doc>Information about the capabilities of a debug adapter.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ExceptionBreakpointsFilter" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<label>
				<c path="String"/>
				<haxe_doc>The name of the filter. This will be shown in the UI.</haxe_doc>
			</label>
			<filter>
				<c path="String"/>
				<haxe_doc>The internal ID of the filter. This value is passed to the setExceptionBreakpoints request.</haxe_doc>
			</filter>
		</a>
		<haxe_doc>An ExceptionBreakpointsFilter is shown in the UI as an option for configuring how exceptions are dealt with.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Message" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<variables>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An object used as a dictionary for looking up the variables in the format string.</haxe_doc>
			</variables>
			<urlLabel>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional label that is presented to the user as the UI for opening the url.</haxe_doc>
			</urlLabel>
			<url>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional url where additional information about this message can be found.</haxe_doc>
			</url>
			<showUser>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If true show user.</haxe_doc>
			</showUser>
			<sendTelemetry>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If true send to telemetry.</haxe_doc>
			</sendTelemetry>
			<id>
				<x path="Int"/>
				<haxe_doc>Unique identifier for the message.</haxe_doc>
			</id>
			<format>
				<c path="String"/>
				<haxe_doc>A format string for the message. Embedded variables have the form '{name}'.
		If variable name starts with an underscore character, the variable does not contain user data (PII) and can be safely used for telemetry purposes.</haxe_doc>
			</format>
		</a>
		<haxe_doc>A structured message object. Used to return errors from requests.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Module" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<version>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Version of Module.</haxe_doc>
			</version>
			<symbolStatus>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>User understandable description of if symbols were found for the module (ex: 'Symbols Loaded', 'Symbols not found', etc.</haxe_doc>
			</symbolStatus>
			<symbolFilePath>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Logical full path to the symbol file. The exact definition is implementation defined.</haxe_doc>
			</symbolFilePath>
			<path>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Logical full path to the module. The exact definition is implementation defined, but usually this would be a full path to the on-disk file for the module.</haxe_doc>
			</path>
			<name>
				<c path="String"/>
				<haxe_doc>A name of the module.</haxe_doc>
			</name>
			<isUserCode>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>True if the module is considered 'user code' by a debugger that supports 'Just My Code'.</haxe_doc>
			</isUserCode>
			<isOptimized>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>True if the module is optimized.</haxe_doc>
			</isOptimized>
			<id>
				<x path="haxe.extern.EitherType">
					<x path="Int"/>
					<c path="String"/>
				</x>
				<haxe_doc>Unique identifier for the module.</haxe_doc>
			</id>
			<dateTimeStamp>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Module created or modified.</haxe_doc>
			</dateTimeStamp>
			<addressRange>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Address range covered by this module.</haxe_doc>
			</addressRange>
		</a>
		<haxe_doc>A Module object represents a row in the modules view.
	Two attributes are mandatory: an id identifies a module in the modules view and is used in a ModuleEvent for identifying a module for adding, updating or deleting.
	The name is used to minimally render the module in the UI.

	Additional attributes can be added to the module. They will show up in the module View if they have a corresponding ColumnDescriptor.

	To avoid an unnecessary proliferation of additional attributes with similar semantics but different names
	we recommend to re-use attributes from the 'recommended' list below first, and only introduce new attributes if nothing appropriate could be found.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.ColumnDescriptorType" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.ColumnDescriptorType_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<String public="1" get="inline" set="null" expr="cast &quot;string&quot;" line="2202" static="1">
		<x path="vscode.debugProtocol.ColumnDescriptorType"/>
		<meta>
			<m n=":value"><e>cast "string"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</String>
	<Number public="1" get="inline" set="null" expr="cast &quot;number&quot;" line="2203" static="1">
		<x path="vscode.debugProtocol.ColumnDescriptorType"/>
		<meta>
			<m n=":value"><e>cast "number"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Number>
	<Boolean public="1" get="inline" set="null" expr="cast &quot;boolean&quot;" line="2204" static="1">
		<x path="vscode.debugProtocol.ColumnDescriptorType"/>
		<meta>
			<m n=":value"><e>cast "boolean"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Boolean>
	<UnixTimestampUTC public="1" get="inline" set="null" expr="cast &quot;unixTimestampUTC&quot;" line="2205" static="1">
		<x path="vscode.debugProtocol.ColumnDescriptorType"/>
		<meta>
			<m n=":value"><e>cast "unixTimestampUTC"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UnixTimestampUTC>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.ColumnDescriptorType_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<String public="1" get="inline" set="null" expr="cast &quot;string&quot;" line="2202" static="1">
			<x path="vscode.debugProtocol.ColumnDescriptorType"/>
			<meta>
				<m n=":value"><e>cast "string"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</String>
		<Number public="1" get="inline" set="null" expr="cast &quot;number&quot;" line="2203" static="1">
			<x path="vscode.debugProtocol.ColumnDescriptorType"/>
			<meta>
				<m n=":value"><e>cast "number"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Number>
		<Boolean public="1" get="inline" set="null" expr="cast &quot;boolean&quot;" line="2204" static="1">
			<x path="vscode.debugProtocol.ColumnDescriptorType"/>
			<meta>
				<m n=":value"><e>cast "boolean"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Boolean>
		<UnixTimestampUTC public="1" get="inline" set="null" expr="cast &quot;unixTimestampUTC&quot;" line="2205" static="1">
			<x path="vscode.debugProtocol.ColumnDescriptorType"/>
			<meta>
				<m n=":value"><e>cast "unixTimestampUTC"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UnixTimestampUTC>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.ColumnDescriptor" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<width>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Width of this column in characters (hint only).</haxe_doc>
			</width>
			<type>
				<x path="Null"><x path="vscode.debugProtocol.ColumnDescriptorType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Datatype of values in this column.  Defaults to 'string' if not specified.</haxe_doc>
			</type>
			<label>
				<c path="String"/>
				<haxe_doc>Header UI label of column.</haxe_doc>
			</label>
			<format>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Format to use for the rendered values in this column. TBD how the format strings looks like.</haxe_doc>
			</format>
			<attributeName>
				<c path="String"/>
				<haxe_doc>Name of the attribute rendered in this column.</haxe_doc>
			</attributeName>
		</a>
		<haxe_doc>A ColumnDescriptor specifies what module attribute to show in a column of the ModulesView, how to format it, and what the column's label should be.
	It is only used if the underlying UI actually supports this level of customization.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ModulesViewDescriptor" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><columns><c path="Array"><t path="vscode.debugProtocol.ColumnDescriptor"/></c></columns></a>
		<haxe_doc>The ModulesViewDescriptor is the container for all declarative configuration options of a ModuleView.
	For now it only specifies the columns to be shown in the modules view.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Thread" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<name>
				<c path="String"/>
				<haxe_doc>A name of the thread.</haxe_doc>
			</name>
			<id>
				<x path="Int"/>
				<haxe_doc>Unique identifier for the thread.</haxe_doc>
			</id>
		</a>
		<haxe_doc>A Thread</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.SourcePresentationHint" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.SourcePresentationHint_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Normal public="1" get="inline" set="null" expr="cast &quot;normal&quot;" line="2263" static="1">
		<x path="vscode.debugProtocol.SourcePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "normal"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Normal>
	<Emphasize public="1" get="inline" set="null" expr="cast &quot;emphasize&quot;" line="2264" static="1">
		<x path="vscode.debugProtocol.SourcePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "emphasize"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Emphasize>
	<Deemphasize public="1" get="inline" set="null" expr="cast &quot;deemphasize&quot;" line="2265" static="1">
		<x path="vscode.debugProtocol.SourcePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "deemphasize"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Deemphasize>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.SourcePresentationHint_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Normal public="1" get="inline" set="null" expr="cast &quot;normal&quot;" line="2263" static="1">
			<x path="vscode.debugProtocol.SourcePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "normal"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Normal>
		<Emphasize public="1" get="inline" set="null" expr="cast &quot;emphasize&quot;" line="2264" static="1">
			<x path="vscode.debugProtocol.SourcePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "emphasize"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Emphasize>
		<Deemphasize public="1" get="inline" set="null" expr="cast &quot;deemphasize&quot;" line="2265" static="1">
			<x path="vscode.debugProtocol.SourcePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "deemphasize"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Deemphasize>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.Source" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<sources>
				<x path="Null"><c path="Array"><t path="vscode.debugProtocol.Source"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of sources that are related to this source. These may be the source that generated this source.</haxe_doc>
			</sources>
			<sourceReference>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[If sourceReference > 0 the contents of the source must be retrieved through the SourceRequest (even if a path is specified). A sourceReference is only valid for a session, so it must not be used to persist a source.]]></haxe_doc>
			</sourceReference>
			<presentationHint>
				<x path="Null"><x path="vscode.debugProtocol.SourcePresentationHint"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional hint for how to present the source in the UI. A value of 'deemphasize' can be used to indicate that the source is not available or that it is skipped on stepping.</haxe_doc>
			</presentationHint>
			<path>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The path of the source to be shown in the UI. It is only used to locate and load the content of the source if no sourceReference is specified (or its vaule is 0).</haxe_doc>
			</path>
			<origin>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The (optional) origin of this source: possible values 'internal module', 'inlined content from source map', etc.</haxe_doc>
			</origin>
			<name>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The short name of the source. Every source returned from the debug adapter has a name. When sending a source to the debug adapter this name is optional.</haxe_doc>
			</name>
			<checksums>
				<x path="Null"><c path="Array"><t path="vscode.debugProtocol.Checksum"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The checksums associated with this file.</haxe_doc>
			</checksums>
			<adapterData>
				<x path="Null"><d/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional data that a debug adapter might want to loop through the client. The client should leave the data intact and persist it across sessions. The client should not interpret the data.</haxe_doc>
			</adapterData>
		</a>
		<haxe_doc>A Source is a descriptor for source code.
	It is returned from the debug adapter as part of a StackFrame and it is used by clients when specifying breakpoints.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.StackFramePresentationHint" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.StackFramePresentationHint_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Normal public="1" get="inline" set="null" expr="cast &quot;normal&quot;" line="2315" static="1">
		<x path="vscode.debugProtocol.StackFramePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "normal"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Normal>
	<Label public="1" get="inline" set="null" expr="cast &quot;label&quot;" line="2316" static="1">
		<x path="vscode.debugProtocol.StackFramePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "label"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Label>
	<Subtle public="1" get="inline" set="null" expr="cast &quot;subtle&quot;" line="2317" static="1">
		<x path="vscode.debugProtocol.StackFramePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "subtle"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Subtle>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.StackFramePresentationHint_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Normal public="1" get="inline" set="null" expr="cast &quot;normal&quot;" line="2315" static="1">
			<x path="vscode.debugProtocol.StackFramePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "normal"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Normal>
		<Label public="1" get="inline" set="null" expr="cast &quot;label&quot;" line="2316" static="1">
			<x path="vscode.debugProtocol.StackFramePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "label"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Label>
		<Subtle public="1" get="inline" set="null" expr="cast &quot;subtle&quot;" line="2317" static="1">
			<x path="vscode.debugProtocol.StackFramePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "subtle"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Subtle>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.StackFrame" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<source>
				<x path="Null"><t path="vscode.debugProtocol.Source"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional source of the frame.</haxe_doc>
			</source>
			<presentationHint>
				<x path="Null"><x path="vscode.debugProtocol.StackFramePresentationHint"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional hint for how to present this frame in the UI.
		A value of 'label' can be used to indicate that the frame is an artificial frame that is used as a visual label or separator.
		A value of 'subtle' can be used to change the appearance of a frame in a 'subtle' way.</haxe_doc>
			</presentationHint>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the stack frame, typically a method name.</haxe_doc>
			</name>
			<moduleId>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The module associated with this frame, if any.</haxe_doc>
			</moduleId>
			<line>
				<x path="Int"/>
				<haxe_doc>The line within the file of the frame. If source is null or doesn't exist, line is 0 and must be ignored.</haxe_doc>
			</line>
			<id>
				<x path="Int"/>
				<haxe_doc>An identifier for the stack frame. It must be unique across all threads.
		This id can be used to retrieve the scopes of the frame with the 'scopesRequest' or to restart the execution of a stackframe.</haxe_doc>
			</id>
			<endLine>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional end line of the range covered by the stack frame.</haxe_doc>
			</endLine>
			<endColumn>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional end column of the range covered by the stack frame.</haxe_doc>
			</endColumn>
			<column>
				<x path="Int"/>
				<haxe_doc>The column within the line. If source is null or doesn't exist, column is 0 and must be ignored.</haxe_doc>
			</column>
		</a>
		<haxe_doc>A Stackframe contains the source location.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.ScopePresentationHint" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.ScopePresentationHint_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Arguments public="1" get="inline" set="null" expr="cast &quot;arguments&quot;" line="2374" static="1">
		<x path="vscode.debugProtocol.ScopePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "arguments"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Arguments>
	<Locals public="1" get="inline" set="null" expr="cast &quot;locals&quot;" line="2375" static="1">
		<x path="vscode.debugProtocol.ScopePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "locals"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Locals>
	<Registers public="1" get="inline" set="null" expr="cast &quot;registers&quot;" line="2376" static="1">
		<x path="vscode.debugProtocol.ScopePresentationHint"/>
		<meta>
			<m n=":value"><e>cast "registers"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Registers>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.ScopePresentationHint_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Arguments public="1" get="inline" set="null" expr="cast &quot;arguments&quot;" line="2374" static="1">
			<x path="vscode.debugProtocol.ScopePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "arguments"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Arguments>
		<Locals public="1" get="inline" set="null" expr="cast &quot;locals&quot;" line="2375" static="1">
			<x path="vscode.debugProtocol.ScopePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "locals"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Locals>
		<Registers public="1" get="inline" set="null" expr="cast &quot;registers&quot;" line="2376" static="1">
			<x path="vscode.debugProtocol.ScopePresentationHint"/>
			<meta>
				<m n=":value"><e>cast "registers"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Registers>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.Scope" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<variablesReference>
				<x path="Int"/>
				<haxe_doc>The variables of this scope can be retrieved by passing the value of variablesReference to the VariablesRequest.</haxe_doc>
			</variablesReference>
			<source>
				<x path="Null"><t path="vscode.debugProtocol.Source"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional source for this scope.</haxe_doc>
			</source>
			<presentationHint>
				<x path="Null"><x path="vscode.debugProtocol.ScopePresentationHint"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional hint for how to present this scope in the UI. If this attribute is missing, the scope is shown with a generic UI.
		Values:
		'arguments': Scope contains method arguments.
		'locals': Scope contains local variables.
		'registers': Scope contains registers. Only a single 'registers' scope should be returned from a 'scopes' request.
		etc.</haxe_doc>
			</presentationHint>
			<namedVariables>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The number of named variables in this scope.
		The client can use this optional information to present the variables in a paged UI and fetch them in chunks.</haxe_doc>
			</namedVariables>
			<name>
				<c path="String"/>
				<haxe_doc>Name of the scope such as 'Arguments', 'Locals'.</haxe_doc>
			</name>
			<line>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional start line of the range covered by this scope.</haxe_doc>
			</line>
			<indexedVariables>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The number of indexed variables in this scope.
		The client can use this optional information to present the variables in a paged UI and fetch them in chunks.</haxe_doc>
			</indexedVariables>
			<expensive>
				<x path="Bool"/>
				<haxe_doc>If true, the number of variables in this scope is large or expensive to retrieve.</haxe_doc>
			</expensive>
			<endLine>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional end line of the range covered by this scope.</haxe_doc>
			</endLine>
			<endColumn>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional end column of the range covered by this scope.</haxe_doc>
			</endColumn>
			<column>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional start column of the range covered by this scope.</haxe_doc>
			</column>
		</a>
		<haxe_doc>A Scope is a named container for variables. Optionally a scope can map to a source or a range within a source.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Variable" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<variablesReference>
				<x path="Int"/>
				<haxe_doc><![CDATA[If variablesReference is > 0, the variable is structured and its children can be retrieved by passing variablesReference to the VariablesRequest.]]></haxe_doc>
			</variablesReference>
			<value>
				<c path="String"/>
				<haxe_doc>The variable's value. This can be a multi-line text, e.g. for a function the body of a function.</haxe_doc>
			</value>
			<type>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the variable's value. Typically shown in the UI when hovering over the value.</haxe_doc>
			</type>
			<presentationHint>
				<x path="Null"><t path="vscode.debugProtocol.VariablePresentationHint"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Properties of a variable that can be used to determine how to render the variable in the UI.</haxe_doc>
			</presentationHint>
			<namedVariables>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The number of named child variables.
		The client can use this optional information to present the children in a paged UI and fetch them in chunks.</haxe_doc>
			</namedVariables>
			<name>
				<c path="String"/>
				<haxe_doc>The variable's name.</haxe_doc>
			</name>
			<memoryReference>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional memory reference for the variable if the variable represents executable code, such as a function pointer.</haxe_doc>
			</memoryReference>
			<indexedVariables>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The number of indexed child variables.
		The client can use this optional information to present the children in a paged UI and fetch them in chunks.</haxe_doc>
			</indexedVariables>
			<evaluateName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional evaluatable name of this variable which can be passed to the 'EvaluateRequest' to fetch the variable's value.</haxe_doc>
			</evaluateName>
		</a>
		<haxe_doc>A Variable is a name/value pair.
	Optionally a variable can have a 'type' that is shown if space permits or when hovering over the variable's name.
	An optional 'kind' is used to render additional properties of the variable, e.g. different icons can be used to indicate that a variable is public or private.
	If the value is structured (has children), a handle is provided to retrieve the children with the VariablesRequest.
	If the number of named or indexed children is large, the numbers should be returned via the optional 'namedVariables' and 'indexedVariables' attributes.
	The client can use this optional information to present the children in a paged UI and fetch them in chunks.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.VariableKind" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.VariableKind_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Property public="1" get="inline" set="null" expr="cast &quot;property&quot;" line="2507" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "property"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is a property.</haxe_doc>
	</Property>
	<Method public="1" get="inline" set="null" expr="cast &quot;method&quot;" line="2512" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "method"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is a method.</haxe_doc>
	</Method>
	<Class public="1" get="inline" set="null" expr="cast &quot;class&quot;" line="2517" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "class"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is a class.</haxe_doc>
	</Class>
	<Data public="1" get="inline" set="null" expr="cast &quot;data&quot;" line="2522" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "data"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is data.</haxe_doc>
	</Data>
	<Event public="1" get="inline" set="null" expr="cast &quot;event&quot;" line="2527" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "event"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is an event.</haxe_doc>
	</Event>
	<BaseClass public="1" get="inline" set="null" expr="cast &quot;baseClass&quot;" line="2532" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "baseClass"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is a base class.</haxe_doc>
	</BaseClass>
	<InnerClass public="1" get="inline" set="null" expr="cast &quot;innerClass&quot;" line="2537" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "innerClass"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is an inner class.</haxe_doc>
	</InnerClass>
	<Interface public="1" get="inline" set="null" expr="cast &quot;interface&quot;" line="2542" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "interface"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is an interface.</haxe_doc>
	</Interface>
	<MostDerivedClass public="1" get="inline" set="null" expr="cast &quot;mostDerivedClass&quot;" line="2547" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "mostDerivedClass"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is the most derived class.</haxe_doc>
	</MostDerivedClass>
	<Virtual public="1" get="inline" set="null" expr="cast &quot;virtual&quot;" line="2552" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "virtual"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is virtual, that means it is a synthetic object introduced by the adapter for rendering purposes, e.g. an index range for large arrays.</haxe_doc>
	</Virtual>
	<DataBreakpoint public="1" get="inline" set="null" expr="cast &quot;dataBreakpoint&quot;" line="2557" static="1">
		<x path="vscode.debugProtocol.VariableKind"/>
		<meta>
			<m n=":value"><e>cast "dataBreakpoint"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that a data breakpoint is registered for the object.</haxe_doc>
	</DataBreakpoint>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.VariableKind_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Property public="1" get="inline" set="null" expr="cast &quot;property&quot;" line="2507" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "property"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is a property.</haxe_doc>
		</Property>
		<Method public="1" get="inline" set="null" expr="cast &quot;method&quot;" line="2512" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "method"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is a method.</haxe_doc>
		</Method>
		<Class public="1" get="inline" set="null" expr="cast &quot;class&quot;" line="2517" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "class"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is a class.</haxe_doc>
		</Class>
		<Data public="1" get="inline" set="null" expr="cast &quot;data&quot;" line="2522" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "data"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is data.</haxe_doc>
		</Data>
		<Event public="1" get="inline" set="null" expr="cast &quot;event&quot;" line="2527" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "event"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is an event.</haxe_doc>
		</Event>
		<BaseClass public="1" get="inline" set="null" expr="cast &quot;baseClass&quot;" line="2532" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "baseClass"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is a base class.</haxe_doc>
		</BaseClass>
		<InnerClass public="1" get="inline" set="null" expr="cast &quot;innerClass&quot;" line="2537" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "innerClass"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is an inner class.</haxe_doc>
		</InnerClass>
		<Interface public="1" get="inline" set="null" expr="cast &quot;interface&quot;" line="2542" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "interface"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is an interface.</haxe_doc>
		</Interface>
		<MostDerivedClass public="1" get="inline" set="null" expr="cast &quot;mostDerivedClass&quot;" line="2547" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "mostDerivedClass"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is the most derived class.</haxe_doc>
		</MostDerivedClass>
		<Virtual public="1" get="inline" set="null" expr="cast &quot;virtual&quot;" line="2552" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "virtual"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is virtual, that means it is a synthetic object introduced by the adapter for rendering purposes, e.g. an index range for large arrays.</haxe_doc>
		</Virtual>
		<DataBreakpoint public="1" get="inline" set="null" expr="cast &quot;dataBreakpoint&quot;" line="2557" static="1">
			<x path="vscode.debugProtocol.VariableKind"/>
			<meta>
				<m n=":value"><e>cast "dataBreakpoint"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that a data breakpoint is registered for the object.</haxe_doc>
		</DataBreakpoint>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vscode.debugProtocol.VariableAttribute" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.VariableAttribute_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Static public="1" get="inline" set="null" expr="cast &quot;static&quot;" line="2564" static="1">
		<x path="vscode.debugProtocol.VariableAttribute"/>
		<meta>
			<m n=":value"><e>cast "static"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is static.</haxe_doc>
	</Static>
	<Constant public="1" get="inline" set="null" expr="cast &quot;constant&quot;" line="2569" static="1">
		<x path="vscode.debugProtocol.VariableAttribute"/>
		<meta>
			<m n=":value"><e>cast "constant"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is a constant.</haxe_doc>
	</Constant>
	<ReadOnly public="1" get="inline" set="null" expr="cast &quot;readOnly&quot;" line="2574" static="1">
		<x path="vscode.debugProtocol.VariableAttribute"/>
		<meta>
			<m n=":value"><e>cast "readOnly"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is read only.</haxe_doc>
	</ReadOnly>
	<RawString public="1" get="inline" set="null" expr="cast &quot;rawString&quot;" line="2579" static="1">
		<x path="vscode.debugProtocol.VariableAttribute"/>
		<meta>
			<m n=":value"><e>cast "rawString"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object is a raw string.</haxe_doc>
	</RawString>
	<HasObjectId public="1" get="inline" set="null" expr="cast &quot;hasObjectId&quot;" line="2584" static="1">
		<x path="vscode.debugProtocol.VariableAttribute"/>
		<meta>
			<m n=":value"><e>cast "hasObjectId"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object can have an Object ID created for it.</haxe_doc>
	</HasObjectId>
	<CanHaveObjectId public="1" get="inline" set="null" expr="cast &quot;canHaveObjectId&quot;" line="2589" static="1">
		<x path="vscode.debugProtocol.VariableAttribute"/>
		<meta>
			<m n=":value"><e>cast "canHaveObjectId"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the object has an Object ID associated with it.</haxe_doc>
	</CanHaveObjectId>
	<HasSideEffects public="1" get="inline" set="null" expr="cast &quot;hasSideEffects&quot;" line="2594" static="1">
		<x path="vscode.debugProtocol.VariableAttribute"/>
		<meta>
			<m n=":value"><e>cast "hasSideEffects"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Indicates that the evaluation had side effects.</haxe_doc>
	</HasSideEffects>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.VariableAttribute_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Static public="1" get="inline" set="null" expr="cast &quot;static&quot;" line="2564" static="1">
			<x path="vscode.debugProtocol.VariableAttribute"/>
			<meta>
				<m n=":value"><e>cast "static"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is static.</haxe_doc>
		</Static>
		<Constant public="1" get="inline" set="null" expr="cast &quot;constant&quot;" line="2569" static="1">
			<x path="vscode.debugProtocol.VariableAttribute"/>
			<meta>
				<m n=":value"><e>cast "constant"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is a constant.</haxe_doc>
		</Constant>
		<ReadOnly public="1" get="inline" set="null" expr="cast &quot;readOnly&quot;" line="2574" static="1">
			<x path="vscode.debugProtocol.VariableAttribute"/>
			<meta>
				<m n=":value"><e>cast "readOnly"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is read only.</haxe_doc>
		</ReadOnly>
		<RawString public="1" get="inline" set="null" expr="cast &quot;rawString&quot;" line="2579" static="1">
			<x path="vscode.debugProtocol.VariableAttribute"/>
			<meta>
				<m n=":value"><e>cast "rawString"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object is a raw string.</haxe_doc>
		</RawString>
		<HasObjectId public="1" get="inline" set="null" expr="cast &quot;hasObjectId&quot;" line="2584" static="1">
			<x path="vscode.debugProtocol.VariableAttribute"/>
			<meta>
				<m n=":value"><e>cast "hasObjectId"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object can have an Object ID created for it.</haxe_doc>
		</HasObjectId>
		<CanHaveObjectId public="1" get="inline" set="null" expr="cast &quot;canHaveObjectId&quot;" line="2589" static="1">
			<x path="vscode.debugProtocol.VariableAttribute"/>
			<meta>
				<m n=":value"><e>cast "canHaveObjectId"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the object has an Object ID associated with it.</haxe_doc>
		</CanHaveObjectId>
		<HasSideEffects public="1" get="inline" set="null" expr="cast &quot;hasSideEffects&quot;" line="2594" static="1">
			<x path="vscode.debugProtocol.VariableAttribute"/>
			<meta>
				<m n=":value"><e>cast "hasSideEffects"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Indicates that the evaluation had side effects.</haxe_doc>
		</HasSideEffects>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vscode.debugProtocol.VariableVisibility" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.VariableVisibility_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Public public="1" get="inline" set="null" expr="cast &quot;public&quot;" line="2598" static="1">
		<x path="vscode.debugProtocol.VariableVisibility"/>
		<meta>
			<m n=":value"><e>cast "public"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Public>
	<Private public="1" get="inline" set="null" expr="cast &quot;private&quot;" line="2599" static="1">
		<x path="vscode.debugProtocol.VariableVisibility"/>
		<meta>
			<m n=":value"><e>cast "private"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Private>
	<Protected public="1" get="inline" set="null" expr="cast &quot;protected&quot;" line="2600" static="1">
		<x path="vscode.debugProtocol.VariableVisibility"/>
		<meta>
			<m n=":value"><e>cast "protected"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Protected>
	<Internal public="1" get="inline" set="null" expr="cast &quot;internal&quot;" line="2601" static="1">
		<x path="vscode.debugProtocol.VariableVisibility"/>
		<meta>
			<m n=":value"><e>cast "internal"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Internal>
	<Final public="1" get="inline" set="null" expr="cast &quot;final&quot;" line="2602" static="1">
		<x path="vscode.debugProtocol.VariableVisibility"/>
		<meta>
			<m n=":value"><e>cast "final"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Final>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.VariableVisibility_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Public public="1" get="inline" set="null" expr="cast &quot;public&quot;" line="2598" static="1">
			<x path="vscode.debugProtocol.VariableVisibility"/>
			<meta>
				<m n=":value"><e>cast "public"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Public>
		<Private public="1" get="inline" set="null" expr="cast &quot;private&quot;" line="2599" static="1">
			<x path="vscode.debugProtocol.VariableVisibility"/>
			<meta>
				<m n=":value"><e>cast "private"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Private>
		<Protected public="1" get="inline" set="null" expr="cast &quot;protected&quot;" line="2600" static="1">
			<x path="vscode.debugProtocol.VariableVisibility"/>
			<meta>
				<m n=":value"><e>cast "protected"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Protected>
		<Internal public="1" get="inline" set="null" expr="cast &quot;internal&quot;" line="2601" static="1">
			<x path="vscode.debugProtocol.VariableVisibility"/>
			<meta>
				<m n=":value"><e>cast "internal"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Internal>
		<Final public="1" get="inline" set="null" expr="cast &quot;final&quot;" line="2602" static="1">
			<x path="vscode.debugProtocol.VariableVisibility"/>
			<meta>
				<m n=":value"><e>cast "final"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Final>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.VariablePresentationHint" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<visibility>
				<x path="Null"><x path="vscode.debugProtocol.VariableVisibility"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Visibility of variable. Before introducing additional values, try to use the listed values.</haxe_doc>
			</visibility>
			<kind>
				<x path="Null"><x path="vscode.debugProtocol.VariableKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The kind of variable. Before introducing additional values, try to use the listed values.</haxe_doc>
			</kind>
			<attributes>
				<x path="Null"><c path="Array"><x path="vscode.debugProtocol.VariableAttribute"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Set of attributes represented as an array of strings. Before introducing additional values, try to use the listed values.</haxe_doc>
			</attributes>
		</a>
		<haxe_doc>Optional properties of a variable that can be used to determine how to render the variable in the UI.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.BreakpointLocation" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<line>
				<x path="Int"/>
				<haxe_doc>Start line of breakpoint location.</haxe_doc>
			</line>
			<endLine>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional end line of breakpoint location if the location covers a range.</haxe_doc>
			</endLine>
			<endColumn>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional end column of breakpoint location if the location covers a range.</haxe_doc>
			</endColumn>
			<column>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional start column of breakpoint location.</haxe_doc>
			</column>
		</a>
		<haxe_doc>Properties of a breakpoint location returned from the 'breakpointLocations' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.SourceBreakpoint" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<logMessage>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If this attribute exists and is non-empty, the backend must not 'break' (stop) but log the message instead. Expressions within {} are interpolated.</haxe_doc>
			</logMessage>
			<line>
				<x path="Int"/>
				<haxe_doc>The source line of the breakpoint.</haxe_doc>
			</line>
			<hitCondition>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional expression that controls how many hits of the breakpoint are ignored.
		The backend is expected to interpret the expression as needed.</haxe_doc>
			</hitCondition>
			<condition>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional expression for conditional breakpoints.</haxe_doc>
			</condition>
			<column>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional source column of the breakpoint.</haxe_doc>
			</column>
		</a>
		<haxe_doc>Properties of a breakpoint passed to the setBreakpoints request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.FunctionBreakpoint" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function.</haxe_doc>
			</name>
			<hitCondition>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional expression that controls how many hits of the breakpoint are ignored. The backend is expected to interpret the expression as needed.</haxe_doc>
			</hitCondition>
			<condition>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional expression for conditional breakpoints.</haxe_doc>
			</condition>
		</a>
		<haxe_doc>Properties of a breakpoint passed to the setFunctionBreakpoints request.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.DataBreakpointAccessType" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<haxe_doc>This enumeration defines all possible access types for data breakpoints.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.DataBreakpointAccessType_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Read public="1" get="inline" set="null" expr="cast &quot;read&quot;" line="2703" static="1">
		<x path="vscode.debugProtocol.DataBreakpointAccessType"/>
		<meta>
			<m n=":value"><e>cast "read"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Read>
	<Write public="1" get="inline" set="null" expr="cast &quot;write&quot;" line="2704" static="1">
		<x path="vscode.debugProtocol.DataBreakpointAccessType"/>
		<meta>
			<m n=":value"><e>cast "write"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Write>
	<ReadWrite public="1" get="inline" set="null" expr="cast &quot;readWrite&quot;" line="2705" static="1">
		<x path="vscode.debugProtocol.DataBreakpointAccessType"/>
		<meta>
			<m n=":value"><e>cast "readWrite"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ReadWrite>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.DataBreakpointAccessType_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Read public="1" get="inline" set="null" expr="cast &quot;read&quot;" line="2703" static="1">
			<x path="vscode.debugProtocol.DataBreakpointAccessType"/>
			<meta>
				<m n=":value"><e>cast "read"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Read>
		<Write public="1" get="inline" set="null" expr="cast &quot;write&quot;" line="2704" static="1">
			<x path="vscode.debugProtocol.DataBreakpointAccessType"/>
			<meta>
				<m n=":value"><e>cast "write"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Write>
		<ReadWrite public="1" get="inline" set="null" expr="cast &quot;readWrite&quot;" line="2705" static="1">
			<x path="vscode.debugProtocol.DataBreakpointAccessType"/>
			<meta>
				<m n=":value"><e>cast "readWrite"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ReadWrite>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.DataBreakpoint" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<hitCondition>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional expression that controls how many hits of the breakpoint are ignored. The backend is expected to interpret the expression as needed.</haxe_doc>
			</hitCondition>
			<dataId>
				<c path="String"/>
				<haxe_doc>An id representing the data. This id is returned from the dataBreakpointInfo request.</haxe_doc>
			</dataId>
			<condition>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional expression for conditional breakpoints.</haxe_doc>
			</condition>
			<accessType>
				<x path="Null"><x path="vscode.debugProtocol.DataBreakpointAccessType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access type of the data.</haxe_doc>
			</accessType>
		</a>
		<haxe_doc>Properties of a data breakpoint passed to the setDataBreakpoints request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.Breakpoint" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<verified>
				<x path="Bool"/>
				<haxe_doc>If true breakpoint could be set (but not necessarily at the desired location).</haxe_doc>
			</verified>
			<source>
				<x path="Null"><t path="vscode.debugProtocol.Source"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The source where the breakpoint is located.</haxe_doc>
			</source>
			<message>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional message about the state of the breakpoint. This is shown to the user and can be used to explain why a breakpoint could not be verified.</haxe_doc>
			</message>
			<line>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The start line of the actual range covered by the breakpoint.</haxe_doc>
			</line>
			<id>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional unique identifier for the breakpoint.</haxe_doc>
			</id>
			<endLine>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional end line of the actual range covered by the breakpoint.</haxe_doc>
			</endLine>
			<endColumn>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional end column of the actual range covered by the breakpoint. If no end line is given, then the end column is assumed to be in the start line.</haxe_doc>
			</endColumn>
			<column>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional start column of the actual range covered by the breakpoint.</haxe_doc>
			</column>
		</a>
		<haxe_doc>Information about a Breakpoint created in setBreakpoints or setFunctionBreakpoints.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StepInTarget" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<label>
				<c path="String"/>
				<haxe_doc>The name of the stepIn target (shown in the UI).</haxe_doc>
			</label>
			<id>
				<x path="Int"/>
				<haxe_doc>Unique identifier for a stepIn target.</haxe_doc>
			</id>
		</a>
		<haxe_doc>A StepInTarget can be used in the 'stepIn' request and determines into which single target the stepIn request should step.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.GotoTarget" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<line>
				<x path="Int"/>
				<haxe_doc>The line of the goto target.</haxe_doc>
			</line>
			<label>
				<c path="String"/>
				<haxe_doc>The name of the goto target (shown in the UI).</haxe_doc>
			</label>
			<instructionPointerReference>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional memory reference for the instruction pointer value represented by this target.</haxe_doc>
			</instructionPointerReference>
			<id>
				<x path="Int"/>
				<haxe_doc>Unique identifier for a goto target. This is used in the goto request.</haxe_doc>
			</id>
			<endLine>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional end line of the range covered by the goto target.</haxe_doc>
			</endLine>
			<endColumn>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional end column of the range covered by the goto target.</haxe_doc>
			</endColumn>
			<column>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional column of the goto target.</haxe_doc>
			</column>
		</a>
		<haxe_doc>A GotoTarget describes a code location that can be used as a target in the 'goto' request.
	The possible goto targets can be determined via the 'gotoTargets' request.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.CompletionItem" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<type>
				<x path="Null"><x path="vscode.debugProtocol.CompletionItemType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The item's type. Typically the client uses this information to render the item in the UI with an icon.</haxe_doc>
			</type>
			<text>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If text is not falsy then it is inserted instead of the label.</haxe_doc>
			</text>
			<start>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>This value determines the location (in the CompletionsRequest's 'text' attribute) where the completion text is added.
		If missing the text is added at the location specified by the CompletionsRequest's 'column' attribute.</haxe_doc>
			</start>
			<sortText>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A string that should be used when comparing this item with other items. When `falsy` the label is used.</haxe_doc>
			</sortText>
			<selectionStart>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Determines the start of the new selection after the text has been inserted (or replaced).
		The start position must in the range 0 and length of the completion text.
		If omitted the selection starts at the end of the completion text.</haxe_doc>
			</selectionStart>
			<selectionLength>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Determines the length of the new selection after the text has been inserted (or replaced).
		The selection can not extend beyond the bounds of the completion text.
		If omitted the length is assumed to be 0.</haxe_doc>
			</selectionLength>
			<length>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>This value determines how many characters are overwritten by the completion text.
		If missing the value 0 is assumed which results in the completion text being inserted.</haxe_doc>
			</length>
			<label>
				<c path="String"/>
				<haxe_doc>The label of this completion item. By default this is also the text that is inserted when selecting this completion.</haxe_doc>
			</label>
		</a>
		<haxe_doc>CompletionItems are the suggestions returned from the CompletionsRequest.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.CompletionItemType" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<haxe_doc>Some predefined types for the CompletionItem. Please note that not all clients have specific icons for all of them.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.CompletionItemType_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Method public="1" get="inline" set="null" expr="cast &quot;method&quot;" line="2889" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "method"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Method>
	<Function public="1" get="inline" set="null" expr="cast &quot;function&quot;" line="2890" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "function"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Function>
	<Constructor public="1" get="inline" set="null" expr="cast &quot;constructor&quot;" line="2891" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "constructor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Constructor>
	<Field public="1" get="inline" set="null" expr="cast &quot;field&quot;" line="2892" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "field"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Field>
	<Variable public="1" get="inline" set="null" expr="cast &quot;variable&quot;" line="2893" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "variable"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Variable>
	<Class public="1" get="inline" set="null" expr="cast &quot;class&quot;" line="2894" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "class"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Class>
	<Interface public="1" get="inline" set="null" expr="cast &quot;interface&quot;" line="2895" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "interface"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Interface>
	<Module public="1" get="inline" set="null" expr="cast &quot;module&quot;" line="2896" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "module"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Module>
	<Property public="1" get="inline" set="null" expr="cast &quot;property&quot;" line="2897" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "property"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Property>
	<Unit public="1" get="inline" set="null" expr="cast &quot;unit&quot;" line="2898" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "unit"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Unit>
	<Value public="1" get="inline" set="null" expr="cast &quot;value&quot;" line="2899" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "value"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Value>
	<Enum public="1" get="inline" set="null" expr="cast &quot;enum&quot;" line="2900" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "enum"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Enum>
	<Keyword public="1" get="inline" set="null" expr="cast &quot;keyword&quot;" line="2901" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "keyword"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Keyword>
	<Snippet public="1" get="inline" set="null" expr="cast &quot;snippet&quot;" line="2902" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "snippet"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Snippet>
	<Text public="1" get="inline" set="null" expr="cast &quot;text&quot;" line="2903" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "text"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Text>
	<Color public="1" get="inline" set="null" expr="cast &quot;color&quot;" line="2904" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "color"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<File public="1" get="inline" set="null" expr="cast &quot;file&quot;" line="2905" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "file"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</File>
	<Reference public="1" get="inline" set="null" expr="cast &quot;reference&quot;" line="2906" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "reference"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Reference>
	<CustomColor public="1" get="inline" set="null" expr="cast &quot;customcolor&quot;" line="2907" static="1">
		<x path="vscode.debugProtocol.CompletionItemType"/>
		<meta>
			<m n=":value"><e>cast "customcolor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CustomColor>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.CompletionItemType_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Method public="1" get="inline" set="null" expr="cast &quot;method&quot;" line="2889" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "method"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Method>
		<Function public="1" get="inline" set="null" expr="cast &quot;function&quot;" line="2890" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "function"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Function>
		<Constructor public="1" get="inline" set="null" expr="cast &quot;constructor&quot;" line="2891" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "constructor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Constructor>
		<Field public="1" get="inline" set="null" expr="cast &quot;field&quot;" line="2892" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "field"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Field>
		<Variable public="1" get="inline" set="null" expr="cast &quot;variable&quot;" line="2893" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "variable"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Variable>
		<Class public="1" get="inline" set="null" expr="cast &quot;class&quot;" line="2894" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "class"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Class>
		<Interface public="1" get="inline" set="null" expr="cast &quot;interface&quot;" line="2895" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "interface"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Interface>
		<Module public="1" get="inline" set="null" expr="cast &quot;module&quot;" line="2896" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "module"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Module>
		<Property public="1" get="inline" set="null" expr="cast &quot;property&quot;" line="2897" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "property"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Property>
		<Unit public="1" get="inline" set="null" expr="cast &quot;unit&quot;" line="2898" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "unit"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Unit>
		<Value public="1" get="inline" set="null" expr="cast &quot;value&quot;" line="2899" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "value"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Value>
		<Enum public="1" get="inline" set="null" expr="cast &quot;enum&quot;" line="2900" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "enum"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Enum>
		<Keyword public="1" get="inline" set="null" expr="cast &quot;keyword&quot;" line="2901" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "keyword"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Keyword>
		<Snippet public="1" get="inline" set="null" expr="cast &quot;snippet&quot;" line="2902" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "snippet"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Snippet>
		<Text public="1" get="inline" set="null" expr="cast &quot;text&quot;" line="2903" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "text"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Text>
		<Color public="1" get="inline" set="null" expr="cast &quot;color&quot;" line="2904" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "color"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<File public="1" get="inline" set="null" expr="cast &quot;file&quot;" line="2905" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "file"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</File>
		<Reference public="1" get="inline" set="null" expr="cast &quot;reference&quot;" line="2906" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "reference"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Reference>
		<CustomColor public="1" get="inline" set="null" expr="cast &quot;customcolor&quot;" line="2907" static="1">
			<x path="vscode.debugProtocol.CompletionItemType"/>
			<meta>
				<m n=":value"><e>cast "customcolor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CustomColor>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vscode.debugProtocol.ChecksumAlgorithm" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<haxe_doc>Names of checksum algorithms that may be supported by a debug adapter.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.ChecksumAlgorithm_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<MD5 public="1" get="inline" set="null" expr="cast &quot;MD5&quot;" line="2914" static="1">
		<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
		<meta>
			<m n=":value"><e>cast "MD5"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MD5>
	<SHA1 public="1" get="inline" set="null" expr="cast &quot;SHA1&quot;" line="2915" static="1">
		<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
		<meta>
			<m n=":value"><e>cast "SHA1"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHA1>
	<SHA256 public="1" get="inline" set="null" expr="cast &quot;SHA256&quot;" line="2916" static="1">
		<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
		<meta>
			<m n=":value"><e>cast "SHA256"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHA256>
	<Timestamp public="1" get="inline" set="null" expr="cast &quot;timestamp&quot;" line="2917" static="1">
		<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
		<meta>
			<m n=":value"><e>cast "timestamp"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Timestamp>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.ChecksumAlgorithm_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<MD5 public="1" get="inline" set="null" expr="cast &quot;MD5&quot;" line="2914" static="1">
			<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
			<meta>
				<m n=":value"><e>cast "MD5"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MD5>
		<SHA1 public="1" get="inline" set="null" expr="cast &quot;SHA1&quot;" line="2915" static="1">
			<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
			<meta>
				<m n=":value"><e>cast "SHA1"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHA1>
		<SHA256 public="1" get="inline" set="null" expr="cast &quot;SHA256&quot;" line="2916" static="1">
			<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
			<meta>
				<m n=":value"><e>cast "SHA256"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHA256>
		<Timestamp public="1" get="inline" set="null" expr="cast &quot;timestamp&quot;" line="2917" static="1">
			<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
			<meta>
				<m n=":value"><e>cast "timestamp"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Timestamp>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.Checksum" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<checksum>
				<c path="String"/>
				<haxe_doc>Value of the checksum.</haxe_doc>
			</checksum>
			<algorithm>
				<x path="vscode.debugProtocol.ChecksumAlgorithm"/>
				<haxe_doc>The algorithm used to calculate this checksum.</haxe_doc>
			</algorithm>
		</a>
		<haxe_doc>The checksum of an item calculated by the specified algorithm.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ValueFormat" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a><hex>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Display the value in hex.</haxe_doc>
</hex></a>
		<haxe_doc>Provides formatting information for a value.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.StackFrameFormat" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<parameters>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Displays parameters for the stack frame.</haxe_doc>
			</parameters>
			<parameterValues>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Displays the values of parameters for the stack frame.</haxe_doc>
			</parameterValues>
			<parameterTypes>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Displays the types of parameters for the stack frame.</haxe_doc>
			</parameterTypes>
			<parameterNames>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Displays the names of parameters for the stack frame.</haxe_doc>
			</parameterNames>
			<module>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Displays the module of the stack frame.</haxe_doc>
			</module>
			<line>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Displays the line number of the stack frame.</haxe_doc>
			</line>
			<includeAll>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Includes all stack frames, including those the debug adapter might otherwise hide.</haxe_doc>
			</includeAll>
			<hex>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Display the value in hex.</haxe_doc>
			</hex>
		</a>
		<haxe_doc>Provides formatting information for a stack frame.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ExceptionOptions" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<path>
				<x path="Null"><c path="Array"><t path="vscode.debugProtocol.ExceptionPathSegment"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A path that selects a single or multiple exceptions in a tree. If 'path' is missing, the whole tree is selected. By convention the first segment of the path is a category that is used to group exceptions in the UI.</haxe_doc>
			</path>
			<breakMode>
				<x path="vscode.debugProtocol.ExceptionBreakMode"/>
				<haxe_doc>Condition when a thrown exception should result in a break.</haxe_doc>
			</breakMode>
		</a>
		<haxe_doc>An ExceptionOptions assigns configuration options to a set of exceptions.</haxe_doc>
	</typedef>
	<abstract path="vscode.debugProtocol.ExceptionBreakMode" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<this><c path="String"/></this>
		<haxe_doc>This enumeration defines all possible conditions when a thrown exception should result in a break.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vscode.debugProtocol._DebugProtocol.ExceptionBreakMode_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
	<Never public="1" get="inline" set="null" expr="cast &quot;never&quot;" line="3007" static="1">
		<x path="vscode.debugProtocol.ExceptionBreakMode"/>
		<meta>
			<m n=":value"><e>cast "never"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>never breaks</haxe_doc>
	</Never>
	<Always public="1" get="inline" set="null" expr="cast &quot;always&quot;" line="3012" static="1">
		<x path="vscode.debugProtocol.ExceptionBreakMode"/>
		<meta>
			<m n=":value"><e>cast "always"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>always breaks</haxe_doc>
	</Always>
	<Unhandled public="1" get="inline" set="null" expr="cast &quot;unhandled&quot;" line="3017" static="1">
		<x path="vscode.debugProtocol.ExceptionBreakMode"/>
		<meta>
			<m n=":value"><e>cast "unhandled"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>breaks when exception unhandled</haxe_doc>
	</Unhandled>
	<UserUnhandled public="1" get="inline" set="null" expr="cast &quot;userUnhandled&quot;" line="3022" static="1">
		<x path="vscode.debugProtocol.ExceptionBreakMode"/>
		<meta>
			<m n=":value"><e>cast "userUnhandled"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>breaks if the exception is not handled by user code.</haxe_doc>
	</UserUnhandled>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vscode.debugProtocol._DebugProtocol.ExceptionBreakMode_Impl_" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" private="1" module="vscode.debugProtocol.DebugProtocol" extern="1">
		<Never public="1" get="inline" set="null" expr="cast &quot;never&quot;" line="3007" static="1">
			<x path="vscode.debugProtocol.ExceptionBreakMode"/>
			<meta>
				<m n=":value"><e>cast "never"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>never breaks</haxe_doc>
		</Never>
		<Always public="1" get="inline" set="null" expr="cast &quot;always&quot;" line="3012" static="1">
			<x path="vscode.debugProtocol.ExceptionBreakMode"/>
			<meta>
				<m n=":value"><e>cast "always"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>always breaks</haxe_doc>
		</Always>
		<Unhandled public="1" get="inline" set="null" expr="cast &quot;unhandled&quot;" line="3017" static="1">
			<x path="vscode.debugProtocol.ExceptionBreakMode"/>
			<meta>
				<m n=":value"><e>cast "unhandled"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>breaks when exception unhandled</haxe_doc>
		</Unhandled>
		<UserUnhandled public="1" get="inline" set="null" expr="cast &quot;userUnhandled&quot;" line="3022" static="1">
			<x path="vscode.debugProtocol.ExceptionBreakMode"/>
			<meta>
				<m n=":value"><e>cast "userUnhandled"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>breaks if the exception is not handled by user code.</haxe_doc>
		</UserUnhandled>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vscode.debugProtocol.ExceptionPathSegment" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<negate>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If false or missing this segment matches the names provided, otherwise it matches anything except the names provided.</haxe_doc>
			</negate>
			<names>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Depending on the value of 'negate' the names that should match or not match.</haxe_doc>
			</names>
		</a>
		<haxe_doc>An ExceptionPathSegment represents a segment in a path that is used to match leafs or nodes in a tree of exceptions. If a segment consists of more than one name, it matches the names provided if 'negate' is false or missing or it matches anything except the names provided if 'negate' is true.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.ExceptionDetails" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<typeName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Short type name of the exception object.</haxe_doc>
			</typeName>
			<stackTrace>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Stack trace at the time the exception was thrown.</haxe_doc>
			</stackTrace>
			<message>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Message contained in the exception.</haxe_doc>
			</message>
			<innerException>
				<x path="Null"><c path="Array"><t path="vscode.debugProtocol.ExceptionDetails"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Details of the exception contained by this exception, if any.</haxe_doc>
			</innerException>
			<fullTypeName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Fully-qualified type name of the exception object.</haxe_doc>
			</fullTypeName>
			<evaluateName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional expression that can be evaluated in the current scope to obtain the exception object.</haxe_doc>
			</evaluateName>
		</a>
		<haxe_doc>Detailed information about an exception that has occurred.</haxe_doc>
	</typedef>
	<typedef path="vscode.debugProtocol.DisassembledInstruction" params="" file="src/vscode/debugProtocol/DebugProtocol.hx" module="vscode.debugProtocol.DebugProtocol">
		<a>
			<symbol>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Name of the symbol that corresponds with the location of this instruction, if any.</haxe_doc>
			</symbol>
			<location>
				<x path="Null"><t path="vscode.debugProtocol.Source"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Source location that corresponds to this instruction, if any. Should always be set (if available) on the first instruction returned, but can be omitted afterwards if this instruction maps to the same source file as the previous instruction.</haxe_doc>
			</location>
			<line>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The line within the source location that corresponds to this instruction, if any.</haxe_doc>
			</line>
			<instructionBytes>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional raw bytes representing the instruction and its operands, in an implementation-defined format.</haxe_doc>
			</instructionBytes>
			<instruction>
				<c path="String"/>
				<haxe_doc>Text representing the instruction and its operands, in an implementation-defined format.</haxe_doc>
			</instruction>
			<endLine>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The end line of the range that corresponds to this instruction, if any.</haxe_doc>
			</endLine>
			<endColumn>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The end column of the range that corresponds to this instruction, if any.</haxe_doc>
			</endColumn>
			<column>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The column within the line that corresponds to this instruction, if any.</haxe_doc>
			</column>
			<address>
				<c path="String"/>
				<haxe_doc>The address of the instruction. Treated as a hex value if prefixed with '0x', or as a decimal value otherwise.</haxe_doc>
			</address>
		</a>
		<haxe_doc>Represents a single disassembled instruction.</haxe_doc>
	</typedef>
</haxe>